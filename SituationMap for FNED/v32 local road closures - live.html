<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Far North Emergency Situation Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }

    #map {
      height: 100vh;
      width: 100%;
    }

    .map-legend {
      background: rgba(255, 255, 255, 0.95);
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .map-legend h2 {
      font-size: 0.9rem;
      margin: 0 0 0.25rem;
    }

    .map-legend ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .map-legend li {
      margin: 0.1rem 0;
    }

    .layer-pill {
      display: inline-block;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #e0e0e0;
      margin-right: 0.25rem;
    }
	
	    .legend-item {
      display: flex;
      align-items: center;
      margin: 0.15rem 0;
    }

    .legend-swatch {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 0.4rem;
      border: 2px solid #ffffff;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
    }
.legend-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.25rem;
  width: 100%;
  font-size: 0.85rem;
  font-weight: 600;
  background: transparent;
  border: none;
  padding: 0;
  cursor: pointer;
}

.legend-title {
  flex: 1;
  text-align: left;
}

.legend-toggle-icon {
  font-size: 0.75rem;
  transition: transform 0.15s ease-in-out;
}

.map-legend.legend-collapsed .legend-toggle-icon {
  transform: rotate(-90deg);
}

.legend-content {
  margin-top: 0.35rem;
}

  </style>
</head>
<body>
  <div
    id="map"
    role="region"
    aria-label="Far North emergency situation map showing weather, tides, outages, warnings and community locations"
  ></div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // Base map
    var map = L.map("map", {
      center: [-35.15, 173.65], // Roughly Far North District
      zoom: 8
    });

    var osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // Overlay layer containers
    var layerMetServiceWarnings = L.layerGroup();
    var layerCivilDefenceAlerts = L.layerGroup();
    var layerPowerOutages = L.layerGroup();
    var layerWaterOutages = L.layerGroup();
    var layerRoadWarnings = L.layerGroup();
    var layerMarae = L.layerGroup();
    var layerCommunityHalls = L.layerGroup();
	var layerServiceCentres = L.layerGroup(); // new
	var layerSwimsafe = L.layerGroup();        // new
    var layerWeatherAreas = L.layerGroup();
    var layerTides = L.layerGroup();
    var layerRivers = L.layerGroup();
	 var layerEarthquakes = L.layerGroup(); // GeoNet earthquakes
   var layerGeoNetWarnings = L.layerGroup(); // GeoNet quake warnings (CAP)
   var layerLocalRoadClosures = L.layerGroup();


    // Add layers to control
    var baseLayers = {
      "OpenStreetMap": osm
    };

    var overlays = {
      "MetService Weather Warnings": layerMetServiceWarnings,
      "Civil Defence Alerts": layerCivilDefenceAlerts,
      "Power Outages": layerPowerOutages,
      "Water Outages": layerWaterOutages,
      "NZTA Road Warnings and Closures": layerRoadWarnings,
	  "Local Road Closures": layerLocalRoadClosures, // NEW
      "Marae locations": layerMarae,
      "Community Hall locations": layerCommunityHalls,
	  "Service Centre locations": layerServiceCentres, // new
	    "Swimsafe Locations": layerSwimsafe,              // new
      "Weather": layerWeatherAreas,
      "Tides": layerTides,
      "NRC River Data": layerRivers,
	   "GeoNet Earthquakes": layerEarthquakes,// new,
	         "GeoNet Quake Warnings (CAP)": layerGeoNetWarnings
    };

    var layersControl = L.control.layers(baseLayers, overlays, { collapsed: true }).addTo(map);


   


    // Helper: basic icon factory
    function makeIcon(color) {
      return L.divIcon({
        className: "custom-marker",
        html: '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:' + color + ';border:2px solid white;box-shadow:0 0 2px rgba(0,0,0,0.6);"></span>',
        iconSize: [16, 16],
        iconAnchor: [8, 8]
      });
    }

    // Helper: tide icon with direction arrow
function makeTideIcon(color, direction) {
  var arrowChar =
    direction === "rising" ? "⬆" :
    direction === "falling" ? "⬇" :
    "";

  var arrowHtml = arrowChar
    ? '<span style="margin-left:4px;font-size:18px;line-height:1;">' + arrowChar + "</span>"
    : "";

  return L.divIcon({
    className: "custom-marker custom-marker-tide",
    html:
      '<div style="display:flex;align-items:center;">' +
        '<span style="display:inline-block;width:14px;height:14px;border-radius:50%;background:' +
          color +
          ';border:2px solid white;box-shadow:0 0 2px rgba(0,0,0,0.6);"></span>' +
        arrowHtml +
      "</div>",
    iconSize: [28, 22],
    iconAnchor: [14, 11]
  });
}



    // Marker style configuration
    // Polygons have their own styling further down
    var MARKER_CONFIG = {
      weatherAreas: {
        color: "#1976d2"
      },
      tides: {
        // Default tide marker colour
        defaultColor: "#009688",
        // Optional different colours by tide state if your data includes it
        // For example site.state or site.tideType
        colorByState: {
          high: "#2196f3",
          low: "#ff9800"
        }
      },
      powerOutages: {
        // Keys match statusType passed into colourForStatus
        unplanned: "#e91e63",
        plannedActive: "#d81b60",
        planned: "#ffb300",
        defaultColor: "#9e9e9e"
      },
      waterOutages: {
        defaultColor: "#2196f3",
        // Keys match item.status from the asset listing
        colorByStatus: {
          "New": " #0277bd",
          "Reported": "#0288d1",
          "Under repairs": "#f57c00",
          "Planned": "#7b1fa2",
          "Restored": "#2e7d32"
        }
      },
      nzta: {
        // Point marker colours by NZTA event type
        point: {
          closures: "#b71c1c",
          warnings: "#ff9800",
          roadworks: "#009688",
          hazards: "#ff5722",
          defaultColor: "#1976d2"
        }
      },
      marae: {
        color: "#795548"
      },
      communityHalls: {
        color: "#9c27b0"
      },
      serviceCentres: {
        color: "#ff9800"   // new service centre colour
      },
      rivers: {
        // Colour by flow or trend from Icon.Name
        defaultColor: "#4caf50",
        colorByTrend: {
          rising: "#1976d2",
          falling: "#f44336"
        }
      },
swimsafe: {
  defaultColor: "#00bcd4",
  colorByRiskClass: {
    // Very low
    "risk-vlow-overall": "#4caf50",
    "risk-vlow-weekly": "#4caf50",
    "risk-vlow-special": "#4caf50",

    // Low
    "risk-low-overall": "#8bc34a",
    "risk-low-weekly": "#cddc39",
    "risk-low-special": "#cddc39",

    // Medium / moderate
    "risk-medium-overall": "#ff9800",
    "risk-medium-weekly": "#ff9800",
    "risk-medium-special": "#ff9800",

    // High
    "risk-high-overall": "#f44336",
    "risk-high-weekly": "#f44336",
    "risk-high-special": "#f44336",

    // No data
    "nodata-overall": "#9e9e9e"
  }
},
      earthquakes: {
        // Colours by magnitude band
        minor: "#4caf50",      // mag < 2.5
        light: "#ff9800",      // 2.5 ≤ mag < 4
        moderate: "#f44336",   // mag ≥ 4
        defaultColor: "#795548"
        },
		localRoadClosures: {
    color: "#b71c1c" // dark red for local closures
  },
       geonetCap: {
         // Marker / circle colour for GeoNet CAP quake warnings
         color: "#fbc02d"
       }
    };

// Legend configuration: which overlays contribute which legend items
var LEGEND_CONFIG = {
  "Weather": {
    group: "Weather",
    items: [
      { color: MARKER_CONFIG.weatherAreas.color, label: "Weather location" }
    ]
  },
  "Tides": {
    group: "Tides",
    items: [
      { color: MARKER_CONFIG.tides.defaultColor, label: "Tide site" },
      {
        color: (MARKER_CONFIG.tides.colorByState && MARKER_CONFIG.tides.colorByState.high) || "#2196f3",
        label: "High tide phase"
      },
      {
        color: (MARKER_CONFIG.tides.colorByState && MARKER_CONFIG.tides.colorByState.low) || "#ff9800",
        label: "Low tide phase"
      }
    ]
  },
  "Power Outages": {
    group: "Power outages (Top Energy)",
    items: [
      { color: MARKER_CONFIG.powerOutages.unplanned, label: "Unplanned outage" },
      { color: MARKER_CONFIG.powerOutages.plannedActive, label: "Planned outage active" },
      { color: MARKER_CONFIG.powerOutages.planned, label: "Planned outage scheduled" }
    ]
  },
  "Water Outages": {
    group: "Water outages (FNDC)",
    items: [
      {
        color: MARKER_CONFIG.waterOutages.colorByStatus["New"],
        label: "New"
      },
      {
        color: MARKER_CONFIG.waterOutages.colorByStatus["Reported"],
        label: "Reported"
      },
      {
        color: MARKER_CONFIG.waterOutages.colorByStatus["Under repairs"],
        label: "Under repairs"
      },
      {
        color: MARKER_CONFIG.waterOutages.colorByStatus["Planned"],
        label: "Planned"
      },
      {
        color: MARKER_CONFIG.waterOutages.colorByStatus["Restored"],
        label: "Restored"
      }
    ]
  },
  "NZTA Road Warnings and Closures": {
    group: "Road events (NZTA)",
    items: [
      { color: MARKER_CONFIG.nzta.point.closures, label: "Closure" },
      { color: MARKER_CONFIG.nzta.point.warnings, label: "Warning or caution" },
      { color: MARKER_CONFIG.nzta.point.roadworks, label: "Roadworks" },
      { color: MARKER_CONFIG.nzta.point.hazards, label: "Hazard" }
    ]
  },  // NEW LEGEND GROUP
  "Local Road Closures": {
    group: "Road events (Local)",
    items: [
      {
        color: MARKER_CONFIG.localRoadClosures.color,
        label: "Local closure"
      }
    ]
  },
  "Marae locations": {
    group: "Community",
    items: [
      { color: MARKER_CONFIG.marae.color, label: "Marae" }
    ]
  },
  "Community Hall locations": {
    group: "Community",
    items: [
      { color: MARKER_CONFIG.communityHalls.color, label: "Community hall" }
    ]
  },
  "Service Centre locations": {
    group: "Community",
    items: [
      { color: MARKER_CONFIG.serviceCentres.color, label: "Service centre" }
    ]
  },
"Swimsafe Locations": {
  group: "Community",
  items: [
    {
      color: MARKER_CONFIG.swimsafe.colorByRiskClass["risk-vlow-overall"],
      label: "Very low risk"
    },
    {
      color: MARKER_CONFIG.swimsafe.colorByRiskClass["risk-low-weekly"],
      label: "Low risk"
    },
    {
      color: MARKER_CONFIG.swimsafe.colorByRiskClass["risk-medium-overall"],
      label: "Moderate risk"
    },
    {
      color: MARKER_CONFIG.swimsafe.colorByRiskClass["risk-high-overall"],
      label: "High risk"
    },
    {
      color: MARKER_CONFIG.swimsafe.colorByRiskClass["nodata-overall"],
      label: "No recent risk data"
    }
  ]
},
  "GeoNet Earthquakes": {
    group: "Earthquakes (GeoNet)",
    items: [
      { color: "#f44336", label: "Earthquake (size by magnitude)" }
    ]
  },
  "GeoNet Quake Warnings (CAP)": {
    group: "GeoNet warnings (CAP)",
    items: [
      { color: MARKER_CONFIG.geonetCap.color, label: "Quake warning area (CAP)" }
    ]
  },
  "NRC River Data": {
    group: "Rivers (NRC)",
    items: [
      { color: MARKER_CONFIG.rivers.defaultColor, label: "River site" },
      {
        color: (MARKER_CONFIG.rivers.colorByTrend && MARKER_CONFIG.rivers.colorByTrend.rising) || "#1976d2",
        label: "River rising"
      },
      {
        color: (MARKER_CONFIG.rivers.colorByTrend && MARKER_CONFIG.rivers.colorByTrend.falling) || "#f44336",
        label: "River falling"
      }
    ]
  },
  "MetService Weather Warnings": {
    group: "MetService weather warnings",
    items: [
      { color: "#f44336", label: "Severe weather polygon" }
    ]
  },
  "Civil Defence Alerts": {
    group: "Civil Defence alerts",
    items: [
      { color: "#ff9800", label: "Civil Defence alert area" }
    ]
  }
};

// Will hold a reference to the legend content element once the legend is added
var legendContentEl = null;

// Update legend content based on which overlays are currently visible
function updateLegend() {
  if (!legendContentEl) {
    return;
  }

  var groupsByName = {};
  var groupList = [];

  // Build grouped legend entries in overlay order
  Object.keys(overlays).forEach(function (overlayName) {
    var layer = overlays[overlayName];
    if (!map.hasLayer(layer)) {
      return;
    }

    var cfg = LEGEND_CONFIG[overlayName];
    if (!cfg) {
      return;
    }

    var groupName = cfg.group;
    var group = groupsByName[groupName];
    if (!group) {
      group = { name: groupName, items: [] };
      groupsByName[groupName] = group;
      groupList.push(group);
    }

    cfg.items.forEach(function (item) {
      group.items.push(item);
    });
  });

  if (!groupList.length) {
    legendContentEl.innerHTML =
      '<p style="margin:0;font-size:0.8rem;">No overlay layers are selected.</p>';
    return;
  }

  var html = "<ul>";
  groupList.forEach(function (group) {
    html += "<li><strong>" + group.name + "</strong></li>";
    group.items.forEach(function (item) {
      html +=
        '<li class="legend-item">' +
          '<span class="legend-swatch" style="background:' +
          item.color +
          ';"></span>' +
          item.label +
        "</li>";
    });
  });
  html += "</ul>";

  legendContentEl.innerHTML = html;
}

// Collapsible marker legend driven by visible overlay layers
var legend = L.control({ position: "bottomleft" });

legend.onAdd = function () {
  var div = L.DomUtil.create("div", "map-legend");

  div.innerHTML =
    '<button type="button" class="legend-toggle" aria-expanded="true">' +
      '<span class="legend-title">Legend</span>' +
      '<span class="legend-toggle-icon" aria-hidden="true">▾</span>' +
    "</button>" +
    '<div class="legend-content"></div>';

  legendContentEl = div.querySelector(".legend-content");

  var toggleBtn = div.querySelector(".legend-toggle");

  // Stop map drag when interacting with the legend
  L.DomEvent.disableClickPropagation(div);

  L.DomEvent.on(toggleBtn, "click", function (e) {
    L.DomEvent.stopPropagation(e);

    var expanded = toggleBtn.getAttribute("aria-expanded") === "true";
    var newExpanded = !expanded;

    toggleBtn.setAttribute("aria-expanded", newExpanded ? "true" : "false");

    if (newExpanded) {
      div.classList.remove("legend-collapsed");
      legendContentEl.style.display = "";
    } else {
      div.classList.add("legend-collapsed");
      legendContentEl.style.display = "none";
    }
  });

  // Populate initial legend content (in case any overlays are on by default)
  updateLegend();

  return div;
};

legend.addTo(map);

// Keep legend in sync with layer visibility
map.on("overlayadd", function () {
  updateLegend();
});
map.on("overlayremove", function () {
  updateLegend();
});


// NZTA event visibility by feature.properties.type
// Valid values in delays.json are usually: closures, warnings, roadworks, hazards
var NZTA_EVENT_TYPE_VISIBILITY = {
  closures: true,
  warnings: true,
  roadworks: true,
  hazards: true
};

function nztaEventIsVisible(feature) {
  var p = feature && feature.properties ? feature.properties : {};
  var typeKey = (p.type || "").toLowerCase();

  // If there is no type just show it
  if (!typeKey) return true;

  if (Object.prototype.hasOwnProperty.call(NZTA_EVENT_TYPE_VISIBILITY, typeKey)) {
    return !!NZTA_EVENT_TYPE_VISIBILITY[typeKey];
  }

  // Unknown type defaults to visible
  return true;
}


        // 1. Weather From Open Meteo For Key Locations

    // Live Open Meteo API for six Far North locations
    var OPEN_METEO_URL =
      "https://api.open-meteo.com/v1/forecast?latitude=-35.111,-35.415307,-35.1034116,-35.27075,-34.834066,-34.511518,-35.2268,-35.4022&longitude=173.265,173.797135,173.7109356,173.215174,173.106533,172.890875,173.9472,173.5041&daily=weather_code&hourly=precipitation_probability,precipitation,rain,weather_code,wind_speed_10m,wind_gusts_10m,temperature_2m,relative_humidity_2m&current=temperature_2m,relative_humidity_2m,apparent_temperature,wind_speed_10m,wind_direction_10m,weather_code,wind_gusts_10m,precipitation&timezone=Pacific%2FAuckland&forecast_days=3";

    // Local test option: use your saved Open Meteo response file instead of live API
    // var OPEN_METEO_URL = "forecast.json";

    // Locations in the same order as the Open Meteo latitude and longitude lists
    var WEATHER_LOCATIONS = [
      { name: "Kaitaia",     lat: -35.111,     lng: 173.265 },
      { name: "Kaikohe",     lat: -35.415307,  lng: 173.797135 },
	  { name: "Kerikeri",     lat: -35.2268,  lng: 173.9472 },
	  { name: "Rawene",     lat: -35.4022,  lng: 173.5041 },
      { name: "Kaeo",        lat: -35.1034116, lng: 173.7109356 },
      { name: "Herekino",    lat: -35.27075,   lng: 173.215174 },
      { name: "Waiharara",   lat: -34.834066,  lng: 173.106533 },
      { name: "Cape Reinga", lat: -34.511518,  lng: 172.890875 }
    ];

    // Translate WMO weather code to a simple description
    function wmoToText(code) {
      var map = {
        0:  "Clear sky",
        1:  "Mainly clear",
        2:  "Partly cloudy",
        3:  "Overcast",
        45: "Fog",
        48: "Depositing rime fog",
        51: "Light drizzle",
        53: "Moderate drizzle",
        55: "Dense drizzle",
        56: "Light freezing drizzle",
        57: "Dense freezing drizzle",
        61: "Slight rain",
        63: "Moderate rain",
        65: "Heavy rain",
        66: "Light freezing rain",
        67: "Heavy freezing rain",
        71: "Slight snowfall",
        73: "Moderate snowfall",
        75: "Heavy snowfall",
        77: "Snow grains",
        80: "Slight rain showers",
        81: "Moderate rain showers",
        82: "Violent rain showers",
        85: "Slight snow showers",
        86: "Heavy snow showers",
        95: "Thunderstorm",
        96: "Thunderstorm with slight hail",
        99: "Thunderstorm with heavy hail"
      };
      return map[code] || "Unknown conditions";
    }

    function buildWeatherPopupHtml(site, forecast) {
      var current = forecast.current || {};
      var dailyCode =
        forecast.daily &&
        Array.isArray(forecast.daily.weather_code) &&
        forecast.daily.weather_code.length
          ? forecast.daily.weather_code[0]
          : null;

      var currentDesc =
        typeof current.weather_code === "number"
          ? wmoToText(current.weather_code)
          : "";

      var dailyDesc =
        typeof dailyCode === "number"
          ? wmoToText(dailyCode)
          : "";

      var html =
        "<strong>" + site.name + "</strong><br>" +
        (currentDesc ? "Now: " + currentDesc + "<br>" : "") +
        "Temperature: " +
        (current.temperature_2m != null
          ? current.temperature_2m.toFixed(1) + " °C"
          : "n/a") +
        "<br>" +
        "Feels like: " +
        (current.apparent_temperature != null
          ? current.apparent_temperature.toFixed(1) + " °C"
          : "n/a") +
        "<br>" +
        "Humidity: " +
        (current.relative_humidity_2m != null
          ? current.relative_humidity_2m + " %"
          : "n/a") +
        "<br>" +
        "Wind: " +
        (current.wind_speed_10m != null
          ? current.wind_speed_10m + " km/h"
          : "n/a") +
        (current.wind_direction_10m != null
          ? " (" + current.wind_direction_10m + "°)"
          : "") +
        "<br>";

      if (current.wind_gusts_10m != null) {
        html += "Gusts: " + current.wind_gusts_10m + " km/h<br>";
      }

      if (current.precipitation != null) {
        html += "Precipitation: " + current.precipitation + " mm<br>";
      }

      if (dailyDesc) {
        html += "<br>Today: " + dailyDesc;
      }

      return html;
    }

    function addWeatherMarker(site, forecast) {
      var popupHtml = buildWeatherPopupHtml(site, forecast);

      var marker = L.marker([site.lat, site.lng], {
        icon: makeIcon(MARKER_CONFIG.weatherAreas.color)
      });

      // Hover popup behaviour for the Weather layer
      marker.bindPopup(popupHtml);
      marker.on("mouseover", function () {
        this.openPopup();
      });
      marker.on("mouseout", function () {
        this.closePopup();
      });

      layerWeatherAreas.addLayer(marker);
    }

    function loadWeatherFromOpenMeteo() {
      fetch(OPEN_METEO_URL)
        .then(function (res) {
          return res.json();
        })
        .then(function (data) {
          // Open Meteo multi location responses are an array
          // Your saved forecast.json has this format
          var forecasts = Array.isArray(data) ? data : [data];

          if (!forecasts.length) {
            console.warn("Open Meteo weather data empty");
            return;
          }

          WEATHER_LOCATIONS.forEach(function (site, idx) {
            var forecast = forecasts[idx];
            if (!forecast || !forecast.current) {
              return;
            }
            addWeatherMarker(site, forecast);
          });
        })
        .catch(function (err) {
          console.warn("Open Meteo weather load failed", err);
        });
    }

    // Kick off weather load
    loadWeatherFromOpenMeteo();


        // 2. Tides from NIWA Tide API and CSV locations

    // CSV containing place name and coordinates
    // Format (single header, then repeating "Name,lat,lng" groups):
    // Place, Latitude, Longitude Cape Maria van Diemen,-34.40...,172.62... Ngatehe Point,-34.52...,173.41...
    var TIDES_CSV_URL =
      "https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/Testing/Tides%20-%20Tides.csv";

    // NIWA Tides API endpoint and key
    var NIWA_TIDES_API_URL = "https://api.niwa.co.nz/tides/data";
    var NIWA_TIDES_API_KEY = "qMPsVJPmEXB1b0YQtGJE5i9bnzOWOq1O";

    // Build NIWA request URL for one site, wrapped through CORS proxy
    function buildNiwaTideUrl(lat, lng) {
      var now = new Date();
      var startDate = now.toISOString().slice(0, 10); // yyyy-mm-dd (UTC)

      var baseUrl =
        NIWA_TIDES_API_URL +
        "?lat=" +
        encodeURIComponent(lat) +
        "&long=" +
        encodeURIComponent(lng) +
        "&numberOfDays=2" +
        "&startDate=" +
        encodeURIComponent(startDate) +
        "&datum=LAT" +
        "&apikey=" +
        encodeURIComponent(NIWA_TIDES_API_KEY);

      // Use same proxy pattern as other feeds
      return "https://corsproxy.io/?url=" + encodeURIComponent(baseUrl);
    }

    // Parse your compact CSV into [{ name, lat, lng }, ...]
    function parseTideCsv(text) {
      if (!text) {
        return [];
      }

      var raw = text.trim();

      // Remove header "Place, Latitude, Longitude"
      raw = raw.replace(/^Place,\s*Latitude,\s*Longitude\s*/i, "");

      var sites = [];

      // Remaining string is repeating: Name,lat,lng [space] Name2,lat2,lng2 ...
      while (raw.length) {
        var firstComma = raw.indexOf(",");
        if (firstComma === -1) {
          break;
        }
        var name = raw.slice(0, firstComma).trim();
        var rest = raw.slice(firstComma + 1).trim();

        var secondComma = rest.indexOf(",");
        if (secondComma === -1) {
          break;
        }
        var latStr = rest.slice(0, secondComma).trim();
        rest = rest.slice(secondComma + 1).trim();

        var nextSpace = rest.indexOf(" ");
        var lngStr;
        var remainder;
        if (nextSpace === -1) {
          lngStr = rest.trim();
          remainder = "";
        } else {
          lngStr = rest.slice(0, nextSpace).trim();
          remainder = rest.slice(nextSpace + 1).trim();
        }

        var lat = parseFloat(latStr);
        var lng = parseFloat(lngStr);

        if (!isNaN(lat) && !isNaN(lng) && name) {
          sites.push({ name: name, lat: lat, lng: lng });
        }

        raw = remainder;
      }

      return sites;
    }

    // Normalise NIWA response into sorted [{ time: Date, height: number }, ...]
    function normaliseNiwaTideValues(data) {
      if (!data || !data.values) {
        return [];
      }

      var series = [];
      var rawValues = data.values;

      for (var i = 0; i < rawValues.length; i++) {
        var v = rawValues[i];
        var timeStr;
        var height;

        if (Array.isArray(v)) {
          timeStr = v[0];
          height = parseFloat(v[1]);
        } else {
          timeStr = v.time || v.dateTime || v[0];
          if (v.value != null) {
            height = parseFloat(v.value);
          } else if (v.height != null) {
            height = parseFloat(v.height);
          } else {
            height = parseFloat(v[1]);
          }
        }

        if (!timeStr || !isFinite(height)) {
          continue;
        }

        var t = new Date(timeStr);
        if (isNaN(t.getTime())) {
          continue;
        }

        series.push({ time: t, height: height });
      }

      series.sort(function (a, b) {
        return a.time - b.time;
      });

      return series;
    }

    // Detect local high and low tide events from a height time series
    function detectTideEvents(series) {
      var events = [];
      if (!series || series.length < 3) {
        return events;
      }

      for (var i = 1; i < series.length - 1; i++) {
        var prev = series[i - 1];
        var cur = series[i];
        var next = series[i + 1];

        var type = null;
        if (cur.height >= prev.height && cur.height >= next.height) {
          type = "H"; // high
        } else if (cur.height <= prev.height && cur.height <= next.height) {
          type = "L"; // low
        }

        if (type) {
          events.push({
            type: type,
            time: cur.time,
            height: cur.height
          });
        }
      }

      return events;
    }

    // Summarise: last high, last low, next high, next low, and current height
        // Summarise: last high, last low, next high, next low, and current height
    function summariseTideState(series) {
      var events = detectTideEvents(series);
      if (!events.length) {
        return null;
      }

      var now = new Date();

      var lastEvent = null;
      var nextEvent = null;
      var lastHigh = null;
      var nextHigh = null;
      var lastLow = null;
      var nextLow = null;

      for (var i = 0; i < events.length; i++) {
        var e = events[i];

        if (e.time <= now) {
          if (!lastEvent || e.time > lastEvent.time) {
            lastEvent = e;
          }
          if (e.type === "H" && (!lastHigh || e.time > lastHigh.time)) {
            lastHigh = e;
          }
          if (e.type === "L" && (!lastLow || e.time > lastLow.time)) {
            lastLow = e;
          }
        }

        if (e.time >= now) {
          if (!nextEvent || e.time < nextEvent.time) {
            nextEvent = e;
          }
          if (e.type === "H" && (!nextHigh || e.time < nextHigh.time)) {
            nextHigh = e;
          }
          if (e.type === "L" && (!nextLow || e.time < nextLow.time)) {
            nextLow = e;
          }
        }
      }

      var currentHeight = null;
      var betweenPercent = null;

      if (
        lastEvent &&
        nextEvent &&
        nextEvent.time.getTime() > lastEvent.time.getTime()
      ) {
        var totalMs = nextEvent.time.getTime() - lastEvent.time.getTime();
        var elapsedMs = now.getTime() - lastEvent.time.getTime();
        var frac = elapsedMs / totalMs;

        if (frac < 0) {
          frac = 0;
        }
        if (frac > 1) {
          frac = 1;
        }

        betweenPercent = Math.round(frac * 100);
        currentHeight =
          lastEvent.height + frac * (nextEvent.height - lastEvent.height);
      }

      // Determine tide direction (going in or out) from last and next events
      var direction = null;
      if (lastEvent && nextEvent) {
        if (lastEvent.type === "L" && nextEvent.type === "H") {
          direction = "rising"; // tide coming in
        } else if (lastEvent.type === "H" && nextEvent.type === "L") {
          direction = "falling"; // tide going out
        }
      }

      return {
        lastHigh: lastHigh,
        lastLow: lastLow,
        nextHigh: nextHigh,
        nextLow: nextLow,
        currentHeight: currentHeight,
        betweenPercent: betweenPercent,
        direction: direction
      };
    }


 function formatTideTime(evt) {
  if (!evt || !evt.time) {
    return "n/a";
  }
  var d = evt.time;
  var timeStr = d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  var day = String(d.getDate()).padStart(2, "0");
  var month = String(d.getMonth() + 1).padStart(2, "0");
  return timeStr + " " + day + "/" + month;
}


    function formatTideHeight(evt) {
      if (!evt || typeof evt.height !== "number" || isNaN(evt.height)) {
        return "";
      }
      return evt.height.toFixed(2) + " m";
    }

    function formatCurrentHeight(h) {
      if (typeof h !== "number" || !isFinite(h)) {
        return "n/a";
      }
      return h.toFixed(2) + " m";
    }

       function addTideMarker(site, summary) {
  var direction = summary.direction;
  var arrowChar =
    direction === "rising" ? "⬆" :
    direction === "falling" ? "⬇" :
    "•";

  var directionLabel =
    direction === "rising"
      ? "Incoming (rising)"
      : direction === "falling"
      ? "Outgoing (falling)"
      : "Unknown";

  // Collect last/next high and low then sort chronologically
  var events = [
    { label: "Last high", evt: summary.lastHigh },
    { label: "Last low",  evt: summary.lastLow },
    { label: "Next high", evt: summary.nextHigh },
    { label: "Next low",  evt: summary.nextLow }
  ].filter(function (item) {
    return item.evt && item.evt.time;
  });

  events.sort(function (a, b) {
    return a.evt.time - b.evt.time;
  });

  var eventsHtml = events.map(function (item) {
    var timeStr = formatTideTime(item.evt);
    var heightStr = formatTideHeight(item.evt);
    if (heightStr) {
      return "<strong>" + item.label + ":</strong> " + timeStr + " (" + heightStr + ")";
    }
    return "<strong>" + item.label + ":</strong> " + timeStr;
  }).join("<br>");

  var popupHtml =
    "<strong>" + site.name + "</strong><br>" +
    "Estimated current height: " +
    formatCurrentHeight(summary.currentHeight) +
    "<br>" +
    "Tide direction: " + arrowChar + " " + directionLabel + "<br>" +
    (summary.betweenPercent != null
      ? "Between last and next tide: " +
        summary.betweenPercent +
        "% of the way<br><br>"
      : "<br>") +
    eventsHtml;

  // Use tide specific icon with arrow
  var marker = L.marker([site.lat, site.lng], {
    icon: makeTideIcon(MARKER_CONFIG.tides.defaultColor, direction)
  }).bindPopup(popupHtml);

  layerTides.addLayer(marker);
}


    function loadTides() {
      fetch(TIDES_CSV_URL)
        .then(function (res) {
          return res.text();
        })
        .then(function (csvText) {
          var sites = parseTideCsv(csvText);
          if (!sites.length) {
            console.warn("No tide sites parsed from CSV");
            return;
          }

          sites.forEach(function (site) {
            var url = buildNiwaTideUrl(site.lat, site.lng);

            fetch(url)
              .then(function (res) {
                return res.json();
              })
              .then(function (data) {
                var series = normaliseNiwaTideValues(data);
                if (!series.length) {
                  return;
                }
                var summary = summariseTideState(series);
                if (!summary) {
                  return;
                }
                addTideMarker(site, summary);
              })
              .catch(function (err) {
                console.warn("Tide data load failed for site", site.name, err);
              });
          });
        })
        .catch(function (err) {
          console.warn("Tide CSV load failed", err);
        });
    }

    // Kick off tide load
    loadTides();


    // 3. MetService Severe Weather Watches, Warnings and Advisories (Atom + CAP)
var METSERVICE_ATOM_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/alerts/archive/latest_2025-11-08T06-24-52-084Z.xml");

// Colour helper based on title text
function metserviceColourForTitle(title) {
  var t = (title || "").toLowerCase();
  var color = "#1976d2";

  if (t.indexOf("warning") !== -1) {
    color = "#f44336";
  }
  if (t.indexOf("watch") !== -1) {
    color = "#2196f3";
  }
  if (t.indexOf("orange") !== -1) {
    color = "#ff9800";
  }
  if (t.indexOf("red") !== -1) {
    color = "#b71c1c";
  }

  return color;
}

// Use your existing Far North bounding box if available
function polygonTouchesFarNorth(latlngs) {
  if (typeof isInFarNorth !== "function") {
    return true; // if no helper, keep everything
  }
  for (var i = 0; i < latlngs.length; i++) {
    var pt = latlngs[i];
    if (isInFarNorth(pt[0], pt[1])) {
      return true;
    }
  }
  return false;
}

function loadMetserviceWeatherAlerts(atomUrl, targetLayer) {
  fetch(atomUrl)
    .then(function (res) { return res.text(); })
    .then(function (atomText) {
      var parser = new DOMParser();
      var atom = parser.parseFromString(atomText, "application/xml");

      var entries = atom.getElementsByTagName("entry");
      var tasks = [];

      for (var i = 0; i < entries.length; i++) {
        (function (entry) {
          var titleEl = entry.getElementsByTagName("title")[0];
          var summaryEl = entry.getElementsByTagName("summary")[0];

          var links = entry.getElementsByTagName("link");
          var capLinkEl = null;
          for (var j = 0; j < links.length; j++) {
            var rel = links[j].getAttribute("rel") || "";
            var type = links[j].getAttribute("type") || "";
            if (type.indexOf("cap+xml") !== -1) {
              capLinkEl = links[j];
              break;
            }
          }
          if (!capLinkEl && links.length) {
            capLinkEl = links[0];
          }

          var title = titleEl ? titleEl.textContent : "MetService Weather Alert";
          var summary = summaryEl ? summaryEl.textContent : "";
          var capUrl = capLinkEl ? capLinkEl.getAttribute("href") : null;

          if (!capUrl) {
            return;
          }

          var proxiedCapUrl = "https://corsproxy.io/?url=" + encodeURIComponent(capUrl);

          var task = fetch(proxiedCapUrl)
            .then(function (res) { return res.text(); })
            .then(function (capText) {
              var capDoc = parser.parseFromString(capText, "application/xml");

              var infoEl = capDoc.getElementsByTagName("info")[0];
              if (!infoEl) {
                return;
              }

              var eventEl = infoEl.getElementsByTagName("event")[0];
              var headlineEl = infoEl.getElementsByTagName("headline")[0];
              var descriptionEl = infoEl.getElementsByTagName("description")[0];
              var effectiveEl = infoEl.getElementsByTagName("effective")[0];
              var expiresEl = infoEl.getElementsByTagName("expires")[0];

              var eventName = eventEl ? eventEl.textContent : title;
              var headline = headlineEl ? headlineEl.textContent : title;
              var description = descriptionEl ? descriptionEl.textContent : summary;
              var effective = effectiveEl ? effectiveEl.textContent : "";
              var expires = expiresEl ? expiresEl.textContent : "";

              var colour = metserviceColourForTitle(title || eventName);

              var areaEls = infoEl.getElementsByTagName("area");
              var polygonsAddedForAlert = 0;

              for (var a = 0; a < areaEls.length; a++) {
                var areaEl = areaEls[a];
                var areaDescEl = areaEl.getElementsByTagName("areaDesc")[0];
                var areaDesc = areaDescEl ? areaDescEl.textContent : "";
                var polyEls = areaEl.getElementsByTagName("polygon");

                if (!polyEls.length) {
                  continue;
                }

                for (var pIdx = 0; pIdx < polyEls.length; pIdx++) {
                  var coordsStr = polyEls[pIdx].textContent.trim();
                  if (!coordsStr) {
                    continue;
                  }

                  var pointPairs = coordsStr.split(/\s+/);
                  var latlngs = [];

                  for (var k = 0; k < pointPairs.length; k++) {
                    var pair = pointPairs[k].split(",");
                    if (pair.length !== 2) {
                      continue;
                    }
                    var lat = parseFloat(pair[0]);
                    var lng = parseFloat(pair[1]);
                    if (isNaN(lat) || isNaN(lng)) {
                      continue;
                    }
                    latlngs.push([lat, lng]);
                  }

                  if (!latlngs.length) {
                    continue;
                  }

                  // Only keep polygons that touch the Far North
                  if (!polygonTouchesFarNorth(latlngs)) {
                    continue;
                  }

                  var popupHtml =
                    "<strong>" + headline + "</strong><br>" +
                    "<em>" + eventName + "</em><br><br>" +
                    (areaDesc ? "<strong>Area:</strong> " + areaDesc + "<br><br>" : "") +
                    (description ? nl2br(description) + "<br><br>" : "") +
                    (effective ? "<strong>From:</strong> " + effective + "<br>" : "") +
                    (expires ? "<strong>Until:</strong> " + expires + "<br>" : "");

                  var polygon = L.polygon(latlngs, {
                    color: colour,
                    weight: 2,
                    fillOpacity: 0.15
                  }).bindPopup(popupHtml);

                  polygon.addTo(targetLayer);
                  polygonsAddedForAlert++;
                }
              }

              // Fallback marker when no polygons were added for this alert
              if (!polygonsAddedForAlert) {
                var marker = L.marker(map.getCenter(), {
                  icon: makeIcon(colour)
                }).bindPopup(
                  "<strong>" + headline + "</strong><br>" +
                  "<em>" + eventName + "</em><br><br>" +
                  (description ? nl2br(description) + "<br><br>" : "") +
                  (effective ? "<strong>From:</strong> " + effective + "<br>" : "") +
                  (expires ? "<strong>Until:</strong> " + expires + "<br>" : "")
                );
                targetLayer.addLayer(marker);
              }
            })
            .catch(function (err) {
              console.warn("MetService CAP alert load failed", err);
            });

          tasks.push(task);
        })(entries[i]);
      }

      return Promise.all(tasks);
    })
    .catch(function (err) {
      console.warn("MetService Atom feed load failed", err);
    });
}

// Load MetService feed
loadMetserviceWeatherAlerts(METSERVICE_ATOM_URL, layerMetServiceWarnings);


   // 4. Civil Defence Alerts from Atom + CAP feed
// Civil Defence Atom feed that embeds CAP alerts in <content>
var CIVIL_DEFENCE_ATOM_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://www.civildefence.govt.nz/home/rss");

// Optional helper if you want to reuse elsewhere
function nl2br(text) {
  return text ? text.replace(/\n/g, "<br>") : "";
}

function loadCivilDefenceAtomCap(url, targetLayer) {
  fetch(url)
    .then(function (res) { return res.text(); })
    .then(function (xmlText) {
      var parser = new DOMParser();
      var atom = parser.parseFromString(xmlText, "application/xml");

      var entries = atom.getElementsByTagName("entry");
      for (var i = 0; i < entries.length; i++) {
        var entry = entries[i];

        var titleEl = entry.getElementsByTagName("title")[0];
        var summaryEl = entry.getElementsByTagName("summary")[0];
        var linkEl = entry.getElementsByTagName("link")[0];
        var contentEl = entry.getElementsByTagName("content")[0];

        var title = titleEl ? titleEl.textContent : "Civil Defence Alert";
        var summaryText = summaryEl ? summaryEl.textContent : "";
        var linkHref = "";
        if (linkEl) {
          linkHref = linkEl.getAttribute("href") || linkEl.textContent;
        }

        var polygonsAdded = 0;

        if (contentEl) {
          // This is the CAP XML as text
          var capText = contentEl.textContent;
          if (capText) {
            var capDoc = parser.parseFromString(capText, "application/xml");

            var infoEl = capDoc.getElementsByTagName("info")[0];
            if (infoEl) {
              var headlineEl = infoEl.getElementsByTagName("headline")[0];
              var descriptionEl = infoEl.getElementsByTagName("description")[0];
              var areaEl = infoEl.getElementsByTagName("area")[0];

              var areaDescEl = areaEl ? areaEl.getElementsByTagName("areaDesc")[0] : null;
              var polyEls = areaEl ? areaEl.getElementsByTagName("polygon") : [];

              var headline = headlineEl ? headlineEl.textContent : title;
              var description = descriptionEl ? descriptionEl.textContent : summaryText;
              var areaDesc = areaDescEl ? areaDescEl.textContent : "";

              for (var j = 0; j < polyEls.length; j++) {
                var coordsStr = polyEls[j].textContent.trim();
                if (!coordsStr) {
                  continue;
                }

                var pointPairs = coordsStr.split(/\s+/);
                var latlngs = [];

                pointPairs.forEach(function (pair) {
                  var parts = pair.split(",");
                  if (parts.length !== 2) {
                    return;
                  }
                  var lat = parseFloat(parts[0]);
                  var lng = parseFloat(parts[1]);
                  if (isNaN(lat) || isNaN(lng)) {
                    return;
                  }
                  latlngs.push([lat, lng]);
                });

                if (!latlngs.length) {
                  continue;
                }

                var polygon = L.polygon(latlngs, {
                  color: "#ff9800",
                  weight: 2,
                  fillOpacity: 0.15
                });

                var popupHtml =
                  "<strong>" + headline + "</strong><br>" +
                  "<em>Civil Defence Mobile Alert</em><br><br>" +
                  (areaDesc ? "<strong>Areas:</strong> " + areaDesc + "<br><br>" : "") +
                  (description ? nl2br(description) + "<br><br>" : "") +
                  (!description && summaryText ? nl2br(summaryText) + "<br><br>" : "") +
                  (linkHref ? '<a href="' + linkHref + '" target="_blank" rel="noopener">View full alert</a>' : "");

                polygon.bindPopup(popupHtml);
                polygon.addTo(targetLayer);
                polygonsAdded++;
              }
            }
          }
        }

        // Fallback marker if no polygons found
        if (!polygonsAdded) {
          var marker = L.marker(map.getCenter(), {
            icon: makeIcon("#ff9800")
          }).bindPopup(
            "<strong>" + title + "</strong><br><br>" +
            (summaryText ? nl2br(summaryText) + "<br><br>" : "") +
            (linkHref ? '<a href="' + linkHref + '" target="_blank" rel="noopener">View full alert</a>' : "")
          );
          targetLayer.addLayer(marker);
        }
      }
    })
    .catch(function (err) {
      console.warn("Civil Defence Atom load failed", err);
    });
}

// Load Civil Defence feed
loadCivilDefenceAtomCap(CIVIL_DEFENCE_ATOM_URL, layerCivilDefenceAlerts);

// 5. Top Energy Power Outages - KMZ polygons + regions + outages

var TOP_ENERGY_OUTAGES_URL =  "https://corsproxy.io/?url=" +  encodeURIComponent("https://outages.topenergy.co.nz/api/outages");
var TOP_ENERGY_REGIONS_URL =  "https://outages.topenergy.co.nz/api/outages/regions";

var TOP_ENERGY_KMZ_URL =  "https://corsproxy.io/?url=" +  encodeURIComponent("https://outages.topenergy.co.nz/storage/kmz/polygonsActiveAll.kmz");


//var TOP_ENERGY_OUTAGES_URL =  "https://corsproxy.io/?url=" +  encodeURIComponent("https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/Testing/TopEnergy/outages%20(1028211125).json");
//var TOP_ENERGY_REGIONS_URL =  "https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/Testing/TopEnergy/regions%20(1028211125).json";

//var TOP_ENERGY_KMZ_URL =  "https://corsproxy.io/?url=" +  encodeURIComponent("https://github.com/almokinsgov/NZSHAPE/raw/refs/heads/main/Testing/TopEnergy/polygonsActiveAll%20(103421112025).kmz");

// Config to control which outage types are shown as pins
// Set a type to false to hide that type
var POWER_OUTAGE_TYPES_VISIBLE = {
  unplanned: true,
  plannedActive: true,
  planned: true
};

// 5.1 Load KMZ polygons as non interactive background
function addTopEnergyPolygons(kmzUrl, targetLayer) {
  if (typeof JSZip === "undefined") {
    console.warn("JSZip is required to parse KMZ polygons");
    return;
  }

  fetch(kmzUrl)
    .then(function (res) { return res.arrayBuffer(); })
    .then(function (arrayBuffer) {
      return JSZip.loadAsync(arrayBuffer);
    })
    .then(function (zip) {
      var kmlFile = zip.file("doc.kml");
      if (!kmlFile) {
        var candidates = zip.file(/\.kml$/i);
        if (candidates && candidates.length) {
          kmlFile = candidates[0];
        }
      }
      if (!kmlFile) {
        console.warn("No KML file found inside Top Energy KMZ");
        return null;
      }
      return kmlFile.async("string");
    })
    .then(function (kmlText) {
      if (!kmlText) {
        return;
      }
      var parser = new DOMParser();
      var kmlDoc = parser.parseFromString(kmlText, "application/xml");

      var placemarks = kmlDoc.getElementsByTagName("Placemark");
      for (var i = 0; i < placemarks.length; i++) {
        var pm = placemarks[i];
        var polygons = pm.getElementsByTagName("Polygon");
        for (var j = 0; j < polygons.length; j++) {
          var poly = polygons[j];
          var coordsEls = poly.getElementsByTagName("coordinates");
          if (!coordsEls.length) {
            continue;
          }
          var coordsText = coordsEls[0].textContent;
          if (!coordsText) {
            continue;
          }

          // KML coordinates: lon,lat,alt lon,lat,alt ...
          var pairs = coordsText.trim().split(/\s+/);
          var latlngs = [];
          for (var pIdx = 0; pIdx < pairs.length; pIdx++) {
            var parts = pairs[pIdx].split(",");
            if (parts.length < 2) {
              continue;
            }
            var lon = parseFloat(parts[0]);
            var lat = parseFloat(parts[1]);
            if (isNaN(lat) || isNaN(lon)) {
              continue;
            }
            latlngs.push([lat, lon]);
          }

          if (!latlngs.length) {
            continue;
          }

          // Polygons are visual only not selectable
          var polygon = L.polygon(latlngs, {
            color: "#e91e63",
            weight: 1,
            fillOpacity: 0.05,
            interactive: false
          });

          polygon.addTo(targetLayer);
        }
      }
    })
    .catch(function (err) {
      console.warn("Top Energy KMZ polygons load failed", err);
    });
}

// 5.2 Join outages to region details and create one pin per outage
function buildTopEnergyOutageMarkers(regionsData, outagesData, targetLayer) {
  // Build lookup of region details by id (regions.*[].name)
  var regionDetailsById = {};

  Object.keys(regionsData || {}).forEach(function (key) {
    var value = regionsData[key];
    if (!Array.isArray(value)) {
      return;
    }
    value.forEach(function (r) {
      if (!r || !r.name) {
        return;
      }
      // name in regions matches id in outages
      regionDetailsById[r.name] = r;
    });
  });

  // Use marker config for colours
  function colourForStatus(statusType) {
    var cfg = MARKER_CONFIG.powerOutages || {};
    if (statusType && cfg[statusType]) {
      return cfg[statusType];
    }
    return cfg.defaultColor || "#9e9e9e";
  }

  function statusLabel(statusType) {
    if (statusType === "unplanned") {
      return "Unplanned outage";
    }
    if (statusType === "plannedActive") {
      return "Planned outage (currently active)";
    }
    if (statusType === "planned") {
      return "Planned outage";
    }
    return "Outage";
  }

  function renderDetail(detail) {
    if (!detail) {
      return "<br>No additional detail available for this outage.";
    }

    var html = "";
    if (detail.circuitName) {
      html += "Circuit: " + detail.circuitName + "<br>";
    }
    if (detail.customersCurrentlyOff != null && detail.customersCurrentlyOff !== "") {
      html += "Customers affected: " + detail.customersCurrentlyOff + "<br>";
    }
    if (detail.startDateTime) {
      html += "From: " + detail.startDateTime + "<br>";
    }
    if (detail.endDateTime) {
      html += "Until: " + detail.endDateTime + "<br>";
    }
    if (detail.alternativeStartDateTime) {
      html += "Alt from: " + detail.alternativeStartDateTime + "<br>";
    }
    if (detail.alternativeEndDateTime) {
      html += "Alt until: " + detail.alternativeEndDateTime + "<br>";
    }
    if (detail.additionalInformation) {
      html += detail.additionalInformation + "<br>";
    }
    return html || "<br>No additional detail available for this outage.";
  }

  function addOutageMarkers(list, statusType) {
    if (!Array.isArray(list)) {
      return;
    }
    list.forEach(function (outage) {
      if (!outage || outage.lat == null || outage.lng == null || !outage.id) {
        return;
      }

      // Look up detail by matching outage.id to region name
      var detail = regionDetailsById[outage.id] || null;
      var colour = colourForStatus(statusType);

      var marker = L.circleMarker([outage.lat, outage.lng], {
        radius: 7,
        fillColor: colour,
        color: "#ffffff",
        weight: 1,
        fillOpacity: 0.9
      });

      var popupHtml =
        "<strong>Top Energy outage</strong><br>" +
        "Outage ID: " + outage.id + "<br>" +
        "Type: " + statusLabel(statusType) + "<br>" +
        renderDetail(detail);

      marker.bindPopup(popupHtml);
      marker.addTo(targetLayer);
    });
  }

  // Helper to check visibility config and add markers
  function addIfVisible(list, statusType) {
    if (!POWER_OUTAGE_TYPES_VISIBLE[statusType]) {
      return;
    }
    addOutageMarkers(list, statusType);
  }

  // Outages JSON has unplanned, planned and plannedActive lists of points
  // Config controls which types are shown
  addIfVisible(outagesData.unplanned, "unplanned");
  addIfVisible(outagesData.plannedActive, "plannedActive");
  addIfVisible(outagesData.planned, "planned");
}

// 5.3 Orchestrate Top Energy layer load
function loadTopEnergyOutages() {
  // Polygons as background
  addTopEnergyPolygons(TOP_ENERGY_KMZ_URL, layerPowerOutages);

  // Regions (detail) and outages (points) in parallel
  var regionsPromise = fetch(TOP_ENERGY_REGIONS_URL).then(function (res) { return res.json(); });
  var outagesPromise = fetch(TOP_ENERGY_OUTAGES_URL).then(function (res) { return res.json(); });

  Promise.all([regionsPromise, outagesPromise])
    .then(function (results) {
      var regionsData = results[0] || {};
      var outagesData = results[1] || {};
      buildTopEnergyOutageMarkers(regionsData, outagesData, layerPowerOutages);
    })
    .catch(function (err) {
      console.warn("Top Energy regions or outages load failed", err);
    });
}

// Kick off Top Energy load
loadTopEnergyOutages();

    <!-- 6. Water Outages from Asset Listing Code -->
    <!-- FNDC water outages asset listing feed, proxied for CORS -->
    var WATER_OUTAGES_URL =
      "https://corsproxy.io/?" +
      encodeURIComponent("https://www.fndc.govt.nz/services/water/Water-outage-updates/wateroutagesassetlistingfeed");

    // Which statuses to show on the map.
    // Adjust this list to include or exclude statuses such as "Restored"
    var WATER_OUTAGE_STATUS_FILTER = ["New", "Reported", "Under repairs", "Planned", "Restored"];

    function waterOutageStatusAllowed(status) {
      if (!status) {
        return false;
      }
      var trimmed = String(status).trim();
      return WATER_OUTAGE_STATUS_FILTER.indexOf(trimmed) !== -1;
    }
	   function waterOutageMarkerColor(status) {
      var cfg = MARKER_CONFIG.waterOutages || {};
      var key = String(status || "").trim();
      if (cfg.colorByStatus && cfg.colorByStatus[key]) {
        return cfg.colorByStatus[key];
      }
      return cfg.defaultColor || "#2196f3";
    }

    function loadWaterOutages() {
  fetch(WATER_OUTAGES_URL)
    .then(function (res) {
      // Asset listing feeds can sometimes be text rather than strict JSON
      return res.text();
    })
    .then(function (text) {
      var data;

      // Try to parse as JSON directly first
      try {
        data = JSON.parse(text);
      } catch (err) {
        // Fallback - FNDC asset feed can be a bare list of objects
        // and now often comes wrapped like "{{ ... },}"
        var trimmed = text.trim();

        // Handle new "{{ ... },}" wrapper pattern - drop the extra first "{"
        if (trimmed.indexOf("{{") === 0) {
          trimmed = trimmed.slice(1).trim();
        }

        // Remove a final "},}" wrapper - keeps the last object closing brace
        trimmed = trimmed.replace(/},\}\s*$/, "}");

        // Remove any simple trailing comma at the very end eg "...},"
        trimmed = trimmed.replace(/,\s*$/, "");

        // Wrap as an array if there are no [ ] brackets
        if (trimmed.charAt(0) !== "[") {
          trimmed = "[" + trimmed;
        }
        if (trimmed.charAt(trimmed.length - 1) !== "]") {
          trimmed = trimmed + "]";
        }

        try {
          data = JSON.parse(trimmed);
        } catch (err2) {
          console.warn("Could not parse water outages feed", err2);
          return;
        }
      }

      // If the feed ever switches to an object with an items array
      if (!Array.isArray(data) && data && Array.isArray(data.items)) {
        data = data.items;
      }

      if (!Array.isArray(data)) {
        console.warn("Water outages feed was not an array", data);
        return;
      }

      data.forEach(function (item) {
        if (!item) {
          return;
        }

        // Latitude / longitude
        var lat = parseFloat(item.latitude || item.lat);
        var lng = parseFloat(item.longitude || item.lng);
        if (!isFinite(lat) || !isFinite(lng)) {
          return;
        }

        // Status filter
        if (
          WATER_OUTAGE_STATUS_FILTER.length &&
          !waterOutageStatusAllowed(item.status)
        ) {
          return;
        }

        // Build popup HTML with all requested fields
        var popupHtml =
          "<strong>FNDC water outage</strong><br>" +
          (item.name ? "Name: " + item.name + "<br>" : "") +
          (item.status ? "Status: " + item.status + "<br>" : "") +
          (item.address ? "Address: " + item.address + "<br>" : "") +
          (item.datelodged ? "Date lodged: " + item.datelodged + "<br>" : "") +
          (item.dateresolved
            ? "Date resolved: " + item.dateresolved + "<br>"
            : "");

        if (item.details) {
          // details already contains HTML <p> tags
          popupHtml += "<br>" + item.details;
        }

        if (item.description) {
          popupHtml += "<br><em>" + item.description + "</em>";
        }

        // Add as a pin or marker to the water outages layer
        var marker = L.circleMarker([lat, lng], {
          radius: 6,
          fillColor: waterOutageMarkerColor(item.status),
          color: "#ffffff",
          weight: 1,
          fillOpacity: 0.9
        });

        marker.bindPopup(popupHtml);
        marker.addTo(layerWaterOutages);
      });
    })
    .catch(function (err) {
      console.warn("Water outages load failed", err);
    });
}



    // Kick off water outages load
    loadWaterOutages();


    // 7. Road Warnings, Closures and Roadworks from NZTA delays.json
// Live NZTA feed
var ROAD_WARNINGS_URL = "https://corsproxy.io/?url=https://www.journeys.nzta.govt.nz/assets/map-data-cache/delays.json";

// Optional: limit to Far North by simple bounding box
// Adjust if you want a different cut
function isInFarNorth(lat, lng) {
  // Rough box for Far North District
  // North of about -35.9 and west of about 174.4
  return lat > -48.9 && lat < -33.2 && lng > 167.1 && lng < 179.5;
}

// Use marker config colours for NZTA features
function nztaColorForFeature(feature) {
  var p = feature && feature.properties ? feature.properties : {};
  var cfg = MARKER_CONFIG.nzta.point;
  var typeKey = (p.type || "").toLowerCase();
  var color = cfg.defaultColor;

  // First prefer the type group if present
  if (typeKey && cfg[typeKey]) {
    color = cfg[typeKey];
  } else {
    // Fallback to simple text checks on Impact
    var impact = (p.Impact || "").toLowerCase();

    if (impact.indexOf("closed") !== -1 || impact.indexOf("closure") !== -1) {
      color = cfg.closures || color;
    } else if (
      impact.indexOf("warning") !== -1 ||
      impact.indexOf("caution") !== -1
    ) {
      color = cfg.warnings || color;
    } else if (impact.indexOf("work") !== -1) {
      color = cfg.roadworks || color;
    } else if (impact.indexOf("hazard") !== -1) {
      color = cfg.hazards || color;
    }
  }

  return color;
}

function nztaStyle(feature) {
  var color = nztaColorForFeature(feature);
  var p = feature && feature.properties ? feature.properties : {};
  var impact = (p.Impact || "").toLowerCase();

  var weight = 4;
  var dashArray = null;

  if (impact.indexOf("closed") !== -1 || impact.indexOf("closure") !== -1) {
    weight = 6;
  } else if (
    impact.indexOf("warning") !== -1 ||
    impact.indexOf("caution") !== -1
  ) {
    dashArray = "4 6";
  } else if (impact.indexOf("hazard") !== -1) {
    dashArray = "2 6";
  }

  return {
    color: color,
    weight: weight,
    dashArray: dashArray,
    opacity: 0.9
  };
}

// Use the shared divIcon style instead of circleMarker
function nztaPointToLayer(feature, latlng) {
  var color = nztaColorForFeature(feature);
  return L.marker(latlng, {
    icon: makeIcon(color, { className: "nzta-road-event" })
  });
}

function nztaOnEachFeature(feature, layer) {
  var p = feature.properties || {};

  var title =
    p.Name ||
    p.LocationArea ||
    "Road Event";

  var html = "<strong>" + title + "</strong><br>";

  if (p.EventType) {
    html += "Type: " + p.EventType + "<br>";
  }
  if (p.EventDescription) {
    html += "Description: " + p.EventDescription + "<br>";
  }
  if (p.EventComments) {
    html += p.EventComments + "<br><br>";
  }
  if (p.Impact) {
    html += "Impact: " + p.Impact + "<br>";
  }
  if (p.StartDateNice) {
    html += "From: " + p.StartDateNice + "<br>";
  }
  if (p.EndDateNice) {
    html += "To: " + p.EndDateNice + "<br>";
  }
  if (p.ExpectedResolution) {
    html += "Expected: " + p.ExpectedResolution + "<br>";
  }
  if (p.AlternativeRoute) {
    html += "Detour: " + p.AlternativeRoute + "<br>";
  }

  layer.bindPopup(html);
}

// NZTA delays
fetch(ROAD_WARNINGS_URL)
  .then(function (res) { return res.json(); })
  .then(function (geojson) {

    // Keep only Far North features and apply the event type filter
    var filtered = {
      type: "FeatureCollection",
      features: geojson.features.filter(function (f) {
        if (!f.geometry) return false;

        var g = f.geometry;

        // Spatial clip to Far North
        if (g.type === "Point") {
          var lng = g.coordinates[0];
          var lat = g.coordinates[1];
          if (!isInFarNorth(lat, lng)) return false;
        } else if (
          g.type === "MultiLineString" &&
          g.coordinates &&
          g.coordinates.length &&
          g.coordinates[0].length
        ) {
          var first = g.coordinates[0][0];
          var lng2 = first[0];
          var lat2 = first[1];
          if (!isInFarNorth(lat2, lng2)) return false;
        } else {
          // Ignore other geometry types for now
          return false;
        }

        // Apply NZTA event type visibility
        return nztaEventIsVisible(f);
      })
    };

    L.geoJSON(filtered, {
      style: nztaStyle,
      pointToLayer: nztaPointToLayer,
      onEachFeature: nztaOnEachFeature
    }).addTo(layerRoadWarnings);
  })
  .catch(function (err) {
    console.warn("NZTA delays load failed", err);
  });


// 8. Marae data (NZ wide from Māori Maps export)
var MARAE_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/alerts/Marae%20data%20-%20data2.json");

    function loadMaraeLayer(url, targetLayer) {
  fetch(url)
    .then(function (res) { return res.json(); })
    .then(function (data) {
      if (!Array.isArray(data)) {
        console.warn("Marae data is not an array");
        return;
      }

      data.forEach(function (marae) {
        var lat = marae.latitude;
        var lng = marae.longitude;

        if (lat == null || lng == null) {
          return;
        }

        // Optional filter to Far North only
        // if (typeof isInFarNorth === "function" && !isInFarNorth(lat, lng)) {
        //   return;
        // }

        var title = marae.title || "Marae";
        var link = marae.Link || "";
        var district = marae.District || "";
        var imageUrl = marae["Image URL"] || "";

        var marker = L.marker([lat, lng], {
          icon: makeIcon(MARKER_CONFIG.marae.color)
        });

        var popupHtml =
          "<strong>" + title + "</strong><br>" +
          (district ? "<em>" + district + "</em><br><br>" : "<br>") +
          (link ? '<a href="' + link + '" target="_blank" rel="noopener">View marae page</a><br><br>' : "");

        if (imageUrl) {
          popupHtml +=
            '<a href="' + imageUrl + '" target="_blank" rel="noopener">' +
              '<img src="' + imageUrl + '" alt="Image of ' + title + '" ' +
              'style="max-width:180px;max-height:120px;display:block;margin-top:4px;border-radius:4px;object-fit:cover;" />' +
            "</a>";
        }

        marker.bindPopup(popupHtml);
        targetLayer.addLayer(marker);
      });
    })
    .catch(function (err) {
      console.warn("Marae data load failed", err);
    });
}

// Load Marae layer
loadMaraeLayer(MARAE_URL, layerMarae);


        // 9. Community Halls from FNDC District Facilities (ArcGIS pgeojson)
    var HALLS_GEOJSON_URL =
      "https://corsproxy.io/?url=" +
      encodeURIComponent(
        "https://services5.arcgis.com/H4FlrMy6xTBd6Ywx/ArcGIS/rest/services/DistrictFacilities_FNDC_public/FeatureServer/0/query?where=1%3D1&objectIds=&geometry=&geometryType=esriGeometryPoint&inSR=4326&spatialRel=esriSpatialRelIntersects&resultType=none&distance=0.0&units=esriSRUnit_Meter&outDistance=&relationParam=&returnGeodetic=false&outFields=*&returnGeometry=true&featureEncoding=esriDefault&multipatchOption=xyFootprint&maxAllowableOffset=&geometryPrecision=&outSR=&defaultSR=&datumTransformation=&applyVCSProjection=false&returnIdsOnly=false&returnUniqueIdsOnly=false&returnCountOnly=false&returnExtentOnly=false&returnQueryGeometry=false&returnDistinctValues=false&cacheHint=false&collation=&orderByFields=&groupByFieldsForStatistics=&returnAggIds=false&outStatistics=&having=&resultOffset=&resultRecordCount=&returnZ=false&returnM=false&returnTrueCurves=false&returnExceededLimitFeatures=true&quantizationParameters=&sqlFormat=none&f=pgeojson&token="
      );

    fetch(HALLS_GEOJSON_URL)
      .then(function (res) { return res.json(); })
      .then(function (geojson) {
        if (!geojson || !Array.isArray(geojson.features)) {
          console.warn("Community halls geojson has no features");
          return;
        }

        L.geoJSON(geojson, {
          // Only keep features that are halls
          filter: function (feature) {
            var p = feature && feature.properties;
            if (!p || p.asset_sub_type == null) {
              return false;
            }
            return String(p.asset_sub_type).toLowerCase() === "hall";
          },

          // Use a location pin style icon
          pointToLayer: function (feature, latlng) {
            return L.marker(latlng, {
              icon: makeIcon(MARKER_CONFIG.communityHalls.color)
            });
          },

          // Build popup using asset name and basic details
          onEachFeature: function (feature, layer) {
            var p = feature.properties || {};
            var name = p.system_name || "Community Hall";
            var community = p.community || "";
            var location = p.location || "";
            var owner = p.asset_owner || "";
            var status = p.status || "";

            var popup =
              "<strong>" + name + "</strong><br>" +
              (community ? "<em>" + community + "</em><br>" : "") +
              (location ? "Location: " + location + "<br>" : "") +
              (owner ? "Owner: " + owner + "<br>" : "") +
              (status ? "Status: " + status + "<br>" : "");

            layer.bindPopup(popup);
          }
        }).addTo(layerCommunityHalls);
      })
      .catch(function (err) {
        console.warn("Community halls geojson load failed", err);
      });


   // 10. NRC river data (live API)
var NRC_RIVERS_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://env.gurudigital.nz/WebApi/GetMapPoints/2?collectionId=19");
// For local testing you can instead use:
// var NRC_RIVERS_URL = "rivers.json";

// Helper to pick a colour based on current river trend
function riverColourForStatus(site) {
  var name = site.Icon && site.Icon.Name ? site.Icon.Name.toLowerCase() : "";
  var cfg = MARKER_CONFIG.rivers || {};

  if (cfg.colorByTrend) {
    if (name.indexOf("rising") !== -1 && cfg.colorByTrend.rising) {
      return cfg.colorByTrend.rising;
    }
    if (name.indexOf("falling") !== -1 && cfg.colorByTrend.falling) {
      return cfg.colorByTrend.falling;
    }
  }

  return cfg.defaultColor || "#4caf50";
}


// Build popup HTML for an NRC river site
function buildRiverPopup(site) {
  var title = site.DisplayName || site.Name || "River site";

  var html = "<strong>" + title + "</strong><br>";

  // Short description and LAWA link (Summary is already HTML)
  if (site.Summary) {
    html += site.Summary + "<br>";
  }

  var primary = site.PrimaryMeasurement;
  var secondary = site.SecondaryMeasurement;
  var primaryValue = site.PrimaryValue;
  var secondaryValue = site.SecondaryValue;

  if (primary && primaryValue) {
    html += "<br><strong>" +
      (primary.DisplayName || primary.Name || "Level") +
      ":</strong> " + primaryValue.Value +
      (primary.Units ? " " + primary.Units : "") +
      (primaryValue.FormattedTime && primaryValue.FormattedDate
        ? " at " + primaryValue.FormattedTime + " " + primaryValue.FormattedDate
        : "") +
      "<br>";
  }

  if (secondary && secondaryValue) {
    html += "<strong>" +
      (secondary.DisplayName || secondary.Name || "Flow") +
      ":</strong> " + secondaryValue.Value +
      (secondary.Units ? " " + secondary.Units : "") +
      (secondaryValue.FormattedTime && secondaryValue.FormattedDate
        ? " at " + secondaryValue.FormattedTime + " " + secondaryValue.FormattedDate
        : "") +
      "<br>";
  }

  var drought = site.DroughtInfo;
  if (drought) {
    if (drought.MALFText) {
      html += "<br><strong>MALF:</strong> " + drought.MALFText + "<br>";
    }
    if (drought.DMFText) {
      html += "<strong>DMF:</strong> " + drought.DMFText + "<br>";
    }
    if (drought.PercentDiffDMF) {
      html += "<strong>Relative to DMF:</strong> " + drought.PercentDiffDMF + "<br>";
    }
  }

  if (site.WebCamUrl) {
    html += '<br><a href="' + site.WebCamUrl +
      '" target="_blank" rel="noopener">View webcam</a><br>';
  }

  if (site.Image && site.Image.URL) {
    var imgUrl = "https://env.gurudigital.nz/" + site.Image.URL.replace(/^\/?/, "");
    html +=
      '<br><a href="' + imgUrl + '" target="_blank" rel="noopener">' +
        '<img src="' + imgUrl + '" alt="Image for ' + title + '"' +
        ' style="max-width:200px;max-height:130px;display:block;margin-top:4px;' +
        ' border-radius:4px;object-fit:cover;" />' +
      "</a>";
  }

  return html;
}

function loadNrcRivers(url, targetLayer) {
  fetch(url)
    .then(function (res) { return res.json(); })
    .then(function (sites) {
      if (!Array.isArray(sites)) {
        console.warn("NRC river data is not an array");
        return;
      }

      sites.forEach(function (site) {
        if (!site.HasLocation || site.Latitude == null || site.Longitude == null) {
          return;
        }

        // Optional Far North filter if you want to clip to district
        // if (typeof isInFarNorth === "function" &&
        //     !isInFarNorth(site.Latitude, site.Longitude)) {
        //   return;
        // }

        var lat = site.Latitude;
        var lng = site.Longitude;

        var marker = L.marker([lat, lng], {
          icon: makeIcon(riverColourForStatus(site))
        });

        marker.bindPopup(buildRiverPopup(site));
        targetLayer.addLayer(marker);
      });
    })
    .catch(function (err) {
      console.warn("NRC river data load failed", err);
    });
}

// Load NRC river layer
loadNrcRivers(NRC_RIVERS_URL, layerRivers);
  // 11. GeoNet earthquakes - shallow events near Far North

  var GEONET_EARTHQUAKES_URL =
    "https://corsproxy.io/?url=" +
    encodeURIComponent(
      "https://wfs.geonet.org.nz/geonet/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=geonet:quake_search_v1&outputFormat=json&cql_filter=depth%3C50+AND+origintime%3E=%272025-01-01%27+AND+DWITHIN(origin_geom,Point+(173.5+-35.2),140000,meters)"
    );

  function earthquakeColor(magnitude) {
    var cfg = MARKER_CONFIG.earthquakes || {};
    var mag = parseFloat(magnitude);

    if (!isFinite(mag)) {
      return cfg.defaultColor || "#795548";
    }
    if (mag >= 4) {
      return cfg.moderate || cfg.defaultColor || "#f44336";
    }
    if (mag >= 2.5) {
      return cfg.light || cfg.defaultColor || "#ff9800";
    }
    return cfg.minor || cfg.defaultColor || "#4caf50";
  }

  function formatEarthquakeTime(origintime) {
    if (!origintime) {
      return "";
    }
    var d = new Date(origintime);
    if (isNaN(d.getTime())) {
      return origintime;
    }
    // Local browser time, readable string
    return d.toLocaleString();
  }

  function buildEarthquakePopup(props) {
    var mag = props.magnitude;
    var depth = props.depth;
    var timeStr = formatEarthquakeTime(props.origintime);
    var id = props.publicid;

    var html = "<strong>GeoNet earthquake</strong><br>";

    if (mag != null) {
      html += "Magnitude: " + mag.toFixed ? mag.toFixed(1) : mag + "<br>";
    }
    if (depth != null) {
      html += "Depth: " + depth + " km<br>";
    }
    if (timeStr) {
      html += "Time: " + timeStr + "<br>";
    }

    if (id) {
      // publicid is like "2025p660965"
      var quakeUrl =
        "https://www.geonet.org.nz/quake/" +
        encodeURIComponent(String(id));
      html +=
        '<br><a href="' +
        quakeUrl +
        '" target="_blank" rel="noopener">View on GeoNet</a>';
    }

    return html;
  }

  function loadGeonetEarthquakes(url, targetLayer) {
    fetch(url)
      .then(function (res) {
        return res.json();
      })
      .then(function (geojson) {
        if (!geojson || !Array.isArray(geojson.features)) {
          console.warn("GeoNet earthquakes data is not a FeatureCollection");
          return;
        }

        geojson.features.forEach(function (feature) {
          if (!feature || !feature.geometry || feature.geometry.type !== "Point") {
            return;
          }

          var coords = feature.geometry.coordinates;
          if (!Array.isArray(coords) || coords.length < 2) {
            return;
          }

          var lng = coords[0];
          var lat = coords[1];
          if (!isFinite(lat) || !isFinite(lng)) {
            return;
          }

          var props = feature.properties || {};
          var mag = parseFloat(props.magnitude);
          var color = earthquakeColor(mag);

          var radius = 5;
          if (isFinite(mag)) {
            radius = 3 + mag * 1.5;
            if (radius < 4) {
              radius = 4;
            }
            if (radius > 12) {
              radius = 12;
            }
          }

          var marker = L.circleMarker([lat, lng], {
            radius: radius,
            fillColor: color,
            color: "#ffffff",
            weight: 1,
            fillOpacity: 0.9
          });

          marker.bindPopup(buildEarthquakePopup(props));
          targetLayer.addLayer(marker);
        });
      })
      .catch(function (err) {
        console.warn("GeoNet earthquakes load failed", err);
      });
  }

  // Load GeoNet earthquakes layer
  loadGeonetEarthquakes(GEONET_EARTHQUAKES_URL, layerEarthquakes);
    // 9. GeoNet Quake Warnings (CAP feed)

    // Sample GeoNet CAP feed (using your example file through the CORS proxy)
    var GEONET_CAP_FEED_URL =
      "https://corsproxy.io/?url=" +
      encodeURIComponent(
        "https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/Testing/GeoNet/quake-example.xml"
      );

    function loadGeoNetWarningCap(url) {
      fetch(url)
        .then(function (res) {
          return res.text();
        })
        .then(function (xmlText) {
          var parser = new DOMParser();
          var capDoc = parser.parseFromString(xmlText, "application/xml");

          var infoEl = capDoc.getElementsByTagName("info")[0];
          if (!infoEl) {
            console.warn("GeoNet CAP: no <info> element found");
            return;
          }

          var eventEl = infoEl.getElementsByTagName("event")[0];
          var headlineEl = infoEl.getElementsByTagName("headline")[0];
          var descriptionEl = infoEl.getElementsByTagName("description")[0];
          var onsetEl = infoEl.getElementsByTagName("onset")[0];
          var expiresEl = infoEl.getElementsByTagName("expires")[0];

          var eventName = eventEl ? eventEl.textContent : "Earthquake";
          var headline = headlineEl ? headlineEl.textContent : eventName;
          var description = descriptionEl ? descriptionEl.textContent : "";
          var onset = onsetEl ? onsetEl.textContent : "";
          var expires = expiresEl ? expiresEl.textContent : "";

          // Build parameter map from <parameter><valueName>/<value>
          var params = infoEl.getElementsByTagName("parameter");
          var paramMap = {};
          for (var i = 0; i < params.length; i++) {
            var p = params[i];
            var valueNameEl = p.getElementsByTagName("valueName")[0];
            var valueEl = p.getElementsByTagName("value")[0];
            if (!valueNameEl || !valueEl) {
              continue;
            }
            paramMap[valueNameEl.textContent] = valueEl.textContent;
          }

          // Core coordinates from LatitudeLongitude parameter
          var latLngStr = paramMap.LatitudeLongitude || paramMap["LatitudeLongitude"];
          var lat = null;
          var lng = null;
          if (latLngStr) {
            var llParts = latLngStr.split(",");
            if (llParts.length === 2) {
              lat = parseFloat(llParts[0]);
              lng = parseFloat(llParts[1]);
            }
          }

          // Optional area circle "lat,lon radiusKm"
          var areaEl = infoEl.getElementsByTagName("area")[0];
          var circleEl = areaEl ? areaEl.getElementsByTagName("circle")[0] : null;
          var radiusKm = null;
          if (circleEl) {
            var circleText = circleEl.textContent.trim();
            var circleParts = circleText.split(" ");
            if (circleParts.length === 2) {
              var centreParts = circleParts[0].split(",");
              if ((!lat || !lng) && centreParts.length === 2) {
                lat = parseFloat(centreParts[0]);
                lng = parseFloat(centreParts[1]);
              }
              radiusKm = parseFloat(circleParts[1]);
            }
          }

          if (lat == null || isNaN(lat) || lng == null || isNaN(lng)) {
            console.warn("GeoNet CAP: no valid coordinates");
            return;
          }

          var magnitude = paramMap.Magnitude || paramMap["Magnitude"];
          var depth = paramMap.Depth || paramMap["Depth"];
          var locality = paramMap.Locality || paramMap["Locality"];
          var intensity = paramMap.Intensity || paramMap["Intensity"];
          var mmi = paramMap.MMI || paramMap["MMI"];
          var timeParam = paramMap.Time || paramMap["Time"];

          var webEl = infoEl.getElementsByTagName("web")[0];
          var webUrl = webEl ? webEl.textContent : "";

          var popupHtml =
            "<strong>" + headline + "</strong><br>" +
            "<em>" + eventName + "</em><br>" +
            (locality ? locality + "<br>" : "") +
            (magnitude ? "Magnitude: " + magnitude + "<br>" : "") +
            (depth ? "Depth: " + depth + " km<br>" : "") +
            (intensity ? "Intensity: " + intensity + "<br>" : "") +
            (mmi ? "MMI: " + mmi + "<br>" : "") +
            (timeParam ? "Origin time: " + timeParam + "<br>" : "") +
            (onset ? "Onset: " + onset + "<br>" : "") +
            (expires ? "Expires: " + expires + "<br>" : "") +
            (description ? "<br>" + description + "<br>" : "") +
            (webUrl
              ? '<br><a href="' + webUrl + '" target="_blank" rel="noopener">View details on GeoNet</a>'
              : "");

          var markerColor =
            MARKER_CONFIG.geonetCap && MARKER_CONFIG.geonetCap.color
              ? MARKER_CONFIG.geonetCap.color
              : "#fbc02d";

          // Centre marker for the quake warning
          var marker = L.marker([lat, lng], {
            icon: makeIcon(markerColor)
          }).bindPopup(popupHtml);

          layerGeoNetWarnings.addLayer(marker);

          // Optional CAP area circle
          if (radiusKm && isFinite(radiusKm)) {
            var circle = L.circle([lat, lng], {
              radius: radiusKm * 1000, // km to m
              color: markerColor,
              weight: 2,
              fillOpacity: 0.1
            });
            layerGeoNetWarnings.addLayer(circle);
          }
        })
        .catch(function (err) {
          console.warn("GeoNet CAP warning load failed", err);
        });
    }

    // Kick off GeoNet quake warning CAP load
    loadGeoNetWarningCap(GEONET_CAP_FEED_URL);

//  Service Centres (FNDC District Facilities)
// Uses the same ArcGIS pgeojson feed as Community Halls

// Reuse the same facilities URL you already use for community halls.
// If you named it differently, keep that name here.
var FACILITIES_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent(
    "https://services5.arcgis.com/H4FlrMy6xTBd6Ywx/ArcGIS/rest/services/DistrictFacilities_FNDC_public/FeatureServer/0/query?where=1%3D1&objectIds=&geometry=&geometryType=esriGeometryPoint&inSR=4326&spatialRel=esriSpatialRelIntersects&resultType=none&distance=0.0&units=esriSRUnit_Meter&outDistance=&relationParam=&returnGeodetic=false&outFields=*&returnGeometry=true&featureEncoding=esriDefault&multipatchOption=xyFootprint&maxAllowableOffset=&geometryPrecision=&outSR=&defaultSR=&datumTransformation=&applyVCSProjection=false&returnIdsOnly=false&returnUniqueIdsOnly=false&returnCountOnly=false&returnExtentOnly=false&returnQueryGeometry=false&returnDistinctValues=false&cacheHint=false&collation=&orderByFields=&groupByFieldsForStatistics=&returnAggIds=false&outStatistics=&having=&resultOffset=&resultRecordCount=&returnZ=false&returnM=false&returnTrueCurves=false&returnExceededLimitFeatures=true&quantizationParameters=&sqlFormat=none&f=pgeojson&token="
  );

function buildServiceCentrePopup(props) {
  var name =
    props.asset_name ||
    props.system_name ||
    props.asset_id ||
    "Service Centre";

  var community = props.community || "";
  var location = props.location || "";
  var status = props.status || "";
  var managedBy = props.managed_by || "";
  var owner = props.asset_owner || "";

  var html = "<strong>" + name + "</strong><br>";

  if (community) {
    html += "<em>" + community + "</em><br>";
  }
  if (location) {
    html += "Location: " + location + "<br>";
  }
  if (status) {
    html += "Status: " + status + "<br>";
  }
  if (managedBy) {
    html += "Managed by: " + managedBy + "<br>";
  }
  if (owner) {
    html += "Owner: " + owner + "<br>";
  }

  return html;
}

function loadServiceCentres(url, targetLayer) {
  fetch(url)
    .then(function (res) {
      return res.json();
    })
    .then(function (geojson) {
      if (!geojson || !Array.isArray(geojson.features)) {
        console.warn("Facilities feed is not a FeatureCollection");
        return;
      }

      geojson.features.forEach(function (feature) {
        if (!feature.geometry || feature.geometry.type !== "Point") {
          return;
        }

        var props = feature.properties || {};

        // Only Service Centre category
        if (props.category !== "Service Centre") {
          return;
        }

        var coords = feature.geometry.coordinates;
        if (!Array.isArray(coords) || coords.length < 2) {
          return;
        }

        var lng = coords[0];
        var lat = coords[1];

        if (!isFinite(lat) || !isFinite(lng)) {
          return;
        }

        var iconColor =
          MARKER_CONFIG.serviceCentres &&
          MARKER_CONFIG.serviceCentres.color
            ? MARKER_CONFIG.serviceCentres.color
            : "#ff9800";

        var marker = L.marker([lat, lng], {
          icon: makeIcon(iconColor)
        });

        marker.bindPopup(buildServiceCentrePopup(props));
        targetLayer.addLayer(marker);
      });
    })
    .catch(function (err) {
      console.warn("Service Centres load failed", err);
    });
}

// Load service centres
loadServiceCentres(FACILITIES_URL, layerServiceCentres);

// Swimsafe swimming locations
// Live API
var SWIMSAFE_URL = "https://corsproxy.io/?url=https://www.lawa.org.nz/umbraco/api/mapservice/swimsites";
// For local testing with your saved file you can temporarily use:
// var SWIMSAFE_URL = "swimsites.json";

function swimsafeColorForSite(site) {
  var cfg = MARKER_CONFIG.swimsafe || {};
  var css = (site.CssClass || site.cssClass || "").toLowerCase();

  if (cfg.colorByRiskClass) {
    if (css && cfg.colorByRiskClass[css]) {
      return cfg.colorByRiskClass[css];
    }
    // Optional alternative key if the API exposes something like site.RiskClass
    if (!css && site.RiskClass && cfg.colorByRiskClass[site.RiskClass]) {
      return cfg.colorByRiskClass[site.RiskClass];
    }
  }

  return cfg.defaultColor || "#00bcd4";
}

function riskLabelFromCssClass(cssClass) {
  if (!cssClass) return "";
  var c = cssClass.toLowerCase();
  if (c.indexOf("risk-vlow") === 0) return "Very low risk";
  if (c.indexOf("risk-low") === 0) return "Low risk";
  if (
    c.indexOf("risk-med") === 0 ||
    c.indexOf("risk-medium") === 0 ||
    c.indexOf("risk-mod") === 0
  ) {
    return "Moderate risk";
  }
  if (c.indexOf("risk-high") === 0) return "High risk";
  if (c.indexOf("nodata") === 0) return "No recent risk data";
  return "";
}


function loadSwimsafeSites(url, targetLayer) {
  fetch(url)
    .then(function (res) { return res.json(); })
    .then(function (sites) {
      if (!Array.isArray(sites)) {
        console.warn("Swimsafe sites data is not an array", sites);
        return;
      }

      sites.forEach(function (site) {
        var lat = site.Latitude != null ? site.Latitude : site.latitude;
        var lng = site.Longitude != null ? site.Longitude : site.longitude;
        if (typeof lat !== "number" || typeof lng !== "number") {
          return;
        }

        // Limit to Far North district area
        if (!isInFarNorth(lat, lng)) {
          return;
        }

        var name = site.Name || site.name || "Swimming site";
        var urlPath = site.Url || site.url || "";
        var siteType = site.SiteType || site.siteType || "";
        var cssClass = site.CssClass || site.cssClass || "";
        var riskLabel = riskLabelFromCssClass(cssClass);

        var popupHtml =
          "<strong>" + name + "</strong><br>" +
          (siteType ? siteType + "<br>" : "") +
          (riskLabel ? "<strong>Risk:</strong> " + riskLabel + "<br>" : "");

        if (urlPath) {
          var fullUrl = urlPath.indexOf("http") === 0
            ? urlPath
            : "https://www.lawa.org.nz" + urlPath; // adjust if needed

          popupHtml +=
            '<br><a href="' + fullUrl +
            '" target="_blank" rel="noopener">View swim site details</a>';
        }

        var marker = L.marker([lat, lng], {
          icon: makeIcon(swimsafeColorForSite(site))
        });

        marker.bindPopup(popupHtml);
        targetLayer.addLayer(marker);
      });
    })
    .catch(function (err) {
      console.warn("Swimsafe sites load failed", err);
    });
}

// Load Swimsafe layer
loadSwimsafeSites(SWIMSAFE_URL, layerSwimsafe);

// 9. Local Road Closures from CSV

var LOCAL_ROAD_CLOSURES_URL =
  "https://raw.githubusercontent.com/almokinsgov/testbed/refs/heads/main/road.csv";

function loadLocalRoadClosures() {
  fetch(LOCAL_ROAD_CLOSURES_URL)
    .then(function (res) {
      return res.text();
    })
    .then(function (text) {
      if (!text) {
        console.warn("Local road closures CSV was empty");
        return;
      }

      var lines = text.split(/\r?\n/);
      if (lines.length <= 1) {
        console.warn("Local road closures CSV has no data rows");
        return;
      }

      // Skip header
      for (var i = 1; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!line) {
          continue;
        }

        // Simple CSV split, OK here because fields have no embedded commas
        var cols = line.split(",");
        if (cols.length < 4) {
          continue;
        }

        var roadName = (cols[0] || "").trim();
        var reason = (cols[1] || "").trim();

        // Header says Longitude,Latitude but the values are lat then lon
        // so we treat the "Longitude" column as latitude
        var lonHeaderValue = (cols[2] || "").trim();
        var latHeaderValue = (cols[3] || "").trim();

        // Interpret as [lat, lng]
        var lat = parseFloat(lonHeaderValue);
        var lng = parseFloat(latHeaderValue);

        // Detour information may contain commas, so join the rest
        var detour = cols.slice(4).join(",").trim();

        if (!isFinite(lat) || !isFinite(lng)) {
          continue;
        }

        var popupHtml =
          "<strong>" + (roadName || "Local road closure") + "</strong><br>" +
          (reason ? "Reason: " + reason + "<br>" : "") +
          (detour ? "Detour: " + detour + "<br>" : "");

        var marker = L.marker([lat, lng], {
          icon: makeIcon(MARKER_CONFIG.localRoadClosures.color)
        }).bindPopup(popupHtml);

        layerLocalRoadClosures.addLayer(marker);
      }
    })
    .catch(function (err) {
      console.warn("Local road closures load failed", err);
    });
}

// Kick off local road closures load
loadLocalRoadClosures();


  </script>
</body>
</html>
