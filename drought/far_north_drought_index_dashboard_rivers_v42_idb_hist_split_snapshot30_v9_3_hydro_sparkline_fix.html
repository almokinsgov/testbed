<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Far North Drought Index Dashboard</title>

  <!-- Leaflet (map) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root{
      --bg: #0b0f14;
      --panel: #101826;
      --panel2: #0f1722;
      --text: #e8eef7;
      --muted: #9fb0c6;
      --border: rgba(255,255,255,0.10);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
      --radius2: 10px;
      --gap: 14px;
      --ok: #38bdf8;
      --watch: #a3e635;
      --warn: #fbbf24;
      --severe: #fb7185;
      --extreme: #f97316;
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }
    body{
      margin: 0;
      background: radial-gradient(1100px 700px at 20% -10%, rgba(56,189,248,0.12), transparent 60%),
                  radial-gradient(900px 650px at 90% 0%, rgba(251,191,36,0.10), transparent 55%),
                  linear-gradient(180deg, var(--bg), #070a0f 65%);
      color: var(--text);
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    header{
      padding: 18px 18px 10px 18px;
      display: grid;
      gap: 10px;
    }

    h1{
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.2px;
    }

    .sub{
      color: var(--muted);
      font-size: 13px;
      margin-top: 2px;
    }

    .controls{
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .btn{
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      border: 1px solid var(--border);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(0,0,0,0.24);
      user-select: none;
    }
    .btn:hover{ filter: brightness(1.05); }

    .pill{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .pill strong{ color: var(--text); font-weight: 600; }

    .field{
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--muted);
    }
    .field input{
      width: 76px;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
      outline: none;
    }

    .field select{
  background: transparent;
  border: 1px solid rgba(255,255,255,0.10);
  color: var(--text);
  padding: 6px 8px;
  border-radius: 8px;
  outline: none;
}
.field input[type="datetime-local"]{
  width: 200px;
}
.field input:disabled, .field select:disabled{
  opacity: 0.55;
  cursor: not-allowed;
}

main{
      padding: 0 18px 18px 18px;
      display: grid;
      gap: var(--gap);
      grid-template-columns: 1.1fr 1.5fr;
      grid-template-rows: auto 1fr;
    }

    @media (max-width: 1050px){
      main{ grid-template-columns: 1fr; }
    }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .panel .hd{
      padding: 12px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.15);
    }

    .panel .hd h2{
      margin: 0;
      font-size: 14px;
      letter-spacing: 0.2px;
      color: var(--text);
    }

    .kpiGrid{
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      padding: 12px;
    }
    @media (max-width: 1050px){
      .kpiGrid{ grid-template-columns: repeat(2, 1fr); }
    }
    .kpi{
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
    }
    .kpi .label{ color: var(--muted); font-size: 12px; }
    .kpi .value{ font-size: 20px; font-weight: 700; margin-top: 4px; }
    .kpi .tiny{ color: var(--muted); font-size: 12px; margin-top: 4px; }

    #map{
      height: 520px;
      width: 100%;
      background: #0a0e14;
    }
    @media (max-width: 1050px){
      #map{ height: 430px; }
    }

    table{
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th, td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.07);
      vertical-align: middle;
    }
    th{
      text-align: left;
      color: var(--muted);
      font-weight: 600;
      background: rgba(0,0,0,0.12);
      position: sticky;
      top: 0;
      z-index: 2;
    }
    tbody tr{
      cursor: pointer;
      background: rgba(0,0,0,0.06);
    }
    tbody tr:hover{ background: rgba(255,255,255,0.04); }

    .tag{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.15px;
      white-space: nowrap;
    }
    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--ok);
      box-shadow: 0 0 0 4px rgba(56,189,248,0.15);
    }

    
    .climateExplainGrid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .explainItem{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.16);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .explainTitle{
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .explainBody{
      font-size: 12px;
      line-height: 1.35;
      color: var(--text);
      opacity: 0.92;
    }
.mono{ font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1; }
    .muted{ color: var(--muted); }

    .split{
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
      height: 100%;
    }
    .scroll{
      overflow: auto;
      max-height: 520px;
    }
    @media (max-width: 1050px){
      .scroll{ max-height: 420px; }
    }

    .detail{
      padding: 12px 14px;
      display: grid;
      gap: 10px;
    }
    .detail h3{
      margin: 0;
      font-size: 14px;
    }
    .grid2{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 1050px){
      .grid2{ grid-template-columns: 1fr; }
    }
    .miniCard{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.20);
    }
    .miniCard .k{ color: var(--muted); font-size: 12px; }
    .miniCard .v{ font-size: 16px; font-weight: 700; margin-top: 3px; }
    .miniCard .s{ color: var(--muted); font-size: 12px; margin-top: 2px; }

    .spark{
      width: 100%;
      height: 62px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
    }

    .spark.recentCanvas{
      height: 92px;
    }


    .note{
      color: var(--muted);
      font-size: 12px;
      padding: 12px 14px 14px 14px;
    }

    /* Modal */
    .modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 1000;
    }
    .modal{
      width: min(900px, 100%);
      background: #0b1220;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.60);
      overflow: hidden;
    }
    .modal .top{
      padding: 12px 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .modal .top h3{
      margin: 0;
      font-size: 14px;
    }
    .modal .body{
      padding: 12px 14px;
      display: grid;
      gap: 10px;
    }
    textarea{
      width: 100%;
      min-height: 280px;
      resize: vertical;
      background: rgba(0,0,0,0.25);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.45;
    }

    .toast{
      position: fixed;
      right: 16px;
      bottom: 16px;
      background: rgba(0,0,0,0.75);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: 440px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.50);
      display: none;
      z-index: 1100;
    }
  
/* Playback panel */
.playback-grid{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:flex-end;
}
.playback-slider{
  display:flex;
  gap:12px;
  align-items:center;
  margin-top:10px;
}
.playback-slider input[type="range"]{ flex:1; }
.check{
  display:flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border:1px solid var(--border);
  border-radius:12px;
  background: rgba(255,255,255,0.03);
  color: var(--muted);
  user-select:none;
}
.check input{ accent-color: var(--accent); }


    .trendCanvas{ height: 120px; }

    .trendWrap{ position: relative; }
    .chartTooltip{
      position:absolute;
      left: 10px;
      top: 10px;
      background: rgba(0,0,0,0.82);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 8px 10px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.45);
      font-size: 12px;
      line-height: 1.25;
      color: var(--text);
      pointer-events:none;
      z-index: 50;
      max-width: 320px;
      max-height: 260px;
      overflow: hidden;
    }
    
    #districtHydroReadingsTooltip{
      position: fixed;
      z-index: 100000;
    }

.chartTooltip .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .trendLegend{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin: 8px 0 10px 0;
    }
    .legendItem{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 999px;
      background: rgba(255,255,255,0.03);
    }
    .legendDot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display:inline-block;
      box-shadow: 0 0 0 4px rgba(255,255,255,0.06);
    }
    .legendMean{ background: var(--ok); box-shadow: 0 0 0 4px rgba(56,189,248,0.15); }
    .legendMedian{ background: var(--warn); box-shadow: 0 0 0 4px rgba(251,191,36,0.14); }
    .legendWorst{ background: var(--extreme); box-shadow: 0 0 0 4px rgba(249,115,22,0.16); }

</style>
</head>

<body>
  <header>
    <div>
      <h1>Far North Drought Index Dashboard</h1>
      <div class="sub">Modelled drought signal from Open-Meteo forecast soil moisture, rainfall, evap demand, humidity and optional Open-Meteo flood discharge</div>
    </div>

    <div class="controls">
      <button class="btn" id="btnRefresh">Refresh Data</button>
      <button class="btn" id="btnEditLocations">Edit Locations</button>
      <button class="btn" id="btnDownloadData" title="Download all loaded datasets and computed results as a portable bundle">Download Data</button>
            <button class="btn" id="btnExportZip" title="Export a GitHub-ready ZIP with Open-Meteo separate and NRC split by site and month">Export ZIP</button>
<button class="btn" id="btnLoadData" title="Load a previously downloaded bundle to avoid re-fetching providers">Load Data</button>
      <button class="btn" id="btnLoadZipManifest" title="Load an exported ZIP using manifest.json and the split GitHub layout">Load ZIP Manifest</button>
      <span class="field" id="manifestUrlField" style="display:none">
              Manifest URL
              <input type="text" id="manifestUrlInput" placeholder="https://raw.githubusercontent.com/<user>/<repo>/<branch>/<folder>/manifest.json" style="width:420px" />
            </span>
            <button class="btn" id="btnLoadManifestUrl" style="display:none" title="Load data from a hosted GitHub folder by manifest URL and lazy-load NRC Hilltop month files">Load Manifest URL</button>

      <button class="btn" id="btnClearLoadedData" title="Clear loaded datasets and computed results (does not change your saved locations)">Clear Loaded</button>
      <input type="file" id="fileLoadData" accept=".json,.json.gz,application/json,application/gzip" style="display:none" />
      <input type="file" id="fileLoadZipManifest" accept=".zip,application/zip" style="display:none" />

      <span class="field">
        Past Days
        <input type="number" id="pastDays" min="7" max="92" step="1" value="30" />
      </span>

      <span class="field">
        Forecast Days
        <input type="number" id="forecastDays" min="3" max="16" step="1" value="7" />
      </span>

<span class="field">
  Time Mode
  <select id="timeMode">
    <option value="live">Live</option>
    <option value="historic">Historic</option>
  </select>
</span>

<span class="field">
  Historic Date Time
  <input type="datetime-local" id="asOfInput" />
</span>

<button class="btn" id="btnLoadSnapshot" style="display:none" title="Load the selected Historic Date Time">Load Snapshot</button>


      <span class="pill" id="statusPill">
        <strong>Status</strong>
        <span class="muted" id="statusText">Idle</span>
      </span>

      <span class="pill" title="Drought index scale">
        <span class="dot" style="background: var(--ok)"></span><span class="muted">0-48 Normal</span>
      </span>
      <span class="pill"><span class="dot" style="background: var(--watch)"></span><span class="muted">49-63 Watch</span></span>
      <span class="pill"><span class="dot" style="background: var(--warn)"></span><span class="muted">64-78 Warning</span></span>
      <span class="pill"><span class="dot" style="background: var(--severe)"></span><span class="muted">79-93 Severe</span></span>
      <span class="pill"><span class="dot" style="background: var(--extreme)"></span><span class="muted">94-100 Extreme</span></span>
    </div>
  </header>


  <section id="playbackPanel" class="panel playback" style="grid-column: 1 / -1; display:none;">
    <div class="hd">
      <h2>Playback</h2>
      <div class="muted" id="playbackStatus">Set a play range then load and play</div>
    </div>

    <div class="playback-grid">
      <span class="field">
        Range Start
        <input type="datetime-local" id="rangeStartInput" />
      </span>

      <span class="field">
        Range End
        <input type="datetime-local" id="rangeEndInput" />
      </span>

      <button class="btn" id="btnLoadRange" title="Fetch data for the selected range">Load Range</button>

      <button class="btn" id="btnStepBack" title="Step back">◀</button>
      <button class="btn" id="btnPlay" title="Play">Play</button>
      <button class="btn" id="btnPause" title="Pause" style="display:none;">Pause</button>
      <button class="btn" id="btnStepFwd" title="Step forward">▶</button>

      <span class="field">
        Step
        <select id="playStep">
          <option value="60">1h</option>
          <option value="360">6h</option>
          <option value="720">12h</option>
          <option value="1440" selected>1d</option>
        </select>
      </span>

      <span class="field">
        Speed
        <select id="playSpeed">
          <option value="1500">Slow</option>
          <option value="900" selected>Normal</option>
          <option value="450">Fast</option>
          <option value="200">Max</option>
        </select>
      </span>

      <label class="check">
        <input type="checkbox" id="playLoop" checked />
        Loop
      </label>

      <label class="check" title="Updates river and groundwater during playback (slower)">
        <input type="checkbox" id="playHydro" />
        Update River/GW
      </label>
    </div>

    <div class="playback-slider">
      <input type="range" id="playSlider" min="0" max="0" value="0" step="1" />
      <div class="muted" id="playTimeLabel"></div>
    </div>
  </section>

  <main>
    <section class="panel" style="grid-column: 1 / -1;">
      <div class="hd">
        <h2>District Summary</h2>
        <span class="muted mono" id="lastUpdated">Not Updated</span>
      </div>
      <div class="kpiGrid">
        <div class="kpi">
          <div class="label">District Index (Mean)</div>
          <div class="value mono" id="kpiMean">-</div>
          <div class="tiny muted" id="kpiMeanCat"></div>
        </div>
        <div class="kpi">
          <div class="label">District Index (Median)</div>
          <div class="value mono" id="kpiMedian">-</div>
          <div class="tiny muted" id="kpiMedianCat"></div>
        </div>
        <div class="kpi">
          <div class="label">Worst Location</div>
          <div class="value mono" id="kpiWorst">-</div>
          <div class="tiny muted" id="kpiWorstName"></div>
        </div>
        <div class="kpi">
          <div class="label">Rain 14 Day Mean</div>
          <div class="value mono" id="kpiRain14">-</div>
          <div class="tiny muted">Across locations</div>
        </div>

        <div class="kpi">
          <div class="label">Forecast Rain 7d</div>
          <div class="value mono" id="kpiRain7">-</div>
          <div class="tiny muted">Mean across locations</div>
        </div>
        <div class="kpi">
          <div class="label">Forecast ET0 7d</div>
          <div class="value mono" id="kpiET07">-</div>
          <div class="tiny muted">Mean across locations</div>
        </div>
        <div class="kpi">
          <div class="label">Forecast VPD Mean 7d</div>
          <div class="value mono" id="kpiVPD7">-</div>
          <div class="tiny muted">Daytime mean (9-18)</div>
        </div>
        <div class="kpi">
          <div class="label">RH Mean 7d</div>
          <div class="value mono" id="kpiRH7">-</div>
          <div class="tiny muted">Past 7 days</div>
        </div>
      </div>

      <div style="padding: 0 12px 12px 12px;">
        <div class="miniCard">
          <div class="k">District Trend</div>
          <div class="s muted">Mean, Median and Worst location index over time</div>
          <div class="trendLegend">
            <span class="legendItem"><span class="legendDot legendMean"></span><span class="muted">Mean</span></span>
            <span class="legendItem"><span class="legendDot legendMedian"></span><span class="muted">Median</span></span>
            <span class="legendItem"><span class="legendDot legendWorst"></span><span class="muted">Worst</span></span>
          </div>
          <div class="trendWrap">
            <canvas id="districtTrendChart" class="spark trendCanvas"></canvas>
            <div id="districtTrendTooltip" class="chartTooltip" style="display:none;"></div>
          </div>
          <div class="tiny muted" id="districtTrendMeta">-</div>
          <div class="tiny muted" id="districtTrendIndicatorHelp" style="margin-top:6px;">Indicators: [Drought Watch] Mean 80+ (5d), [Drought Warning] Mean 80+ (7d), [Drought Danger] Mean 84+ (5d), [Location Danger] 94+ (3d), District wide stress when Worst-Mean ≤2 for 3d</div>
        </div>




<div class="miniCard">
  <div class="k">District Weather and Environment Trend</div>
  <div class="s muted">District-wide daily mean for a selected metric</div>
  <div class="row gap" style="align-items:center; flex-wrap:wrap; margin-top:6px;">
    <label class="tiny muted" for="districtEnvMetric">Metric</label>
    <select id="districtEnvMetric">
      <option value="rain_mm">Rain (Daily, mm)</option>
      <option value="rain14_mm">Rain (14 Day Mean, mm/day)</option>
      <option value="et0_mm">ET0 (Daily, mm)</option>
      <option value="et07_mm">ET0 (7 Day Mean, mm/day)</option>
      <option value="temp_c">Air Temperature (Daily Mean, °C)</option>
      <option value="rh_pct">Relative Humidity (Daily Mean, %)</option>
      <option value="vpd_kpa">VPD (Daily Mean, kPa)</option>
      <option value="soil_9_27">Soil Moisture 9-27 cm (Daily Mean, m³/m³)</option>
      <option value="soil_27_81">Soil Moisture 27-81 cm (Daily Mean, m³/m³)</option>
      <option value="soil_0_1">Soil Moisture 0-1 cm (Daily Mean, m³/m³)</option>
      <option value="soil_1_3">Soil Moisture 1-3 cm (Daily Mean, m³/m³)</option>
      <option value="soil_3_9">Soil Moisture 3-9 cm (Daily Mean, m³/m³)</option>
      <option value="wind_dir_deg">Wind Direction 10m (Daily Mean, °)</option>
      <option value="plume_idx">Tropical Plume Signal (Index 0–100)</option>
      <option value="wind_ms">Wind Speed 10m (Daily Mean, m/s)</option>
      <option value="msl_hpa">Mean Sea Level Pressure (Daily Mean, hPa)</option>
    </select>
  </div>
  <div class="trendWrap">
    <canvas id="districtEnvChart" class="spark trendCanvas"></canvas>
    <div id="districtEnvTooltip" class="chartTooltip" style="display:none;"></div>
  </div>
  <div class="tiny muted" id="districtEnvMeta">-</div>
</div>

<div class="miniCard" id="districtClimateCard">
  <div class="k">Climate Drivers and Plume Signal</div>
  <div class="s muted">Context layer only. This does not change the drought score.</div>

  <div class="trendLegend" style="margin:8px 0 2px 0;">
    <span class="tag" id="districtEnsoTag"><span class="dot" style="background:var(--ok)"></span>ENSO: <span class="mono">Loading</span></span>
    <span class="tag" id="districtSamTag"><span class="dot" style="background:var(--ok)"></span>SAM: <span class="mono">Loading</span></span>
    <span class="tag" id="districtMjoTag"><span class="dot" style="background:var(--ok)"></span>MJO: <span class="mono">Loading</span></span>
    <span class="tag" id="districtPlumeTag"><span class="dot" style="background:var(--ok)"></span>Plume: <span class="mono">-</span></span>
  </div>
  <div class="tiny muted" id="districtDriversMeta">Best effort fetch of global indices</div>

  <div class="tiny muted" id="districtPlumeReason" style="margin-top:8px;">-</div>
  <div class="climateExplainGrid" id="districtClimateExplainGrid">
    <div class="explainItem"><div class="explainTitle">ENSO</div><div class="explainBody" id="districtExplainEnso">-</div></div>
    <div class="explainItem"><div class="explainTitle">SAM</div><div class="explainBody" id="districtExplainSam">-</div></div>
    <div class="explainItem"><div class="explainTitle">MJO</div><div class="explainBody" id="districtExplainMjo">-</div></div>
    <div class="explainItem"><div class="explainTitle">Tropical Plume Signal</div><div class="explainBody" id="districtExplainPlume">-</div></div>
  </div>

</div>

<div class="miniCard">
  <div class="k">District River and Groundwater Stress Trend</div>
  <div class="s muted">District-wide daily mean water stress from nearest river gauges and bores (10 km limit). 0 = high water for that gauge, 100 = low</div>

  <div class="grid2" style="margin-top:8px;">
    <div>
      <div class="tiny muted" style="margin-bottom:4px;">River Stress</div>
      <div class="trendWrap">
        <canvas id="districtRiverChart" class="spark trendCanvas"></canvas>
        <div id="districtRiverTooltip" class="chartTooltip" style="display:none;"></div>
      </div>
    </div>
    <div>
      <div class="tiny muted" style="margin-bottom:4px;">Groundwater Stress</div>
      <div class="trendWrap">
        <canvas id="districtGWChart" class="spark trendCanvas"></canvas>
        <div id="districtGWTooltip" class="chartTooltip" style="display:none;"></div>
      </div>
    </div>
  </div>

  <div class="tiny muted" id="districtHydroMeta">-</div>
</div>

<div class="miniCard" id="districtHydroReadingsCard">
  <div class="k">District Hydrology Readings Over Time</div>
  <div class="s muted">Mean readings from river gauges and groundwater sources. Use Step to switch between daily and hourly. Combined aggregates across selected sites, individual draws one line per selected site.</div>

  <div class="row gap" style="align-items:center; flex-wrap:wrap; margin-top:6px;">
    <label class="tiny muted" for="districtHydroKind">Data</label>
    <select id="districtHydroKind">
      <option value="river">Rivers</option>
      <option value="gw">Groundwater Sources</option>
    </select>

    <label class="tiny muted" for="districtHydroMetric">Metric</label>
    <select id="districtHydroMetric"></select>

    <label class="tiny muted" for="districtHydroView">View</label>
    <select id="districtHydroView">
      <option value="combined">Combined</option>
      <option value="individual">Individual</option>
    </select>

    <label class="tiny muted" for="districtHydroScope">Scope</label>
    <select id="districtHydroScope">
      <option value="near">Near Locations (10 km)</option>
      <option value="all">All GuruDigital Sources</option>
    </select>

    <label class="tiny muted" for="districtHydroStep">Step</label>
    <select id="districtHydroStep">
      <option value="day" selected>Daily</option>
      <option value="hour">Hourly</option>
    </select>

  </div>

  <div id="districtHydroSitePickerWrap" style="margin-top:8px;">
    <div class="tiny muted" style="margin-bottom:4px;">Sites</div>
    <select id="districtHydroSitePicker" multiple size="6" style="width:100%;"></select>
    <div class="tiny muted" style="margin-top:6px;">Tip: Ctrl or Cmd for multi select. Combined uses selected sites for the aggregation, individual draws a line for each selected site.</div>
  </div>

  <div class="trendLegend" id="districtHydroReadingsLegend" style="margin-top:8px; display:none;"></div>

  <div class="trendWrap" style="margin-top:6px;">
    <canvas id="districtHydroReadingsChart" class="spark trendCanvas"></canvas>
    <div id="districtHydroReadingsTooltip" class="chartTooltip" style="display:none;"></div>
  </div>

  <div class="tiny muted" id="districtHydroReadingsMeta">-</div>
</div>



      </div>

<div class="note">
        Notes: This is a heuristic index designed for quick operational awareness. It uses modelled soil moisture and weather variables and can be tuned to match your district signals and thresholds.
      </div>
    </section>

    <section class="panel">
      <div class="hd">
        <h2>Map</h2>
        <span class="muted">Click a marker or row for details</span>
      </div>
      <div id="map"></div>
    </section>

    <section class="panel">
      <div class="hd">
        <h2>Locations</h2>
        <span class="muted" id="tableHint">Loading is idle</span>
      </div>

      <div class="split">
        <div class="scroll" id="tableWrap">
          <table id="tbl">
            <thead>
              <tr>
                <th>Location</th>
                <th>Index</th>
                <th>Category</th>
                <th class="mono">Rain 14d</th>
                <th class="mono">Soil 9-27</th>
                <th class="mono">Soil 27-81</th>
                <th class="mono">ET0 7d</th>
                <th class="mono">RH 7d</th>
                <th class="mono">Groundwater</th>
                <th class="mono">River Gauge</th
              </tr>
            </thead>
            <tbody id="tbody">
              <!-- rows inserted -->
            </tbody>
          </table>
        </div>

        <div class="detail" id="detailPanel">
          <h3>Details</h3>
          <div class="muted">Select a location to view the components and recent trends.</div>
        </div>
      </div>
    </section>
  </main>

  <!-- Locations Modal -->
  <div class="modalBack" id="modalBack">
    <div class="modal">
      <div class="top">
        <h3>Edit Locations</h3>
        <button class="btn" id="btnCloseModal">Close</button>
      </div>
      <div class="body">
        <div class="muted">
          Use JSON array with: id, name, lat, lon. Saved locally in your browser (localStorage).
        </div>
        <textarea id="locationsJson"></textarea>
        <div style="display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;">
          <button class="btn" id="btnResetLocations">Reset To Defaults</button>
          <button class="btn" id="btnSaveLocations">Save Locations</button>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    /***********************
     * Configuration
     ***********************/
    const STORAGE_KEY_LOCATIONS = "fn_drought_locations_v1";
    const STORAGE_KEY_LASTSEL = "fn_drought_last_selected_v1";

    // Dashboard runtime configuration (edit these defaults as needed)
    // Tip: You can still override most values in the browser console via window.<KEY> if you prefer.
    const DASH_CONFIG = {
      // Generic network retry policy (non Open-Meteo fetches)
      network: {
        maxRetries: 6,
        retryBaseMs: 1200,
        retryMaxMs: 60000
      },

      // Open-Meteo bulk fetch policy (keeps large location sets stable)
      openMeteo: {
        // Batching protects against 414 URI Too Large. Smaller batches and longer delays reduce 429 risk.
        batchSize: 90,
        maxUrlLength: 7000,

        // Adaptive defaults by location count (first match wins)
        adaptive: [
          { minLocations: 260, batchSize: 60, betweenBatchDelayMs: 25000 },
          { minLocations: 180, batchSize: 70, betweenBatchDelayMs: 18000 },
          { minLocations: 120, batchSize: 80, betweenBatchDelayMs: 14000 },
          { minLocations:   0, batchSize: 90, betweenBatchDelayMs: 9000  }
        ],

        // Flood endpoint is optional. Auto rules reduce request "weight" for large runs.
        includeFloodMaxLocations: 160,
        includeFloodMaxTotalDays: 60,

        // Delay between the forecast call and optional flood call within a batch
        betweenEndpointDelayMs: 450,

        // Open-Meteo specific retry policy (429 can require longer backoff)
        net: {
          maxRetries: 12,
          retryBaseMs: 5000,
          retryMaxMs: 180000
        }
      },

      // Hilltop (NRC) history fetch policy (mainly impacts district river and groundwater trends)
      hilltop: {
        // Proxy prefix used when Hilltop does not allow CORS
        proxyPrefix: "https://corsproxy.io/?url=",

        // Batch river and bore site history into ~1 month windows to avoid proxy response size limits
        maxDaysPerCall: 31,
        chunkOverlapHours: 1,
        betweenChunkDelayMs: 200
      },

      // Export and archive bundles (download and reload data to avoid re-fetching providers)
      export: {
        // Download as .json.gz if the browser supports CompressionStream
        compressGzip: true,

        // Pretty JSON makes files larger, keep false for big historic exports
        prettyPrint: false,

        // Include computed per-location results (index, components and mini series)
        includeComputed: true,

        // Include cached ENSO, SAM and MJO context tags
        includeClimateDrivers: true,

        // Include raw provider payloads (Open-Meteo arrays, NRC site lists and gauge series)
        includeRawProviders: true,

        // ZIP export: GitHub-ready split layout (providers separated, NRC split by site+month)
        zipGithubLayout: true,
        zipIncludeBundleJson: true,
        zipRootFolder: true,

        // Open-Meteo chunking in ZIP to keep files manageable (locations per chunk)
        openMeteoChunkSize: 25,

        // Hilltop (NRC) history export split policy
        nrcSplitHilltopByMonth: true

      },

      import: {
        // Load and restore from the ZIP split layout (manifest.json plus provider folders)
        enableZipManifestLoad: true,

        // Load from a hosted GitHub folder by manifest URL (GitHub raw or GitHub Pages)
        enableManifestUrlLoad: true,

        // Remember a manifest URL between sessions (stored in localStorage)
        manifestUrlRememberKey: "drought_dash_manifest_url",
        manifestUrlDefault: "",

        // Optional proxy for hosted files (generally not needed for GitHub raw, and may have size limits)
        manifestUrlUseProxy: false,
        manifestUrlProxyPrefix: "",

        // Hosted chunk discovery: fetch chunk_000.json, chunk_001.json... until 404 or maxChunks
        manifestUrlMaxChunks: 800,
        manifestUrlBetweenChunkDelayMs: 50,

        // Lazy-load NRC Hilltop month files from the hosted archive as charts request them
        lazyLoadHilltopMonthFiles: true,
        // Archive session behaviour after loading a ZIP or hosted manifest
        autoSwitchHistoricOnArchiveLoad: true,
        autoSetAsOfToArchiveLatestValid: true,
        clampAsOfToArchiveRange: true,
        clampPastForecastToArchiveMeta: true,

        // When true, Open-Meteo and live Hilltop provider fetches are disabled while an archive is loaded
        disableProviderFetchWhenArchiveLoaded: true,

        // IndexedDB caching for Hilltop month files (persists across reloads and reduces repeated downloads)
        indexedDbEnabled: true,
        indexedDbName: "fn_drought_archive_cache",
        indexedDbStoreHilltopMonthsOnZipLoad: true,
        indexedDbStoreHilltopMonthsFromHosted: true,
        indexedDbPreferHilltopMonths: true,


        // When true, clear in-memory caches before applying imported data
        clearCachesBeforeLoad: true,

        // If both bundle.json and split folders exist in the ZIP, prefer split folders
        preferBundleJsonIfPresent: false,

        // When true, the dashboard will prefer imported/archived data and avoid calling providers unless needed
        preferImportedDataOverProviders: true,

        // When true, and imported data is missing something, allow fallback to live providers
        providerFallbackWhenMissing: true
      },

      startup: {
        // When true, automatically fetch from providers on page load. Leave false if you mainly use archive ZIPs/manifests
        autoRefreshOnLoad: false
      },

      cache: {
        // When true, refresh() will reuse cached data if it fully covers the current view and locations
        preferCacheWhenAvailable: true,

        // Optional: if set (minutes), refresh() will refetch from providers when the cache is older than this
        // Use null to never refetch purely due to age
        maxCacheAgeMinutes: null
      }
    };


    

    // Provider endpoint constants (used for export provenance)
    const OPEN_METEO_FORECAST_URL = "https://api.open-meteo.com/v1/forecast";
    const OPEN_METEO_HISTORICAL_FORECAST_URL = "https://historical-forecast-api.open-meteo.com/v1/forecast";
    const OPEN_METEO_FLOOD_URL = "https://flood-api.open-meteo.com/v1/flood";

const DEFAULT_LOCATIONS = [
  {
    "id": "kaitaia",
    "name": "Kaitaia",
    "lat": -35.098679,
    "lon": 173.264026
  },
  {
    "id": "kerikeri",
    "name": "Kerikeri",
    "lat": -35.2271,
    "lon": 173.947
  },
  {
    "id": "kaikohe",
    "name": "Kaikohe",
    "lat": -35.4053,
    "lon": 173.8008
  },
  {
    "id": "kawakawa",
    "name": "Kawakawa",
    "lat": -35.3818,
    "lon": 174.067
  },
  {
    "id": "opua",
    "name": "Opua",
    "lat": -35.3118,
    "lon": 174.12
  },
  {
    "id": "waima",
    "name": "Waima",
    "lat": -35.4791,
    "lon": 173.545
  },
  {
    "id": "houhora",
    "name": "Houhora",
    "lat": -34.785,
    "lon": 173.08888
  },
  {
    "id": "herekino",
    "name": "Herekino",
    "lat": -35.2018,
    "lon": 173.157
  },
  {
    "id": "kaeo",
    "name": "Kaeo",
    "lat": -35.108235,
    "lon": 173.79291
  },
  {
    "id": "tehapua",
    "name": "Te Hapua",
    "lat": -34.5167,
    "lon": 172.9101
  },
  {
    "id": "peria",
    "name": "Peria",
    "lat": -35.16109,
    "lon": 173.530011
  },
  {
    "id": "waiharara",
    "name": "Waiharara",
    "lat": -34.915392,
    "lon": 173.187835
  },
  {
    "id": "waipoua",
    "name": "Waipoua",
    "lat": -35.661256,
    "lon": 173.610337
  },
  {
    "id": "taemaro",
    "name": "Taemaro",
    "lat": -34.948733,
    "lon": 173.571108
  },
  {
    "id": "broadwood",
    "name": "Broadwood",
    "lat": -35.2642897701786,
    "lon": 173.39444294899548
  },
  {
    "id": "karikari",
    "name": "Karikari",
    "lat": -34.885892728273944,
    "lon": 173.3462494365898
  },
  {
    "id": "mitimiti",
    "name": "Mitimiti",
    "lat": -35.44304730746896,
    "lon": 173.32767061538746
  },
  {
    "id": "puketi",
    "name": "Puketi",
    "lat": -35.20213200802538,
    "lon": 173.69140163503218
  },
  {
    "id": "parapara",
    "name": "Parapara",
    "lat": -35.05534148467114,
    "lon": 173.39589493503365
  },
  {
    "id": "tekao",
    "name": "Te Kao",
    "lat": -34.65177461439293,
    "lon": 172.96693021841563
  }
];

    // Thresholds and weights are designed to be sensible defaults.
    // You should tune them to align with local impacts and signals.
    const droughtConfig = {
      windows: {
        rainPastDays: 14,
        rhPastDays: 7,
        et0ForecastDays: 7,
        vpdForecastDays: 7,
        soilBaselineDays: 30
      },

      thresholds: {
        rain14: { wet: 80, dry: 10 },       // mm in 14 days
        rain7Forecast: { wet: 50, dry: 5 }, // mm in 7 days
        rh7: { wet: 80, dry: 40 },          // %
        et07: { low: 10, high: 30 },        // mm over next 7 days
        vpd: { low: 0.5, high: 2.0 },       // kPa (typical)
      },

      // Soil layers included, and their weights (sum should be 1).
      soilLayers: [
        { key: "soil_moisture_0_1cm", label: "0-1 cm", w: 0.10 },
        { key: "soil_moisture_1_3cm", label: "1-3 cm", w: 0.15 },
        { key: "soil_moisture_3_9cm", label: "3-9 cm", w: 0.20 },
        { key: "soil_moisture_9_27cm", label: "9-27 cm", w: 0.25 },
        { key: "soil_moisture_27_81cm", label: "27-81 cm", w: 0.30 },
      ],

      // Overall weights for the combined index.
      // If river data fails, weights are automatically renormalised.
      weights: {
        soil: 0.42,
        rain: 0.30,
        evap: 0.20,
        river: 0.06,
        humidity: 0.02
      }
    };

    /***********************
     * Helpers
     ***********************/
    const $ = (id) => document.getElementById(id);

    function setStatus(text){
      $("statusText").textContent = text;
    }

    function showToast(msg){
      const t = $("toast");
      t.textContent = msg;
      t.style.display = "block";
      clearTimeout(showToast._timer);
      showToast._timer = setTimeout(() => t.style.display = "none", 5500);
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    // Maps a value to dryness [0..1], where low rain -> high dryness
    function normalizeInverse(val, wet, dry){
      if (val == null || isNaN(val)) return null;
      if (wet === dry) return 0.5;
      const t = (val - dry) / (wet - dry);
      return clamp(1 - t, 0, 1);
    }

    // Maps a value to dryness [0..1], where high val -> high dryness
    function normalize(val, low, high){
      if (val == null || isNaN(val)) return null;
      if (high === low) return 0.5;
      const t = (val - low) / (high - low);
      return clamp(t, 0, 1);
    }

    function median(arr){
      const a = arr.slice().sort((x,y) => x-y);
      const mid = Math.floor(a.length/2);
      return a.length % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }

    function fmt(n, digits=0){
      if (n == null || isNaN(n)) return "-";
      return Number(n).toFixed(digits);
    }

    function categoryForIndex(idx){
      if (idx == null || isNaN(idx)) return { name: "No Data", color: "rgba(255,255,255,0.35)" };
      if (idx >= 94) return { name: "Extreme", color: "var(--extreme)" };
      if (idx >= 79) return { name: "Severe", color: "var(--severe)" };
      if (idx >= 64) return { name: "Warning", color: "var(--warn)" };
      if (idx >= 49) return { name: "Watch", color: "var(--watch)" };
      return { name: "Normal", color: "var(--ok)" };
    }

    function parseLocalDateTime(isoLike){
      // Open-Meteo uses local timestamps when timezone=... is set.
      // Many values look like "2026-01-04T00:00" without offset, which JS treats as local time.
      return new Date(isoLike);
    }

    function dayKeyFromIso(isoDateTime){
      // Works for both "YYYY-MM-DD" and "YYYY-MM-DDTHH:MM"
      return isoDateTime.slice(0, 10);
    }

    function nowLocal(){
      return new Date();
    }

    

const STORAGE_KEY_TIMEMODE = "fndi_timeMode";
const STORAGE_KEY_ASOF = "fndi_asOf";

const STORAGE_KEY_RANGE_START = "fndi_rangeStart";
const STORAGE_KEY_RANGE_END = "fndi_rangeEnd";
const STORAGE_KEY_PLAY_STEP = "fndi_playStepMin";
const STORAGE_KEY_PLAY_SPEED = "fndi_playSpeedMs";
const STORAGE_KEY_PLAY_LOOP = "fndi_playLoop";
const STORAGE_KEY_PLAY_HYDRO = "fndi_playHydro";

let historicRangeStart = null; // Date
let historicRangeEnd = null;   // Date

let historicUseRange = false; // true when Range Mode has been loaded

const playbackState = {
  isPlaying: false,
  timer: null,
  stepMinutes: 1440,
  speedMs: 900,
  loop: true,
  hydro: false,
  lastHydroAt: null
};


let timeMode = "live"; // "live" | "historic"
let asOfSnapshot = null;
let pendingAsOfStr = null; // UI-selected historic datetime that is not yet loaded

// Raw dataset cache, used for snapshot recompute without refetching
const dataCache = {
  wxList: null,
  floodList: null,
  riverSites: null,
  gwSites: null,
  riverForLoc: null,
  gwForLoc: null,
  loadedAt: null,
  rangeMin: null,
  rangeMax: null,
  pastDays: null,
  forecastDays: null,
  locationsSig: null
};

function pad2(n){ return String(n).padStart(2, "0"); }


function ymdLocal(d){
  if (!(d instanceof Date) || isNaN(d.getTime())) return "";
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}

function ymdhLocal(d){
  if (!(d instanceof Date) || isNaN(d.getTime())) return "";
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}T${pad2(d.getHours())}`;
}

function fingerprintLocations(locs){
  if (!Array.isArray(locs)) return "";
  return locs.map(l => {
    const id = (l && (l.id != null ? l.id : (l.name != null ? l.name : ""))) + "";
    const lat = (l && typeof l.lat === "number") ? l.lat.toFixed(6) : String((l && l.lat != null) ? l.lat : "");
    const lon = (l && typeof l.lon === "number") ? l.lon.toFixed(6) : String((l && l.lon != null) ? l.lon : "");
    return `${id}:${lat},${lon}`;
  }).join("|");
}

function ensureCacheLocationsSig(){
  if (!dataCache.locationsSig && Array.isArray(locations) && locations.length){
    dataCache.locationsSig = fingerprintLocations(locations);
  }
}

function cacheMatchesCurrentLocations(){
  if (!Array.isArray(locations) || !locations.length) return false;
  if (dataCache.locationsSig){
    return dataCache.locationsSig === fingerprintLocations(locations);
  }
  // Backward compatibility for older bundles without locationsSig
  return Array.isArray(dataCache.wxList) && dataCache.wxList.length === locations.length;
}


function formatWhenNZ(dateLike){
  const d = dateLike instanceof Date ? dateLike : new Date(String(dateLike).replace(" ", "T"));
  if (!(d instanceof Date) || isNaN(d.getTime())) return "";
  const hh = pad2(d.getHours());
  const mm = pad2(d.getMinutes());
  const dd = pad2(d.getDate());
  const mon = d.toLocaleString("en-NZ", {month: "short"});
  const yy = String(d.getFullYear()).slice(-2);
  return `${hh}:${mm} ${dd} ${mon} ${yy}`;
}

function formatDateTimeLocal(date){
  const d = date instanceof Date ? date : new Date(date);
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}T${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
}

function parseDateTimeLocal(value){
  if (!value || typeof value !== "string") return null;
  const d = new Date(value);
  return isNaN(d.getTime()) ? null : d;
}

function getAsOfDate(){
  if (timeMode === "historic" && asOfSnapshot instanceof Date && !isNaN(asOfSnapshot.getTime())){
    return asOfSnapshot;
  }
  return nowLocal();
}
function updateTimeControls(){
  const sel = document.getElementById("timeMode");
  const inp = document.getElementById("asOfInput");
  const btnSnap = document.getElementById("btnLoadSnapshot");
  if (!sel || !inp) return;

  sel.value = timeMode;

  if (timeMode === "historic"){

    inp.disabled = false;

    // Do not overwrite what the user has selected in the picker until they explicitly load it.
    if (pendingAsOfStr == null || pendingAsOfStr === ""){
      pendingAsOfStr = formatDateTimeLocal(getAsOfDate());
    }
    inp.value = pendingAsOfStr;

    if (btnSnap){
      btnSnap.style.display = "";
      btnSnap.disabled = !parseDateTimeLocal(inp.value);
    }
  } else {
    inp.disabled = true;
    if (btnSnap) btnSnap.style.display = "none";
  }

  showPlaybackPanel(timeMode === "historic");
  if (timeMode === "historic"){
    syncPlaybackInputs();
    updatePlaybackSlider();
  }
}

function updateTimeInputMinMax(){
  const inp = document.getElementById("asOfInput");
  if (!inp) return;
  // Historic mode should allow any date and time, so do not constrain min or max.
  inp.min = "";
  inp.max = "";
}
function clampAsOfToRange(){
  if (timeMode !== "historic") return;
  if (!(asOfSnapshot instanceof Date) || isNaN(asOfSnapshot.getTime())) return;

  const now = nowLocal();
  if (asOfSnapshot > now) asOfSnapshot = new Date(now.getTime());

  localStorage.setItem(STORAGE_KEY_ASOF, asOfSnapshot.toISOString());
  pendingAsOfStr = formatDateTimeLocal(asOfSnapshot);
  updateTimeControls();
}
function deriveWxRange(wx){
  const t = wx?.hourly?.time;
  if (Array.isArray(t) && t.length){
    const min = parseLocalDateTime(t[0]);
    const max = parseLocalDateTime(t[t.length - 1]);
    if (!isNaN(min.getTime()) && !isNaN(max.getTime())){
      return { min, max };
    }
  }
  const d = wx?.daily?.time;
  if (Array.isArray(d) && d.length){
    const min = parseLocalDateTime(d[0] + "T00:00");
    const max = parseLocalDateTime(d[d.length - 1] + "T23:00");
    if (!isNaN(min.getTime()) && !isNaN(max.getTime())){
      return { min, max };
    }
  }
  return { min: null, max: null };
}

function sliceDailyToWindow(dates, values, endDate, daysBack){
  if (!Array.isArray(dates) || !Array.isArray(values) || !dates.length) return [];
  const endKey = endDate.toISOString().slice(0,10);
  let endIdx = -1;
  for (let i=0;i<dates.length;i++){
    if (dates[i] <= endKey) endIdx = i;
  }
  if (endIdx < 0) return [];
  const startIdx = Math.max(0, endIdx - (daysBack - 1));
  return values.slice(startIdx, endIdx + 1);
}

function sliceDailyToWindowSeries(dates, values, endDate, daysBack){
  if (!Array.isArray(dates) || !Array.isArray(values) || !dates.length) return { dates: [], values: [] };
  const endKey = endDate.toISOString().slice(0,10);
  let endIdx = -1;
  for (let i=0;i<dates.length;i++){
    if (dates[i] <= endKey) endIdx = i;
  }
  if (endIdx < 0) return { dates: [], values: [] };
  const startIdx = Math.max(0, endIdx - (daysBack - 1));
  return { dates: dates.slice(startIdx, endIdx + 1), values: values.slice(startIdx, endIdx + 1) };
}


function recomputeFromCache(){
  if (!Array.isArray(locations) || !locations.length) return;
  if (!dataCache.wxList || !dataCache.wxList.length) return;

  const asOf = getAsOfDate();

  if (dataCache.rangeMin && asOf < dataCache.rangeMin){
    showToast("Snapshot is before the loaded data range. Increase Past Days then refresh.");
    return;
  }
  if (dataCache.rangeMax && asOf > dataCache.rangeMax){
    showToast("Snapshot is after the loaded data range. Increase Forecast Days then refresh.");
    return;
  }

  computed = locations.map((loc, i) => {
    const wx = dataCache.wxList[i];
    const flood = dataCache.floodList ? dataCache.floodList[i] : null;
    const riverGauge = dataCache.riverForLoc ? dataCache.riverForLoc[i] : null;
    const gwGauge = dataCache.gwForLoc ? dataCache.gwForLoc[i] : null;

    const index = computeLocationIndex(wx, flood, asOf);

    const soil9 = wx?.hourly?.soil_moisture_9_27cm
      ? lastHourlyAtOrBeforeNow(wx.hourly.time, wx.hourly.soil_moisture_9_27cm, asOf)
      : null;
    const soil27 = wx?.hourly?.soil_moisture_27_81cm
      ? lastHourlyAtOrBeforeNow(wx.hourly.time, wx.hourly.soil_moisture_27_81cm, asOf)
      : null;

    const dailySeries = computeDailySeries(wx);

    const plumeNow = computeTropicalPlumeSignal(wx, asOf);
    const plumeSeries = computePlumeDailySeriesForLocation(wx, asOf, 14);

    return { loc, index, riverGauge, gwGauge, soil9_27: soil9, soil27_81: soil27, dailySeries, plumeNow, plumeSeries };
  });

  computed.sort((a,b) => (b.index.score ?? -1) - (a.index.score ?? -1));

  renderDistrictKPIs();
  renderTable();
  renderMarkers();

  const loaded = dataCache.loadedAt instanceof Date ? dataCache.loadedAt : new Date();
  if (timeMode === "historic"){
    document.getElementById("lastUpdated").textContent =
      "As of " + asOf.toLocaleString("en-NZ", { hour12: false }) +
      " (Data loaded " + loaded.toLocaleString("en-NZ", { hour12: false }) + ")";
  } else {
    document.getElementById("lastUpdated").textContent =
      "Updated " + loaded.toLocaleString("en-NZ", { hour12: false });
  }

  document.getElementById("tableHint").textContent = "Click a row for details";

  const remembered = localStorage.getItem(STORAGE_KEY_LASTSEL);
  const preferred = selectedId && computed.some(r => r.loc.id === selectedId) ? selectedId :
    (remembered && computed.some(r => r.loc.id === remembered) ? remembered : (computed[0]?.loc.id ?? null));
  if (preferred) selectLocation(preferred, false);

  updateDistrictClimatePanel(asOf);
  ensureClimateDriversFetched();
  applyClimateDriversToUi();
  scheduleDistrictTrendBuild();
}
function sumDailyWindow(dailyTime, dailyVals, endDate, daysBack){
      if (!dailyTime || !dailyVals) return null;
      const endKey = endDate.toISOString().slice(0,10);

      let endIdx = -1;
      for (let i=0;i<dailyTime.length;i++){
        const k = dailyTime[i];
        if (k <= endKey) endIdx = i;
      }
      if (endIdx < 0) return null;

      const startIdx = Math.max(0, endIdx - (daysBack - 1));
      let sum = 0;
      for (let i=startIdx;i<=endIdx;i++){
        const v = dailyVals[i];
        if (v != null && !isNaN(v)) sum += v;
      }
      return sum;
    }

    function sumDailyFuture(dailyTime, dailyVals, startDate, daysForward){
      if (!dailyTime || !dailyVals) return null;
      const startKey = startDate.toISOString().slice(0,10);
      let startIdx = -1;

      for (let i=0;i<dailyTime.length;i++){
        if (dailyTime[i] > startKey){
          startIdx = i;
          break;
        }
      }
      if (startIdx < 0) return null;

      const endIdx = Math.min(dailyTime.length - 1, startIdx + (daysForward - 1));
      let sum = 0;
      for (let i=startIdx;i<=endIdx;i++){
        const v = dailyVals[i];
        if (v != null && !isNaN(v)) sum += v;
      }
      return sum;
    }

    function meanHourlyWindow(hourlyTime, hourlyVals, endDate, daysBack){
      if (!hourlyTime || !hourlyVals) return null;
      const endMs = endDate.getTime();
      const startMs = endMs - daysBack * 24 * 3600 * 1000;

      let sum = 0;
      let n = 0;
      for (let i=0;i<hourlyTime.length;i++){
        const t = parseLocalDateTime(hourlyTime[i]).getTime();
        if (t >= startMs && t <= endMs){
          const v = hourlyVals[i];
          if (v != null && !isNaN(v)){
            sum += v;
            n++;
          }
        }
      }
      return n ? sum / n : null;
    }

    function meanHourlyFuture(hourlyTime, hourlyVals, startDate, daysForward, filterFn=null){
      if (!hourlyTime || !hourlyVals) return null;
      const startMs = startDate.getTime();
      const endMs = startMs + daysForward * 24 * 3600 * 1000;

      let sum = 0;
      let n = 0;
      for (let i=0;i<hourlyTime.length;i++){
        const dt = parseLocalDateTime(hourlyTime[i]);
        const t = dt.getTime();
        if (t > startMs && t <= endMs){
          if (filterFn && !filterFn(dt)) continue;
          const v = hourlyVals[i];
          if (v != null && !isNaN(v)){
            sum += v;
            n++;
          }
        }
      }
      return n ? sum / n : null;
    }

    function lastHourlyAtOrBeforeNow(hourlyTime, hourlyVals, nowDate){
      if (!hourlyTime || !hourlyVals) return null;
      const nowMs = nowDate.getTime();
      let last = null;
      for (let i=0;i<hourlyTime.length;i++){
        const t = parseLocalDateTime(hourlyTime[i]).getTime();
        if (t <= nowMs){
          const v = hourlyVals[i];
          if (v != null && !isNaN(v)) last = v;
        }
      }
      return last;
    }

    function minMaxHourlyWindow(hourlyTime, hourlyVals, endDate, daysBack){
      if (!hourlyTime || !hourlyVals) return { min: null, max: null };
      const endMs = endDate.getTime();
      const startMs = endMs - daysBack * 24 * 3600 * 1000;

      let min = Infinity;
      let max = -Infinity;
      let found = false;

      for (let i=0;i<hourlyTime.length;i++){
        const t = parseLocalDateTime(hourlyTime[i]).getTime();
        if (t >= startMs && t <= endMs){
          const v = hourlyVals[i];
          if (v != null && !isNaN(v)){
            found = true;
            min = Math.min(min, v);
            max = Math.max(max, v);
          }
        }
      }
      return found ? { min, max } : { min: null, max: null };
    }

    function safeJsonParse(text){
      try { return JSON.parse(text); } catch { return null; }
    }

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

/***********************
 * Export / Import Data Bundles
 * Lets you download all loaded datasets (including large arrays) and reload later without re-fetching providers.
 ***********************/
const EXPORT_BUNDLE_SCHEMA = 1;

function safeDateFromIso(s){
  if (!s) return null;
  const d = new Date(s);
  return isNaN(d.getTime()) ? null : d;
}

function serialiseDataCache(){
  return {
    wxList: dataCache.wxList,
    floodList: dataCache.floodList,
    riverSites: dataCache.riverSites,
    gwSites: dataCache.gwSites,
    riverForLoc: dataCache.riverForLoc,
    gwForLoc: dataCache.gwForLoc,
    loadedAt: (dataCache.loadedAt instanceof Date) ? dataCache.loadedAt.toISOString() : (dataCache.loadedAt ? String(dataCache.loadedAt) : null),
    rangeMin: (dataCache.rangeMin instanceof Date) ? dataCache.rangeMin.toISOString() : (dataCache.rangeMin ? String(dataCache.rangeMin) : null),
    rangeMax: (dataCache.rangeMax instanceof Date) ? dataCache.rangeMax.toISOString() : (dataCache.rangeMax ? String(dataCache.rangeMax) : null),
    pastDays: dataCache.pastDays,
    forecastDays: dataCache.forecastDays,
    locationsSig: dataCache.locationsSig || null
  };
}

function restoreDataCache(serial){
  const s = serial || {};
  dataCache.wxList = s.wxList || null;
  dataCache.floodList = s.floodList || null;
  dataCache.riverSites = s.riverSites || null;
  dataCache.gwSites = s.gwSites || null;
  dataCache.riverForLoc = s.riverForLoc || null;
  dataCache.gwForLoc = s.gwForLoc || null;
  dataCache.loadedAt = safeDateFromIso(s.loadedAt) || null;
  dataCache.rangeMin = safeDateFromIso(s.rangeMin) || null;
  dataCache.rangeMax = safeDateFromIso(s.rangeMax) || null;
  dataCache.pastDays = (s.pastDays != null) ? s.pastDays : null;
  dataCache.forecastDays = (s.forecastDays != null) ? s.forecastDays : null;
  dataCache.locationsSig = s.locationsSig || null;
}

function buildExportBundle(){
  const nowIso = new Date().toISOString();
  const pastDays = Number($("pastDays")?.value) || null;
  const forecastDays = Number($("forecastDays")?.value) || null;

  const bundle = {
    schema_version: EXPORT_BUNDLE_SCHEMA,
    created_at: nowIso,
    app: {
      name: "Far North Drought Index Dashboard",
      bundle_note: "Portable cache bundle. Safe to commit to GitHub as a snapshot if desired."
    },
    state: {
      timeMode: timeMode,
      asOfSnapshot: (asOfSnapshot instanceof Date) ? asOfSnapshot.toISOString() : null,
      pastDays: pastDays,
      forecastDays: forecastDays,
      selectedId: selectedId
    },
    locations: Array.isArray(locations) ? locations : [],
    data: {}
  };

  if (DASH_CONFIG?.export?.includeRawProviders){
    bundle.data.dataCache = serialiseDataCache();
  }
  if (DASH_CONFIG?.export?.includeComputed){
    bundle.data.computed = Array.isArray(computed) ? computed : [];
  }
  if (DASH_CONFIG?.export?.includeClimateDrivers){
    bundle.data.climateDrivers = {
      fetchedAt: climateDriversCache?.fetchedAt || 0,
      enso: climateDriversCache?.enso || null,
      sam: climateDriversCache?.sam || null,
      mjo: climateDriversCache?.mjo || null
    };
  }

  // Helpful provenance for later GitHub archiving
  bundle.providers = {
    openMeteo: {
      forecastEndpoint: (timeMode === "historic") ? (OPEN_METEO_HISTORICAL_FORECAST_URL || null) : (OPEN_METEO_FORECAST_URL || null),
      historicalForecastEndpoint: OPEN_METEO_HISTORICAL_FORECAST_URL || null,
      floodEndpoint: OPEN_METEO_FLOOD_URL || null
    },
    nrc: {
      rivers: NRC_RIVERS_URL || null,
      groundwater: NRC_GW_URL || null
    }
  };

  return bundle;
}

function makeBundleFilename(){
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  const mode = (timeMode === "historic") ? "historic" : "live";
  return `far_north_drought_bundle_${mode}_${stamp}.json`;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 200);
}

async function downloadObjectAsFile(obj){
  const pretty = !!(DASH_CONFIG?.export?.prettyPrint);
  const jsonText = JSON.stringify(obj, null, pretty ? 2 : 0);

  const wantGzip = !!(DASH_CONFIG?.export?.compressGzip);
  const canGzip = (typeof CompressionStream !== "undefined");

  if (wantGzip && canGzip){
    const base = new Blob([jsonText], { type: "application/json" });
    const cs = new CompressionStream("gzip");
    const gzStream = base.stream().pipeThrough(cs);
    const gzBlob = await new Response(gzStream).blob();
    downloadBlob(gzBlob, makeBundleFilename() + ".gz");
    return;
  }

  downloadBlob(new Blob([jsonText], { type: "application/json" }), makeBundleFilename());
}


/***********************
 * ZIP Export: GitHub-Ready Split Layout
 * - Open-Meteo stored separately (chunked by location count)
 * - NRC site lists stored separately
 * - NRC Hilltop history split by site and month (from in-memory caches)
 ***********************/
function slugForPath(s){
  const t = (s == null) ? "" : String(s).trim().toLowerCase();
  const cleaned = t.replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
  return cleaned || "unknown";
}

function yyyymmFromTimeString(t){
  const s = (t == null) ? "" : String(t).trim();
  const m = s.match(/^(\d{4})-(\d{2})/);
  if (m) return `${m[1]}-${m[2]}`;
  const d = parseHilltopTimeToDate ? parseHilltopTimeToDate(s) : new Date(s);
  if (d && !isNaN(d.getTime())){
    const y = d.getFullYear();
    const mo = String(d.getMonth()+1).padStart(2,"0");
    return `${y}-${mo}`;
  }
  return "unknown";
}

function splitSeriesPairsByMonth(series){
  const out = new Map(); // yyyymm -> {times:[], values:[]}
  if (!series || !Array.isArray(series.times) || !Array.isArray(series.values)) return out;

  for (let i=0;i<series.times.length;i++){
    const t = series.times[i];
    const v = series.values[i];
    if (t == null || v == null || !isFinite(v)) continue;
    const mm = yyyymmFromTimeString(t);
    const cur = out.get(mm) || { times: [], values: [] };
    cur.times.push(String(t));
    cur.values.push(Number(v));
    out.set(mm, cur);
  }
  return out;
}

function parseHilltopCacheKey(cacheKey, kindHint){
  const s = String(cacheKey || "");
  // District cache: DH|river|<site>||<meas>||<endStamp>||<daysBack>
  if (s.startsWith("DH|")){
    const parts = s.split("|");
    const kind = parts[1] || kindHint || "unknown";
    const rest = parts.slice(2).join("|"); // "<site>||<meas>||<endStamp>||<daysBack>"
    const r = rest.split("||");
    return {
      kind,
      siteName: r[0] || "",
      measName: r[1] || "",
      endStamp: r[2] || "",
      daysBack: r[3] || ""
    };
  }

  // Standard cache: <site>||<meas>||<endStamp>||<daysBack>
  const r = s.split("||");
  return {
    kind: kindHint || "unknown",
    siteName: r[0] || "",
    measName: r[1] || "",
    endStamp: r[2] || "",
    daysBack: r[3] || ""
  };
}

function mergeMonthlyFileRecord(rec){
  // De-duplicate by time string, keep last value if repeated
  const map = new Map();
  for (let i=0;i<rec.times.length;i++){
    map.set(rec.times[i], rec.values[i]);
  }
  const pairs = [...map.entries()].sort((a,b)=> String(a[0]).localeCompare(String(b[0])));
  rec.times = pairs.map(p=>p[0]);
  rec.values = pairs.map(p=>p[1]);
  return rec;
}

async function exportZipGithubLayout(){
  if (typeof JSZip === "undefined"){
    showToast("ZIP export needs JSZip. Check your connection or allow the JSZip CDN to load.");
    return;
  }

  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  const mode = (timeMode === "historic") ? "historic" : "live";
  const rootName = `far_north_drought_export_${mode}_${stamp}`;

  setStatus("Building ZIP export…");
  try{
    const zip = new JSZip();
    const root = (DASH_CONFIG?.export?.zipRootFolder) ? zip.folder(rootName) : zip;

    // Root manifest
    const manifest = {
      schema_version: 1,
      created_at: new Date().toISOString(),
      mode,
      note: "GitHub-ready export. Open-Meteo separated. NRC Hilltop split by site and month.",
      state: {
        timeMode,
        asOfSnapshot: (asOfSnapshot instanceof Date) ? asOfSnapshot.toISOString() : null,
        pastDays: Number($("pastDays")?.value) || null,
        forecastDays: Number($("forecastDays")?.value) || null
      },
      counts: {
        locations: Array.isArray(locations) ? locations.length : 0,
        wxList: Array.isArray(dataCache?.wxList) ? dataCache.wxList.length : 0,
        floodList: Array.isArray(dataCache?.floodList) ? dataCache.floodList.length : 0,
        riverSites: Array.isArray(dataCache?.riverSites) ? dataCache.riverSites.length : 0,
        gwSites: Array.isArray(dataCache?.gwSites) ? dataCache.gwSites.length : 0
      }
    };

    root.file("manifest.json", JSON.stringify(manifest, null, 2));
    root.file("locations.json", JSON.stringify(Array.isArray(locations) ? locations : [], null, 2));

    // Optional: full portable bundle for fast reload (redundant but convenient)
    if (DASH_CONFIG?.export?.zipIncludeBundleJson){
      const bundle = buildExportBundle();
      const pretty = !!(DASH_CONFIG?.export?.prettyPrint);
      root.file("bundle.json", JSON.stringify(bundle, null, pretty ? 2 : 0));
    }

    // Provider layout
    const prov = root.folder("providers");

    // ---- Open-Meteo ----
    const om = prov.folder("open_meteo");
    const omMeta = {
      forecastEndpoint: (timeMode === "historic") ? OPEN_METEO_HISTORICAL_FORECAST_URL : OPEN_METEO_FORECAST_URL,
      historicalForecastEndpoint: OPEN_METEO_HISTORICAL_FORECAST_URL,
      floodEndpoint: OPEN_METEO_FLOOD_URL,
      rangeMin: dataCache?.rangeMin ? String(dataCache.rangeMin) : null,
      rangeMax: dataCache?.rangeMax ? String(dataCache.rangeMax) : null,
      pastDays: dataCache?.pastDays ?? null,
      forecastDays: dataCache?.forecastDays ?? null,
      chunkSize: DASH_CONFIG?.export?.openMeteoChunkSize ?? 25
    };
    om.file("meta.json", JSON.stringify(omMeta, null, 2));

    const omChunkSize = Math.max(1, Number(DASH_CONFIG?.export?.openMeteoChunkSize) || 25);

    if (Array.isArray(dataCache?.wxList) && dataCache.wxList.length){
      const fFolder = om.folder("forecast");
      for (let i=0;i<dataCache.wxList.length;i+=omChunkSize){
        const chunkIdx = Math.floor(i / omChunkSize);
        const sliceWx = dataCache.wxList.slice(i, i+omChunkSize);
        const sliceLoc = Array.isArray(locations) ? locations.slice(i, i+omChunkSize) : [];
        const payload = { chunkIndex: chunkIdx, locations: sliceLoc, wxList: sliceWx };
        fFolder.file(`chunk_${String(chunkIdx).padStart(3,"0")}.json`, JSON.stringify(payload));
      }
    }

    if (Array.isArray(dataCache?.floodList) && dataCache.floodList.length){
      const fldFolder = om.folder("flood");
      for (let i=0;i<dataCache.floodList.length;i+=omChunkSize){
        const chunkIdx = Math.floor(i / omChunkSize);
        const sliceF = dataCache.floodList.slice(i, i+omChunkSize);
        const sliceLoc = Array.isArray(locations) ? locations.slice(i, i+omChunkSize) : [];
        const payload = { chunkIndex: chunkIdx, locations: sliceLoc, floodList: sliceF };
        fldFolder.file(`chunk_${String(chunkIdx).padStart(3,"0")}.json`, JSON.stringify(payload));
      }
    }

    // ---- NRC ----
    const nrc = prov.folder("nrc");
    nrc.file("rivers_sites.json", JSON.stringify(dataCache?.riverSites || null, null, 2));
    nrc.file("groundwater_sites.json", JSON.stringify(dataCache?.gwSites || null, null, 2));
    nrc.file("river_for_location.json", JSON.stringify(dataCache?.riverForLoc || null, null, 2));
    nrc.file("groundwater_for_location.json", JSON.stringify(dataCache?.gwForLoc || null, null, 2));

    // Hilltop history caches split by month
    const hilltopFolder = nrc.folder("hilltop_history");
    const fileMap = new Map(); // filepath -> record

    function addSeriesCacheToFileMap(cache, kindHint){
      if (!cache || typeof cache.forEach !== "function") return;
      cache.forEach((series, cacheKey) => {
        const meta = parseHilltopCacheKey(cacheKey, kindHint);
        if (!meta.siteName || !meta.measName || !series) return;

        const monthGroups = splitSeriesPairsByMonth(series);
        const siteSlug = slugForPath(meta.siteName);
        const measSlug = slugForPath(meta.measName);
        const kindSlug = slugForPath(meta.kind);

        for (const [monthKey, chunk] of monthGroups.entries()){
          if (!chunk.times.length) continue;
          const relPath = `${kindSlug}/${siteSlug}/${measSlug}/${monthKey}.json`;

          const existing = fileMap.get(relPath) || {
            kind: meta.kind,
            siteName: meta.siteName,
            measName: meta.measName,
            month: monthKey,
            times: [],
            values: [],
            sources: []
          };

          for (let i=0;i<chunk.times.length;i++){
            existing.times.push(chunk.times[i]);
            existing.values.push(chunk.values[i]);
          }
          existing.sources.push(String(cacheKey));
          fileMap.set(relPath, existing);
        }
      });
    }

    addSeriesCacheToFileMap(riverHistoryCache, "river");
    addSeriesCacheToFileMap(gwHistoryCache, "groundwater");
    addSeriesCacheToFileMap(districtHydroHistoryCache, "district");

    const indexList = [];
    for (const [relPath, rec] of fileMap.entries()){
      const merged = mergeMonthlyFileRecord(rec);
      hilltopFolder.file(relPath, JSON.stringify(merged));
      indexList.push({ path: `providers/nrc/hilltop_history/${relPath}`, kind: rec.kind, siteName: rec.siteName, measName: rec.measName, month: rec.month });
    }
    hilltopFolder.file("index.json", JSON.stringify(indexList, null, 2));

    // Climate driver snapshots (optional)
    if (DASH_CONFIG?.export?.includeClimateDrivers){
      const cd = {
        fetchedAt: climateDriversCache?.fetchedAt || 0,
        enso: climateDriversCache?.enso || null,
        sam: climateDriversCache?.sam || null,
        mjo: climateDriversCache?.mjo || null
      };
      prov.file("climate_drivers.json", JSON.stringify(cd, null, 2));
    }

    // Computed (optional)
    if (DASH_CONFIG?.export?.includeComputed){
      prov.file("computed_locations.json", JSON.stringify(Array.isArray(computed) ? computed : []));
    }

    // Generate ZIP
    const blob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 }});
    const filename = `${rootName}.zip`;
    downloadBlob(blob, filename);

    showToast("Exported ZIP file.");
  } catch (e){
    console.error(e);
    showToast("ZIP export failed. See console for details.");
  } finally {
    setStatus("Ready");
  }
}

async function parseBundleFromFile(file){
  if (!file) return null;

  const isGz = /\.gz$/i.test(file.name) || file.type === "application/gzip";
  const canGunzip = (typeof DecompressionStream !== "undefined");

  if (isGz && canGunzip){
    const buf = await file.arrayBuffer();
    const ds = new DecompressionStream("gzip");
    const stream = new Blob([buf]).stream().pipeThrough(ds);
    const txt = await new Response(stream).text();
    return safeJsonParse(txt);
  }

  const txt = await file.text();
  return safeJsonParse(txt);
}



// ZIP manifest import (GitHub split layout)
// This restores Open-Meteo chunk files, NRC site maps, climate drivers and Hilltop monthly history caches.
function clearHistoryCaches(){
  try{ riverHistoryCache.clear(); }catch(e){}
  try{ gwHistoryCache.clear(); }catch(e){}
  try{ districtHydroHistoryCache.clear(); }catch(e){}
  try{ if (typeof remoteArchive !== "undefined" && remoteArchive && remoteArchive.monthFileCache) remoteArchive.monthFileCache.clear(); }catch(e){}
}

async function readJsonFromZip_(zip, absPath){
  const p = String(absPath || "");
  const f = zip.file(p) || zip.file(p.replace(/^\.\//,""));
  if (!f) return null;
  const txt = await f.async("string");
  try{
    return JSON.parse(txt);
  } catch(err){
    console.warn("ZIP JSON parse failed for", p, err);
    return null;
  }
}

async function readZipManifest_(zip){
  const keys = Object.keys(zip.files || {});
  const cand = keys.filter(k => /(^|\/)manifest\.json$/i.test(k));
  if (!cand.length) return null;
  cand.sort((a,b)=>a.length-b.length);
  const manifestKey = cand[0];
  const manifest = await readJsonFromZip_(zip, manifestKey);
  if (!manifest) return null;
  const prefix = manifestKey.replace(/manifest\.json$/i,"");
  return { manifestKey, prefix, manifest };
}

function listZipChunkKeys_(zip, folderPrefix){
  const pref = String(folderPrefix || "");
  const keys = Object.keys(zip.files || {});
  const chunks = keys.filter(k => k.startsWith(pref) && /chunk_\d+\.json$/i.test(k));
  chunks.sort(); // chunk_000.json lexical sort is fine
  return chunks;
}

async function readChunkedListFromZip_(zip, folderPrefix, listKey){
  const chunkKeys = listZipChunkKeys_(zip, folderPrefix);
  if (!chunkKeys.length) return null;
  const out = [];
  for (const k of chunkKeys){
    const payload = await readJsonFromZip_(zip, k);
    const arr = payload && payload[listKey];
    if (Array.isArray(arr)) out.push(...arr);
  }
  return out;
}

async function restoreHilltopCachesFromZip_(zip, basePrefix){
  const folder = String(basePrefix || "") + "providers/nrc/hilltop_history/";
  const keys = Object.keys(zip.files || {}).filter(k =>
    k.startsWith(folder) &&
    /\.json$/i.test(k) &&
    !/index\.json$/i.test(k)
  );
  if (!keys.length) return;

  const agg = new Map();

  for (const k of keys){
    const rec = await readJsonFromZip_(zip, k);
    if (!rec || !Array.isArray(rec.times) || !Array.isArray(rec.values)) continue;

    const srcKey = (Array.isArray(rec.sources) && rec.sources.length) ? String(rec.sources[0]) : "";
    const cacheKey = srcKey || `${rec.kind||"unknown"}|${rec.siteName||""}||${rec.measName||""}||${rec.month||""}||0`;

    let ent = agg.get(cacheKey);
    if (!ent){
      ent = { kind: rec.kind || null, times: [], values: [] };
      agg.set(cacheKey, ent);
    }
    if (!ent.kind && rec.kind) ent.kind = rec.kind;

    // Merge raw pairs (we will de-duplicate later)
    const n = Math.min(rec.times.length, rec.values.length);
    for (let i=0; i<n; i++){
      ent.times.push(rec.times[i]);
      ent.values.push(rec.values[i]);
    }
  }

  for (const [cacheKey, ent] of agg.entries()){
    const merged = mergeMonthlyFileRecord({ times: ent.times, values: ent.values });
    const series = { times: merged.times || [], values: merged.values || [] };

    if (String(cacheKey).startsWith("DH|") || ent.kind === "district"){
      districtHydroHistoryCache.set(cacheKey, series);
    } else if (ent.kind === "groundwater"){
      gwHistoryCache.set(cacheKey, series);
    } else if (ent.kind === "river"){
      riverHistoryCache.set(cacheKey, series);
    } else {
      // Best effort inference
      const meta = parseHilltopCacheKey(String(cacheKey));
      if (meta && meta.isDistrict) districtHydroHistoryCache.set(cacheKey, series);
      else riverHistoryCache.set(cacheKey, series);
    }
  }
}

async function loadZipManifestSplitLayout(file){
  if (!DASH_CONFIG?.import?.enableZipManifestLoad){
    showToast("ZIP manifest import is disabled in DASH_CONFIG.import.");
    return false;
  }
  if (!window.JSZip){
    showToast("JSZip is not available, cannot load ZIP.");
    return false;
  }
  if (!file) return false;

  try{
    setStatus("Loading ZIP archive…");
    if (DASH_CONFIG?.import?.clearCachesBeforeLoad){
      clearLoadedData();
      clearHistoryCaches();
    } else {
      clearHistoryCaches();
    }

    const zip = await JSZip.loadAsync(await file.arrayBuffer());
    const mf = await readZipManifest_(zip);
    if (!mf){
      showToast("manifest.json was not found in this ZIP.");
      setStatus("Ready");
      return false;
    }

    const base = mf.prefix || "";
    const manifest = mf.manifest || {};
    const locs = await readJsonFromZip_(zip, base + "locations.json");
    if (!Array.isArray(locs) || !locs.length){
      showToast("locations.json is missing or invalid in this ZIP.");
      setStatus("Ready");
      return false;
    }

    const openMeta = await readJsonFromZip_(zip, base + "providers/open_meteo/meta.json");
    const wxList = await readChunkedListFromZip_(zip, base + "providers/open_meteo/forecast/", "wxList");
    const floodList = await readChunkedListFromZip_(zip, base + "providers/open_meteo/flood/", "floodList");

    const riverSites = await readJsonFromZip_(zip, base + "providers/nrc/rivers_sites.json");
    const gwSites = await readJsonFromZip_(zip, base + "providers/nrc/groundwater_sites.json");
    const riverForLoc = await readJsonFromZip_(zip, base + "providers/nrc/river_for_location.json");
    const gwForLoc = await readJsonFromZip_(zip, base + "providers/nrc/groundwater_for_location.json");

    const climateDrivers = await readJsonFromZip_(zip, base + "providers/climate_drivers.json");
    const computed = await readJsonFromZip_(zip, base + "providers/computed_locations.json");

    const state = (manifest && manifest.state && typeof manifest.state === "object") ? { ...manifest.state } : {};
    if (!state.timeMode && manifest.mode){
      const m = String(manifest.mode).toLowerCase();
      state.timeMode = (m.includes("historic")) ? "historic" : "live";
    }

    const loadedAt = manifest.createdAt || manifest.exportedAt || new Date().toISOString();

    const dataCacheSerial = {
      wxList: Array.isArray(wxList) ? wxList : null,
      floodList: Array.isArray(floodList) ? floodList : null,
      riverSites: riverSites || null,
      gwSites: gwSites || null,
      riverForLoc: riverForLoc || null,
      gwForLoc: gwForLoc || null,
      loadedAt,
      rangeMin: openMeta?.rangeMin ?? null,
      rangeMax: openMeta?.rangeMax ?? null,
      pastDays: (openMeta?.pastDays ?? null),
      forecastDays: (openMeta?.forecastDays ?? null)
    };

    // Build a bundle shaped payload so we can reuse the existing restore logic
    const bundle = {
      schema_version: EXPORT_BUNDLE_SCHEMA,
      created_at: loadedAt,
      locations: locs,
      state,
      data: {
        dataCache: dataCacheSerial
      }
    };
    if (Array.isArray(computed)) bundle.data.computed = computed;
    if (climateDrivers && typeof climateDrivers === "object") bundle.data.climateDrivers = climateDrivers;

	    // ZIP imports have no manifestUrl/baseUrl. Use the filename (or manifest key) as a stable hint.
	    const hint = (file && file.name) ? `zip:${file.name}` : (mf.manifestKey || "zip_archive");
	    const archiveId = buildArchiveIdFromRange_(dataCacheSerial.rangeMin, dataCacheSerial.rangeMax, hint);
	    const ok = applyLoadedBundle(bundle, {fromArchive:true, source:"zip", archiveId, hint});
    if (!ok){
      setStatus("Ready");
      return false;
    }

    await restoreHilltopCachesFromZip_(zip, base);

    showToast("Loaded ZIP archive (manifest split layout).");
    setStatus("Ready");
    return true;

  } catch(err){
    console.error(err);
    showToast("ZIP import failed: " + (err && err.message ? err.message : String(err)));
    setStatus("Ready");
    return false;
  }
}



/* ===========================
   Hosted Manifest Import (GitHub)
   =========================== */

const remoteArchive = {
  enabled: false,
  manifestUrl: null,
  baseUrl: null, // folder URL ending with "/"
  manifest: null,
  hilltopIndexList: null,
  hilltopIndexMap: null, // key -> index entry
  monthFileCache: new Map(), // url -> {times, values}
  loadedAt: null
};
/* ===========================
   Archive Session And IDB Cache
   =========================== */

const archiveSession = {
  active: false,
  source: null,          // "zip" | "hosted"
  archiveId: null,
  rangeMin: null,
  rangeMax: null,
  providersDisabled: false
};

function _safeDateAny_(v){
  if (!v) return null;
  if (v instanceof Date) return isNaN(v.getTime()) ? null : v;
  const d = new Date(String(v));
  return isNaN(d.getTime()) ? null : d;
}
function _ymdIso_(d){
  try{ return d.toISOString().slice(0,10); }catch(e){ return "unknown"; }
}
function _slug_(s){
  return String(s || "").trim().replace(/[^a-zA-Z0-9_-]+/g, "_").replace(/_+/g, "_").slice(0, 60) || "archive";
}
function buildArchiveIdFromRange_(rangeMin, rangeMax, hint){
  const a = _safeDateAny_(rangeMin);
  const b = _safeDateAny_(rangeMax);
  const h = _slug_(hint || "archive");
  const sA = a ? _ymdIso_(a) : "unknown";
  const sB = b ? _ymdIso_(b) : "unknown";
  return `${h}_${sA}_to_${sB}`;
}
function buildArchiveIdFromBundle_(bundle, hint){
  const dc = bundle && bundle.dataCache ? bundle.dataCache : {};
  return buildArchiveIdFromRange_(dc.rangeMin, dc.rangeMax, hint);
}

function providersDisabledNow_(forceProviders){
  if (forceProviders) return false;
  return !!(archiveSession.active && archiveSession.providersDisabled);
}

function inferArchiveRange_(){
  // Prefer dataCache ranges if present
  const min = _safeDateAny_(dataCache?.rangeMin) || null;
  const max = _safeDateAny_(dataCache?.rangeMax) || null;
  return { min, max };
}

function inferArchiveLatestValidAsOf_(){
  const { min, max } = inferArchiveRange_();
  if (!max) return null;
  const fd = Math.max(0, Number(dataCache?.forecastDays) || 0);
  let asOf = new Date(max.getTime() - (fd * DAY_MS));
  if (min){
    const needMin = new Date(asOf.getTime() - (Math.max(0, Number(dataCache?.pastDays) || 0) * DAY_MS));
    if (needMin < min){
      // Not enough history, move asOf forward to fit inside range
      asOf = new Date(min.getTime() + (Math.max(0, Number(dataCache?.pastDays) || 0) * DAY_MS));
    }
  }
  return asOf;
}

function applyArchiveSessionFromBundle_(bundle, opts){
  if (!opts || !opts.fromArchive) return;

  const hint = (opts.source === "zip") ? (opts.hint || "zip_archive") : (opts.hint || "hosted_archive");
  const archiveId = opts.archiveId || buildArchiveIdFromBundle_(bundle, hint);

  const { min, max } = inferArchiveRange_();

  archiveSession.active = true;
  archiveSession.source = opts.source || "archive";
  archiveSession.archiveId = archiveId;
  archiveSession.rangeMin = min;
  archiveSession.rangeMax = max;
  archiveSession.providersDisabled = !!(DASH_CONFIG?.import?.disableProviderFetchWhenArchiveLoaded);

  // Keep remoteArchive in sync for Hilltop IDB keys (zip has no baseUrl)
  try{
    remoteArchive.archiveId = archiveId;
  }catch(e){}

  // Auto-clamp UI state
  if (DASH_CONFIG?.import?.clampPastForecastToArchiveMeta){
    if (Number.isFinite(Number(dataCache?.pastDays))) pastDays = Number(dataCache.pastDays);
    if (Number.isFinite(Number(dataCache?.forecastDays))) forecastDays = Number(dataCache.forecastDays);
  }

  if (DASH_CONFIG?.import?.autoSwitchHistoricOnArchiveLoad){
    timeMode = "historic";
  }

  if (DASH_CONFIG?.import?.autoSetAsOfToArchiveLatestValid){
    const latest = inferArchiveLatestValidAsOf_();
    if (latest) asOfSnapshot = latest;
  }

  if (DASH_CONFIG?.import?.clampAsOfToArchiveRange){
    const a = _safeDateAny_(asOfSnapshot);
    const rMin = _safeDateAny_(archiveSession.rangeMin);
    const rMax = _safeDateAny_(archiveSession.rangeMax);
    if (a && rMin && a < rMin) asOfSnapshot = new Date(rMin.getTime());
    if (a && rMax && a > rMax) asOfSnapshot = new Date(rMax.getTime());
  }
}

/* ===========================
   IndexedDB Helpers
   =========================== */

const idbArchive = {
  db: null,
  opening: null,
  name: (DASH_CONFIG?.import?.indexedDbName || "fn_drought_archive_cache"),
  version: 1
};

function idbEnabled_(){
  return !!(DASH_CONFIG?.import?.indexedDbEnabled && typeof indexedDB !== "undefined");
}

async function idbOpen_(){
  if (!idbEnabled_()) return null;
  if (idbArchive.db) return idbArchive.db;
  if (idbArchive.opening) return idbArchive.opening;

  idbArchive.opening = new Promise((resolve, reject) => {
    const req = indexedDB.open(idbArchive.name, idbArchive.version);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains("manifests")) db.createObjectStore("manifests");
      if (!db.objectStoreNames.contains("hilltop_index")) db.createObjectStore("hilltop_index");
      if (!db.objectStoreNames.contains("hilltop_month")) db.createObjectStore("hilltop_month");
      if (!db.objectStoreNames.contains("kv")) db.createObjectStore("kv");
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });

  try{
    idbArchive.db = await idbArchive.opening;
    return idbArchive.db;
  } finally {
    idbArchive.opening = null;
  }
}

async function idbGet_(store, key){
  const db = await idbOpen_();
  if (!db) return null;
  return await new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readonly");
    const os = tx.objectStore(store);
    const req = os.get(key);
    req.onsuccess = () => resolve(req.result ?? null);
    req.onerror = () => reject(req.error);
  });
}

async function idbPut_(store, key, val){
  const db = await idbOpen_();
  if (!db) return false;
  return await new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readwrite");
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
    tx.objectStore(store).put(val, key);
  });
}

async function idbBulkPut_(store, entries){
  const db = await idbOpen_();
  if (!db) return false;
  if (!entries || !entries.length) return true;
  return await new Promise((resolve, reject) => {
    const tx = db.transaction(store, "readwrite");
    const os = tx.objectStore(store);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
    for (const [k,v] of entries){
      os.put(v, k);
    }
  });
}


function clearRemoteArchiveState(){
  remoteArchive.enabled = false;
  remoteArchive.manifestUrl = null;
  remoteArchive.baseUrl = null;
  remoteArchive.manifest = null;
  remoteArchive.hilltopIndexList = null;
  remoteArchive.hilltopIndexMap = null;
  if (remoteArchive.monthFileCache && typeof remoteArchive.monthFileCache.clear === "function"){
    remoteArchive.monthFileCache.clear();
  } else {
    remoteArchive.monthFileCache = new Map();
  }
  remoteArchive.loadedAt = null;
}

function isRemoteArchiveActive(){
  // Also allow ZIP-loaded archives (no baseUrl) when an archiveId + index map is present
  return !!(remoteArchive.enabled && remoteArchive.hilltopIndexMap && (remoteArchive.baseUrl || remoteArchive.source === "zip"));
}

function _normKeyPart(v){
  return String(v ?? "").trim().toLowerCase();
}

function _hilltopIdxKey(kind, siteName, measName, monthKey){
  return `${_normKeyPart(kind)}||${_normKeyPart(siteName)}||${_normKeyPart(measName)}||${String(monthKey || "")}`;
}

function _monthKeyFromDate(d){
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  return `${y}-${m}`;
}

function _monthKeysForRange(fromDate, toDate){
  const out = [];
  if (!(fromDate instanceof Date) || !(toDate instanceof Date)) return out;
  const d0 = new Date(fromDate.getFullYear(), fromDate.getMonth(), 1);
  const d1 = new Date(toDate.getFullYear(), toDate.getMonth(), 1);
  const cur = new Date(d0.getTime());
  while (cur <= d1){
    out.push(_monthKeyFromDate(cur));
    cur.setMonth(cur.getMonth() + 1);
  }
  return out;
}

function _buildHilltopMeasCandidates(measurementName){
  const raw = String(measurementName || "").trim();
  const out = [];
  if (raw) out.push(raw);

  const noUnits = raw.replace(/\s*\([^)]*\)\s*$/,"").trim();
  if (noUnits && noUnits !== raw) out.push(noUnits);

  // Common alternates
  if (raw === "Flow") out.push("Flow (m3/s)");
  if (raw === "Flow (m3/s)") out.push("Flow");
  if (raw === "Water Level") out.push("Water Level (m)");
  if (raw === "Water Level (m)") out.push("Water Level");

  // Unique and non-empty
  return [...new Set(out.filter(Boolean))];
}

function _coerceMonthlyRecord(payload){
  if (!payload || typeof payload !== "object") return null;
  const times = Array.isArray(payload.times) ? payload.times.map(String) : null;
  const values = Array.isArray(payload.values) ? payload.values.map(Number) : null;
  if (!times || !values) return null;
  return { times, values };
}

function _filterSeriesByRange(series, fromDate, toDate){
  if (!series || !Array.isArray(series.times) || !Array.isArray(series.values)) return { times: [], values: [] };
  const outT = [];
  const outV = [];
  const t0 = (fromDate instanceof Date && isFinite(fromDate.getTime())) ? fromDate.getTime() : null;
  const t1 = (toDate instanceof Date && isFinite(toDate.getTime())) ? toDate.getTime() : null;

  for (let i=0;i<series.times.length;i++){
    const ts = series.times[i];
    const v = series.values[i];
    const t = Date.parse(ts);
    if (!isFinite(t)) continue;
    if (t0 !== null && t < t0) continue;
    if (t1 !== null && t > t1) continue;
    outT.push(ts);
    outV.push(Number(v));
  }
  return { times: outT, values: outV };
}

function _applyHostedProxyIfNeeded(url){
  const cfg = DASH_CONFIG?.import || {};
  if (!cfg.manifestUrlUseProxy) return url;
  const pref = String(cfg.manifestUrlProxyPrefix || "").trim();
  if (!pref) return url;
  return pref + url;
}

function _dirFromUrl(url){
  const s = String(url || "");
  const i = s.lastIndexOf("/");
  if (i <= 0) return s;
  return s.slice(0, i+1);
}

async function _fetchJsonOrNull(url, timeoutMs=20000){
  try{
    return await fetchJson(_applyHostedProxyIfNeeded(url), timeoutMs);
  } catch (e){
    return null;
  }
}

async function initRemoteHilltopIndexFromBase_(baseUrl){
  const base = String(baseUrl || "");
  if (!base) return false;
  const idxUrl = base + "providers/nrc/hilltop_history/index.json";
  const payload = await _fetchJsonOrNull(idxUrl, 25000);
  if (!payload) return false;

  const indexList = Array.isArray(payload) ? payload : (Array.isArray(payload.index) ? payload.index : null);
  if (!indexList) return false;

  const map = new Map();
  for (const ent of indexList){
    if (!ent || typeof ent !== "object") continue;
    const kind = String(ent.kind || "").trim();
    const siteName = String(ent.siteName || "").trim();
    const measName = String(ent.measName || "").trim();
    const monthKey = String(ent.month || "").trim();
    const p = String(ent.path || "").trim();
    if (!kind || !siteName || !measName || !monthKey || !p) continue;
    map.set(_hilltopIdxKey(kind, siteName, measName, monthKey), { ...ent, kind, siteName, measName, month: monthKey, path: p });
  }

  remoteArchive.hilltopIndexList = indexList;
  remoteArchive.hilltopIndexMap = map;
  return true;
}

async function remoteFetchHilltopMonthFile_(indexEntry){
  if (!indexEntry || !indexEntry.path) return null;

  const path = String(indexEntry.path);
  const cacheKey = path;

  if (!remoteArchive.monthFileCache) remoteArchive.monthFileCache = new Map();
  if (remoteArchive.monthFileCache.has(cacheKey)) return remoteArchive.monthFileCache.get(cacheKey);

  const archiveId = remoteArchive.archiveId || archiveSession.archiveId || null;
  const idbKey = (archiveId ? `${archiveId}||${path}` : null);

  // IndexedDB first
  if (idbKey && idbEnabled_() && (DASH_CONFIG?.import?.indexedDbPreferHilltopMonths !== false)){
    try{
      const rec = await idbGet_("hilltop_month", idbKey);
      if (rec){
        remoteArchive.monthFileCache.set(cacheKey, rec);
        return rec;
      }
    }catch(e){
      console.warn("IDB month get failed", e);
    }
  }

  // Hosted archive fetch (not live providers)
  if (!remoteArchive.baseUrl){
    return null;
  }

  const url = remoteArchive.baseUrl.replace(/\/+$/,"") + "/" + path.replace(/^\/+/, "");
  try{
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const rec = await res.json();
    remoteArchive.monthFileCache.set(cacheKey, rec);

    if (idbKey && idbEnabled_() && (DASH_CONFIG?.import?.indexedDbStoreHilltopMonthsFromHosted !== false)){
      try{ await idbPut_("hilltop_month", idbKey, rec); }catch(e){ console.warn("IDB month put failed", e); }
    }

    return rec;
  }catch(e){
    console.warn("Archive month fetch failed", path, e);
    return null;
  }
}

function _findHilltopIndexEntry(kind, siteName, measCandidates, monthKey){
  if (!remoteArchive.hilltopIndexMap) return null;
  for (const meas of measCandidates){
    const key = _hilltopIdxKey(kind, siteName, meas, monthKey);
    const ent = remoteArchive.hilltopIndexMap.get(key);
    if (ent) return ent;
  }
  return null;
}

async function remoteFetchHilltopRange_(kind, siteName, measurementName, fromDate, toDate){
  if (!isRemoteArchiveActive()) return null;
  const measCandidates = _buildHilltopMeasCandidates(measurementName);
  const months = _monthKeysForRange(fromDate, toDate);
  const parts = [];

  for (const mm of months){
    const ent = _findHilltopIndexEntry(kind, siteName, measCandidates, mm);
    if (!ent) continue;
    const rec = await remoteFetchHilltopMonthFile_(ent);
    if (!rec) continue;
    const filtered = _filterSeriesByRange(rec, fromDate, toDate);
    if (filtered.times.length) parts.push(filtered);
  }

  if (!parts.length) return null;
  return mergeHilltopSeries(parts);
}

async function remoteFetchHilltopRangeAuto_(siteName, measurementName, fromDate, toDate){
  const kinds = ["river", "groundwater"];
  for (const k of kinds){
    const s = await remoteFetchHilltopRange_(k, siteName, measurementName, fromDate, toDate);
    if (s && Array.isArray(s.values) && s.values.length) return s;
  }
  return null;
}

async function readChunkedListFromHosted_(folderUrl, listKey){
  const base = String(folderUrl || "");
  if (!base) return [];

  const maxChunks = Math.max(1, Number(DASH_CONFIG?.import?.manifestUrlMaxChunks) || 800);
  const delayMs = Math.max(0, Number(DASH_CONFIG?.import?.manifestUrlBetweenChunkDelayMs) || 0);

  const out = [];
  for (let i=0;i<maxChunks;i++){
    const url = base + `chunk_${String(i).padStart(3,"0")}.json`;
    try{
      const payload = await fetchJson(_applyHostedProxyIfNeeded(url), 25000);
      const arr = payload && Array.isArray(payload[listKey]) ? payload[listKey] : [];
      if (arr.length) out.push(...arr);
      if (!payload || !Array.isArray(payload[listKey])) break;
    } catch (e){
      break;
    }
    if (delayMs) await sleep(delayMs);
  }
  return out;
}

async function loadHostedManifestUrl(manifestUrl){
  const url = String(manifestUrl || "").trim();
  if (!url) {
    showToast("Please enter a manifest URL.");
    return;
  }

  if (!DASH_CONFIG?.import?.enableManifestUrlLoad){
    showToast("Manifest URL import is disabled in config.");
    return;
  }

  if (DASH_CONFIG?.import?.clearCachesBeforeLoad){
    clearHistoryCaches();
  }
  clearRemoteArchiveState();

  showToast("Loading hosted manifest…");

  const manifest = await fetchJson(_applyHostedProxyIfNeeded(url), 25000);
  const baseUrl = _dirFromUrl(url);

  if (!manifest || typeof manifest !== "object" || Number(manifest.schema_version) !== Number(EXPORT_BUNDLE_SCHEMA)){
    console.warn("Manifest schema mismatch or missing. Proceeding anyway.", manifest);
  }

  const locs = await fetchJson(_applyHostedProxyIfNeeded(baseUrl + "locations.json"), 25000);

  const omMeta = await _fetchJsonOrNull(baseUrl + "providers/open_meteo/meta.json", 25000);
  const wxList = await readChunkedListFromHosted_(baseUrl + "providers/open_meteo/forecast/", "wxList");
  const floodList = await readChunkedListFromHosted_(baseUrl + "providers/open_meteo/flood/", "floodList");

  const riverSites = await _fetchJsonOrNull(baseUrl + "providers/nrc/rivers_sites.json", 25000);
  const gwSites = await _fetchJsonOrNull(baseUrl + "providers/nrc/groundwater_sites.json", 25000);
  const riverForLocation = await _fetchJsonOrNull(baseUrl + "providers/nrc/river_for_location.json", 25000);
  const groundwaterForLocation = await _fetchJsonOrNull(baseUrl + "providers/nrc/groundwater_for_location.json", 25000);

  const computedLocations = await _fetchJsonOrNull(baseUrl + "providers/computed_locations.json", 25000);
  const climateDrivers = await _fetchJsonOrNull(baseUrl + "providers/climate_drivers.json", 25000);

  const bundle = {
    schema_version: EXPORT_BUNDLE_SCHEMA,
    created_at: manifest?.created_at || new Date().toISOString(),
    rangeMin: omMeta?.rangeMin ?? null,
    rangeMax: omMeta?.rangeMax ?? null,
    pastDays: omMeta?.pastDays ?? null,
    forecastDays: omMeta?.forecastDays ?? null,
    timeMode: (omMeta?.forecastEndpoint && String(omMeta.forecastEndpoint).includes("historical-forecast")) ? "historic" : "live",
    locations: Array.isArray(locs) ? locs : [],
    wxList: Array.isArray(wxList) ? wxList : [],
    floodList: Array.isArray(floodList) ? floodList : [],
    riverSites: riverSites || null,
    gwSites: gwSites || null,
    riverForLocation: riverForLocation || null,
    groundwaterForLocation: groundwaterForLocation || null,
    computedLocations: computedLocations || null,
    climateDrivers: climateDrivers || null,
    providers: {
      open_meteo: omMeta || null
    }
  };

  const ok = applyLoadedBundle(bundle);
  if (!ok){
    showToast("Hosted manifest load completed, but could not apply the bundle.");
    return;
  }

  remoteArchive.enabled = true;
  remoteArchive.manifestUrl = url;
  remoteArchive.baseUrl = baseUrl;
  remoteArchive.manifest = manifest;
  remoteArchive.loadedAt = new Date().toISOString();

  await initRemoteHilltopIndexFromBase_(baseUrl);

  showToast("Hosted data loaded. Hilltop history will lazy-load from the archive when needed.");
}

function applyLoadedBundle(bundle, options){
  if (!bundle || bundle.schema_version !== EXPORT_BUNDLE_SCHEMA){
    showToast("That file is not a recognised drought dashboard bundle.");
    return false;
  }

  if (Array.isArray(bundle.locations) && bundle.locations.length){
    locations = bundle.locations;
    saveLocations(locations);

    const ta = document.getElementById("locationsJson");
    if (ta) ta.value = JSON.stringify(locations, null, 2);
  }

  if (bundle.state){
    if (bundle.state.timeMode){
      timeMode = bundle.state.timeMode;
    }
    const d = safeDateFromIso(bundle.state.asOfSnapshot);
    if (d) asOfSnapshot = d;

    if (bundle.state.pastDays != null && $("pastDays")) $("pastDays").value = bundle.state.pastDays;
    if (bundle.state.forecastDays != null && $("forecastDays")) $("forecastDays").value = bundle.state.forecastDays;

    selectedId = bundle.state.selectedId || selectedId;

    updateTimeControls();
  }

  const data = bundle.data || {};
  if (data.dataCache){
    restoreDataCache(data.dataCache);
    // Backward compatibility: derive a locations signature if not present in the archive
    ensureCacheLocationsSig();
  }
  if (Array.isArray(data.computed)){
    computed = data.computed;
  }
  if (data.climateDrivers){
    climateDriversCache.fetchedAt = Date.now();
    climateDriversCache.loading = false;
    climateDriversCache.enso = data.climateDrivers.enso || null;
    climateDriversCache.sam = data.climateDrivers.sam || null;
    climateDriversCache.mjo = data.climateDrivers.mjo || null;
    applyClimateDriversToUi();
  }

  if (dataCache.wxList && dataCache.wxList.length){
    recomputeFromCache();
  } else {
    renderTable();
    renderMarkers();
    if (computed?.length){
      const first = selectedId && computed.some(r => r.loc.id === selectedId) ? selectedId : computed[0].loc.id;
      if (first) selectLocation(first, false);
    }
    setStatus("Ready");
  }

  document.getElementById("tableHint").textContent = "Loaded from bundle (no provider fetch)";
  showToast("Loaded cached data bundle.");
  return true;
}

function clearLoadedData(){
  dataCache.wxList = null;
  dataCache.floodList = null;
  dataCache.riverSites = null;
  dataCache.gwSites = null;
  dataCache.riverForLoc = null;
  dataCache.gwForLoc = null;
  dataCache.loadedAt = null;
  dataCache.rangeMin = null;
  dataCache.rangeMax = null;
  dataCache.pastDays = null;
  dataCache.forecastDays = null;

  computed = [];
  selectedId = null;

  climateDriversCache.fetchedAt = 0;
  climateDriversCache.loading = false;
  climateDriversCache.enso = null;
  climateDriversCache.sam = null;
  climateDriversCache.mjo = null;
  applyClimateDriversToUi();

  renderTable();
  renderMarkers();

  document.getElementById("lastUpdated").textContent = "No data loaded";
  document.getElementById("tableHint").textContent = "Press Refresh Data to fetch providers, or Load Data to restore a bundle, or Load ZIP Manifest to restore the split archive.";
  clearRemoteArchiveState();

  showToast("Cleared loaded data.");
}

function parseRetryAfterMs(v){
  if (!v) return null;
  const s = String(v).trim();
  if (!s) return null;
  if (/^\d+$/.test(s)) return Number(s) * 1000;
  const dt = Date.parse(s);
  if (!isNaN(dt)){
    const ms = dt - Date.now();
    return ms < 0 ? 0 : ms;
  }
  return null;
}

function isLikelyNetworkError(err){
  if (!err) return false;
  if (err.name === "AbortError") return true;
  // TypeError is what fetch throws for many network failures in browsers
  if (err instanceof TypeError) return true;
  const msg = String(err.message || "");
  return /failed to fetch|networkerror|load failed|timed out/i.test(msg);
}

async function fetchJson(url, timeoutMs=20000){
  // Global knobs (optional):
  //   window.NET_MAX_RETRIES (default 6)
  //   window.NET_RETRY_BASE_MS (default 1200)
  //   window.NET_RETRY_MAX_MS (default 60000)
  const isOpenMeteo = /api\.open-meteo\.com/i.test(url);

  const maxRetries = clamp(
    Number(isOpenMeteo ? window.OPEN_METEO_NET_MAX_RETRIES : window.NET_MAX_RETRIES) ||
    (isOpenMeteo ? (DASH_CONFIG.openMeteo && DASH_CONFIG.openMeteo.net && DASH_CONFIG.openMeteo.net.maxRetries) : (DASH_CONFIG.network && DASH_CONFIG.network.maxRetries)) ||
    6,
    0, 24
  );

  const baseDelayMs = clamp(
    Number(isOpenMeteo ? window.OPEN_METEO_NET_RETRY_BASE_MS : window.NET_RETRY_BASE_MS) ||
    (isOpenMeteo ? (DASH_CONFIG.openMeteo && DASH_CONFIG.openMeteo.net && DASH_CONFIG.openMeteo.net.retryBaseMs) : (DASH_CONFIG.network && DASH_CONFIG.network.retryBaseMs)) ||
    1200,
    100, 60000
  );

  const maxDelayMs  = clamp(
    Number(isOpenMeteo ? window.OPEN_METEO_NET_RETRY_MAX_MS : window.NET_RETRY_MAX_MS) ||
    (isOpenMeteo ? (DASH_CONFIG.openMeteo && DASH_CONFIG.openMeteo.net && DASH_CONFIG.openMeteo.net.retryMaxMs) : (DASH_CONFIG.network && DASH_CONFIG.network.retryMaxMs)) ||
    60000,
    1000, 300000
  );
  const retryStatuses = new Set([429, 500, 502, 503, 504, 522, 524]);

  let attempt = 0;
  while (true){
    attempt++;

    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);

    try{
      const res = await fetch(url, { signal: ctrl.signal, cache: "no-store" });

      if (!res.ok){
        const err = new Error("HTTP " + res.status);
        err.status = res.status;
        err.url = url;

        if (retryStatuses.has(res.status) && attempt <= (maxRetries + 1)){
          const ra = parseRetryAfterMs(res.headers.get("retry-after"));
          const backoff = Math.min(maxDelayMs, Math.round(baseDelayMs * Math.pow(1.8, attempt - 1)));
          const waitMs = ra != null ? Math.max(ra, backoff) : backoff;
          const jitter = Math.round(Math.random() * 400);
          try { setStatus(`Rate limited, backing off (${Math.round((waitMs+jitter)/1000)}s)`); } catch(e){}
          await sleep(waitMs + jitter);
          continue;
        }
        throw err;
      }

      return await res.json();
    } catch (e){
      const status = e && e.status;
      const retryable = retryStatuses.has(status) || isLikelyNetworkError(e);

      if (retryable && attempt <= (maxRetries + 1)){
        const backoff = Math.min(maxDelayMs, Math.round(baseDelayMs * Math.pow(1.8, attempt - 1)));
        const jitter = Math.round(Math.random() * 400);
        try { setStatus(`Network retry (${attempt}/${maxRetries+1})`); } catch(e){}
        await sleep(backoff + jitter);
        continue;
      }
      throw e;
    } finally {
      clearTimeout(t);
    }
  }
}


/***********************
 * Open-Meteo Batching (Avoid 414 URI Too Large + Proxy Size Limits)
 ***********************/
function getOpenMeteoDefaults(locCount, pastDays, forecastDays){
  const totalDays = (Number(pastDays) || 0) + (Number(forecastDays) || 0);

  // Defaults
  let batchSize = (DASH_CONFIG.openMeteo && DASH_CONFIG.openMeteo.batchSize) ? DASH_CONFIG.openMeteo.batchSize : 90;
  let betweenBatchDelayMs = 9000;

  // Adaptive rules (first match)
  const rules = (DASH_CONFIG.openMeteo && Array.isArray(DASH_CONFIG.openMeteo.adaptive)) ? DASH_CONFIG.openMeteo.adaptive : [];
  for (const r of rules){
    if (r && locCount >= (Number(r.minLocations) || 0)){
      if (Number.isFinite(Number(r.batchSize))) batchSize = Number(r.batchSize);
      if (Number.isFinite(Number(r.betweenBatchDelayMs))) betweenBatchDelayMs = Number(r.betweenBatchDelayMs);
      break;
    }
  }

  // Flood is optional; keep it off by default for heavy runs
  const floodMaxLocs = (DASH_CONFIG.openMeteo && Number.isFinite(Number(DASH_CONFIG.openMeteo.includeFloodMaxLocations)))
    ? Number(DASH_CONFIG.openMeteo.includeFloodMaxLocations) : 160;
  const floodMaxDays = (DASH_CONFIG.openMeteo && Number.isFinite(Number(DASH_CONFIG.openMeteo.includeFloodMaxTotalDays)))
    ? Number(DASH_CONFIG.openMeteo.includeFloodMaxTotalDays) : 60;

  const includeFloodAuto = (locCount <= floodMaxLocs) && (totalDays <= floodMaxDays);

  const maxUrlLength = (DASH_CONFIG.openMeteo && Number.isFinite(Number(DASH_CONFIG.openMeteo.maxUrlLength)))
    ? Number(DASH_CONFIG.openMeteo.maxUrlLength) : 7000;

  const betweenEndpointDelayMs = (DASH_CONFIG.openMeteo && Number.isFinite(Number(DASH_CONFIG.openMeteo.betweenEndpointDelayMs)))
    ? Number(DASH_CONFIG.openMeteo.betweenEndpointDelayMs) : 450;

  return { batchSize, betweenBatchDelayMs, includeFloodAuto, maxUrlLength, betweenEndpointDelayMs };
}


function _omKeyLatLon(lat, lon){
  const r = (v) => (Math.round(Number(v) * 10000) / 10000).toFixed(4);
  return r(lat) + "," + r(lon);
}

function _omNormaliseToLocOrder(data, locs){
  if (!data) return locs.map(() => null);
  const arr = Array.isArray(data) ? data : [data];
  if (arr.length === locs.length) return arr;

  const m = new Map();
  for (const d of arr){
    if (d && Number.isFinite(d.latitude) && Number.isFinite(d.longitude)){
      m.set(_omKeyLatLon(d.latitude, d.longitude), d);
    }
  }
  return locs.map(l => m.get(_omKeyLatLon(l.lat, l.lon)) || null);
}

function splitLocationsIntoOpenMeteoBatches(locs, pastDays, forecastDays){
  // User-tunable via global variables if needed:
  //   window.OPEN_METEO_BATCH_SIZE (10–200)
  //   window.OPEN_METEO_MAX_URL_LEN (3000–20000)
  const om = getOpenMeteoDefaults(locs.length, pastDays, forecastDays);
  const maxBatch = clamp(Number(window.OPEN_METEO_BATCH_SIZE) || om.batchSize, 10, 200);
  const maxUrlLen = clamp(Number(window.OPEN_METEO_MAX_URL_LEN) || om.maxUrlLength, 3000, 20000);

  const batches = [];
  let cur = [];

  for (const loc of locs){
    cur.push(loc);

    // Forecast URL is usually the longest; use it as the batching yardstick
    const url = buildForecastUrl(cur, pastDays, forecastDays);

    if (cur.length > maxBatch || url.length > maxUrlLen){
      cur.pop();

      if (cur.length){
        batches.push(cur);
        cur = [loc];
      } else {
        // Extremely unlikely: a single location URL exceeds limits
        batches.push([loc]);
        cur = [];
      }
    }
  }

  if (cur.length) batches.push(cur);
  return batches;
}

async function fetchOpenMeteoBatched(locs, pastDays, forecastDays){
  const batches = splitLocationsIntoOpenMeteoBatches(locs, pastDays, forecastDays);

  const forecastAll = [];
  const floodAll = [];


  // Open-Meteo throttling and optional flood endpoint
  // You can override these in the browser console:
  //   window.OPEN_METEO_INCLUDE_FLOOD = true|false
  //   window.OPEN_METEO_BETWEEN_BATCH_DELAY_MS = 0..120000
  //   window.OPEN_METEO_BETWEEN_ENDPOINT_DELAY_MS = 0..20000
  const om = getOpenMeteoDefaults(locs.length, pastDays, forecastDays);

  const includeFlood = (window.OPEN_METEO_INCLUDE_FLOOD == null)
    ? Boolean(om.includeFloodAuto)
    : Boolean(window.OPEN_METEO_INCLUDE_FLOOD);

  // Delay between batches (large runs need much longer to avoid 429)
  const betweenBatchDelay = clamp(
    Number(window.OPEN_METEO_BETWEEN_BATCH_DELAY_MS) || om.betweenBatchDelayMs,
    0, 120000
  );

  // Delay between forecast and flood endpoints within the same batch
  const betweenEndpointDelay = clamp(
    Number(window.OPEN_METEO_BETWEEN_ENDPOINT_DELAY_MS) || om.betweenEndpointDelayMs,
    0, 20000
  );

  for (let i = 0; i < batches.length; i++){
    const batch = batches[i];

    // Lightweight progress messaging
    const msg = `Loading Open-Meteo (${i+1}/${batches.length})`;
    try { setStatus(msg); } catch(e) {}
    const th = document.getElementById("tableHint");
    if (th) th.textContent = msg + "...";

    const urlForecast = buildForecastUrl(batch, pastDays, forecastDays);
    const urlFlood = buildFloodUrl(batch, pastDays, forecastDays);

    let forecastData = null;
    let floodData = null;

    // Forecast is required
    forecastData = await fetchJson(urlForecast, 30000);

    // Flood is optional; under large location sets this is auto-disabled to reduce rate-limit pressure
    if (includeFlood){
      if (betweenEndpointDelay) await sleep(betweenEndpointDelay);
      try{
        floodData = await fetchJson(urlFlood, 30000);
      } catch (e){
        floodData = null;
      }
    }

    if (betweenBatchDelay && i < batches.length - 1){
      await sleep(betweenBatchDelay);
    }

    if (!forecastData){
      throw new Error(`Open-Meteo forecast failed (batch ${i+1}/${batches.length}).`);
    }

    const wxArr = _omNormaliseToLocOrder(forecastData, batch);
    const floodArr = floodData ? _omNormaliseToLocOrder(floodData, batch) : batch.map(() => null);

    // Preserve the location order across batches
    for (const d of wxArr) forecastAll.push(d);
    for (const d of floodArr) floodAll.push(d);
  }

  return { forecastData: forecastAll, floodData: floodAll, batchesUsed: batches.length };
}



/***********************
 * Climate Drivers (Best Effort)
 * Best effort fetch of global indices for situational context only.
 ***********************/
const climateDriversCache = {
  fetchedAt: 0,
  loading: false,
  enso: null, // { state, period, year, value }
  sam: null,  // { state, date, value }
  mjo: null   // { state, date, phase, amp, rmm1, rmm2 }
};

async function fetchText(url, timeoutMs=20000){
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);
  try{
    const res = await fetch(url, { signal: ctrl.signal, cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  } finally {
    clearTimeout(t);
  }
}

function jinaWrap(url){
  if (typeof url !== "string") return url;
  if (url.startsWith("https://")) return "https://r.jina.ai/https://" + url.slice("https://".length);
  if (url.startsWith("http://")) return "https://r.jina.ai/http://" + url.slice("http://".length);
  return url;
}

async function fetchTextWithFallback(urls, timeoutMs=15000, predicate=null){
  for (const u of (urls || [])){
    try{
      const txt = await fetchText(u, timeoutMs);
      if (!txt) continue;
      if (txt.trim().length <= 40) continue;
      if (predicate && !predicate(txt)) continue;
      return txt;
    }catch(e){
      // ignore and try next
    }
  }
  return null;
}

function parseEnsoOni(text){
  if (!text) return null;

  const lines = String(text).split(/\r?\n/);
  let last = null;

  for (const ln of lines){
    const s = ln.trim();
    if (!s) continue;
    if (s.startsWith("#")) continue;
    // Header line often starts with "SEAS"
    if (/^(SEAS|YR|Year)\b/i.test(s)) continue;

    const parts = s.split(/\s+/);
    // Expected CPC ONI format: SEAS  YR  TOTAL  ANOM
    if (parts.length < 4) continue;

    const period = parts[0];
    const year = parseInt(parts[1], 10);
    const anom = parseFloat(parts[3]);

    if (!isFinite(year) || year < 1800 || year > 2200) continue;
    if (!isFinite(anom)) continue;

    last = { year, period, value: anom };
  }

  if (!last) return null;

  let state = "Neutral";
  if (last.value >= 0.5) state = "El Niño";
  else if (last.value <= -0.5) state = "La Niña";

  return { ...last, state };
}

function parseSamAao(text){
  if (!text) return null;
  const lines = String(text).split(/\r?\n/);
  let last = null;

  for (const ln of lines){
    const s = ln.trim();
    if (!s) continue;
    if (s.startsWith("#")) continue;
    if (/^(year|YYYY)\b/i.test(s)) continue;

    const parts = s.split(/\s+/);

    // Monthly format (e.g., PSL AAO): YEAR then ~12 monthly values
    if (parts.length >= 13){
      const y = parseInt(parts[0], 10);
      if (!isFinite(y) || y < 1800 || y > 2200) continue;

      // Find the last usable monthly value on this row
      let found = null;
      for (let i = parts.length - 1; i >= 1; i--){
        const v = parseFloat(parts[i]);
        if (!isFinite(v)) continue;
        // Some files use large negative sentinels for missing values
        if (v <= -90) continue;
        found = { monthIndex: i, value: v };
        break;
      }
      if (found){
        const mth = String(Math.min(12, Math.max(1, found.monthIndex))).padStart(2, "0");
        last = { date: `${y}-${mth}`, value: found.value };
      }
      continue;
    }

    // Daily formats:
    // YYYY MM DD value
    // YYYY MM value
    if (parts.length >= 4){
      const y = parseInt(parts[0], 10);
      const m = parseInt(parts[1], 10);
      const d = parseInt(parts[2], 10);
      const v = parseFloat(parts[3]);
      if (!isFinite(y) || !isFinite(m) || !isFinite(d) || !isFinite(v)) continue;
      last = { date: `${y}-${String(m).padStart(2,"0")}-${String(d).padStart(2,"0")}`, value: v };
    } else if (parts.length === 3){
      const y = parseInt(parts[0], 10);
      const m = parseInt(parts[1], 10);
      const v = parseFloat(parts[2]);
      if (!isFinite(y) || !isFinite(m) || !isFinite(v)) continue;
      last = { date: `${y}-${String(m).padStart(2,"0")}`, value: v };
    }
  }

  if (!last) return null;

  let state = "Neutral";
  if (last.value >= 0.5) state = "Positive";
  else if (last.value <= -0.5) state = "Negative";

  return { ...last, state };
}

function mjoPhaseFromRmm(rmm1, rmm2){
  if (!isFinite(rmm1) || !isFinite(rmm2)) return null;
  const ang = Math.atan2(rmm2, rmm1); // -pi..pi
  // Map angle to 8 bins. This is approximate; prefer provided phase if available.
  const norm = (ang + Math.PI) / (2 * Math.PI); // 0..1
  const phase = Math.floor(norm * 8) + 1;
  return Math.min(8, Math.max(1, phase));
}

function parseMjoRmm(text){
  if (!text) return null;
  const lines = String(text).split(/\r?\n/);
  let last = null;

  for (const ln of lines){
    const s = ln.trim();
    if (!s) continue;
    if (s.startsWith("#")) continue;
    if (/^(year|YYYY)\b/i.test(s)) continue;

    const parts = s.split(/\s+/);
    // Expected: YYYY MM DD RMM1 RMM2 [phase] [amp]
    if (parts.length < 5) continue;

    const y = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const d = parseInt(parts[2], 10);
    const rmm1 = parseFloat(parts[3]);
    const rmm2 = parseFloat(parts[4]);
    if (![y,m,d,rmm1,rmm2].every(isFinite)) continue;

    let phase = null;
    let amp = null;

    if (parts.length >= 6){
      const p = parseInt(parts[5], 10);
      if (isFinite(p) && p >= 1 && p <= 8) phase = p;
    }
    if (parts.length >= 7){
      const a = parseFloat(parts[6]);
      if (isFinite(a)) amp = a;
    }
    if (amp == null){
      amp = Math.sqrt(rmm1*rmm1 + rmm2*rmm2);
    }
    if (phase == null){
      phase = mjoPhaseFromRmm(rmm1, rmm2);
    }

    last = {
      date: `${y}-${String(m).padStart(2,"0")}-${String(d).padStart(2,"0")}`,
      rmm1, rmm2,
      phase,
      amp
    };
  }

  if (!last) return null;

  const active = last.amp >= 1.0;
  const state = active ? "Active" : "Weak";

  return { ...last, state };
}

function fmtShortDateTime(ts){
  try{
    const d = new Date(ts);
    return d.toLocaleString(undefined, { day:"2-digit", month:"short", hour:"2-digit", minute:"2-digit" });
  }catch{
    return "";
  }
}


function dateStrToMs(s){
  if (!s) return NaN;
  const str = String(s).trim();
  // YYYY-MM
  if (/^\d{4}-\d{2}$/.test(str)){
    return Date.parse(str + "-15T00:00:00Z");
  }
  // YYYY-MM-DD
  if (/^\d{4}-\d{2}-\d{2}$/.test(str)){
    return Date.parse(str + "T00:00:00Z");
  }
  return Date.parse(str);
}

function daysSinceDateStr(s){
  const ms = dateStrToMs(s);
  if (!isFinite(ms)) return Infinity;
  return (Date.now() - ms) / 86400000;
}

function setTagInner(id, html){
  const el = document.getElementById(id);
  if (el) el.innerHTML = html;
}

function setText(id, txt){
  const el = document.getElementById(id);
  if (el) el.textContent = txt;
}

function buildDriverTag(kind, data){
  const loading = climateDriversCache.loading && !data;
  const unavailable = !loading && !data;

  let dot = "var(--ok)";
  let label = "";
  let detail = "";

  if (loading){
    label = "Loading";
    dot = "var(--ok)";
  } else if (unavailable){
    label = "Unavailable";
    dot = "var(--ok)";
  } else if (kind === "enso"){
    label = data.state || "Neutral";
    detail = `${data.period || "-"} ${data.year || ""} ${fmt(data.value, 2)}`;
    if (data.state === "Stale") dot = "var(--warn)";
    else if (data.state === "El Niño") dot = "var(--warn)";
    else if (data.state === "La Niña") dot = "var(--watch)";
    else dot = "var(--ok)";
  } else if (kind === "sam"){
    label = data.state || "Neutral";
    detail = `${data.date || "-"} ${fmt(data.value, 2)}`;
    if (data.state === "Stale") dot = "var(--warn)";
    else if (data.state === "Negative") dot = "var(--warn)";
    else if (data.state === "Positive") dot = "var(--watch)";
    else dot = "var(--ok)";
  } else if (kind === "mjo"){
    label = data.state || "Weak";
    detail = `P${data.phase || "-"} A${fmt(data.amp, 1)} ${data.date || "-"}`;
    if (data.state === "Stale") dot = "var(--warn)";
    else if (data.state === "Active") dot = "var(--watch)";
    else dot = "var(--ok)";
  }

  const detailHtml = detail ? ` <span class="muted mono" style="font-weight:500;">${escapeHtml(detail)}</span>` : "";
  return `<span class="dot" style="background:${dot};"></span>${escapeHtml(kind.toUpperCase())}: <span class="mono">${escapeHtml(label)}</span>${detailHtml}`;
}



function strengthLabelFromAbs(absV){
  if (absV == null || !isFinite(absV)) return "Unknown";
  if (absV >= 1.5) return "Strong";
  if (absV >= 1.0) return "Moderate";
  if (absV >= 0.5) return "Weak";
  return "Near-neutral";
}

function buildEnsoExplain(enso){
  if (!enso){
    return climateDriversCache.loading ? "Loading ENSO background signal." : "ENSO is unavailable. The dashboard continues without this context layer.";
  }
  const v = enso.value;
  const absV = Math.abs(v);
  const strength = strengthLabelFromAbs(absV);
  const state = enso.state || "Unknown";
  let impact = "";
  if (state === "La Niña"){
    impact = "La Niña can increase the chance of humid northeasterly setups and subtropical moisture influence in the Far North.";
  }else if (state === "El Niño"){
    impact = "El Niño can increase the chance of westerly driven patterns, which may reduce humid northeasterly moisture setups in the Far North.";
  }else{
    impact = "Neutral ENSO means local weather is more controlled by synoptic highs, fronts, and shorter-lived moisture events.";
  }
  const season = enso.season ? ` ${enso.season}` : "";
  const yr = enso.year != null ? ` ${enso.year}` : "";
  const valTxt = (v == null || !isFinite(v)) ? "" : ` (ONI ${fmt(v,2)})`;
  return `${strength} ${state}${season}${yr}${valTxt}. ${impact} Treat this as seasonal background, not a local forecast.`;
}

function buildSamExplain(sam){
  if (!sam){
    return climateDriversCache.loading ? "Loading SAM background signal." : "SAM is unavailable. The dashboard continues without this context layer.";
  }
  const v = sam.value;
  const absV = Math.abs(v);
  const strength = strengthLabelFromAbs(absV);
  const state = sam.state || "Unknown";
  let impact = "";
  if (state === "Positive"){
    impact = "Positive SAM often indicates the mid-latitude westerly belt is shifted south, which can reduce the frequency of typical westerly fronts reaching NZ.";
  }else if (state === "Negative"){
    impact = "Negative SAM often indicates the westerly belt is shifted north, which can increase the frequency of frontal systems and windier change periods.";
  }else{
    impact = "Neutral SAM suggests no strong hemisphere-scale push on the westerly belt.";
  }
  const dateTxt = sam.date ? ` (${sam.date})` : "";
  const valTxt = (v == null || !isFinite(v)) ? "" : ` ${fmt(v,2)}`;
  return `${strength} ${state} SAM${dateTxt}, index${valTxt}. ${impact} Use alongside local pressure and wind signals.`;
}

function mjoPhaseRegion(phase){
  const p = parseInt(phase, 10);
  if (![1,2,3,4,5,6,7,8].includes(p)) return "Unknown region";
  if (p === 1) return "Western Indian Ocean";
  if (p === 2) return "Eastern Indian Ocean";
  if (p === 3) return "Maritime Continent (west)";
  if (p === 4) return "Maritime Continent";
  if (p === 5) return "Maritime Continent (east)";
  if (p === 6) return "Western Pacific";
  if (p === 7) return "Central Pacific";
  return "Western Hemisphere and Africa";
}

function buildMjoExplain(mjo){
  if (!mjo){
    return climateDriversCache.loading ? "Loading MJO activity signal." : "MJO is unavailable or stale. The dashboard continues without this context layer.";
  }
  const amp = mjo.amp;
  const phase = mjo.phase;
  const dateTxt = mjo.date ? ` (${mjo.date})` : "";
  const region = mjoPhaseRegion(phase);
  const ampTxt = (amp == null || !isFinite(amp)) ? "" : ` amplitude ${fmt(amp,2)}`;
  if (mjo.state === "Weak" || (amp != null && isFinite(amp) && amp < 1.0)){
    return `Weak MJO${dateTxt}, phase ${phase} in ${region}${ampTxt}. When the MJO is weak, it usually has limited direct influence on NZ rainfall patterns.`;
  }
  return `Active MJO${dateTxt}, phase ${phase} in ${region}${ampTxt}. As it propagates, it can support or suppress subtropical moisture pathways, so watch for alignment with local pressure and wind trends.`;
}

function pctText(frac){
  if (frac == null || !isFinite(frac)) return "-";
  return `${Math.round(frac * 100)}%`;
}

function plumeComponentLabel(kind, v){
  if (v == null || !isFinite(v)) return "Unknown";
  if (kind === "neFrac"){
    if (v >= 0.45) return "High";
    if (v >= 0.20) return "Moderate";
    return "Low";
  }
  if (kind === "rh"){
    if (v >= 78) return "Humid";
    if (v >= 68) return "Moderate";
    return "Dry";
  }
  if (kind === "vpd"){
    if (v <= 0.8) return "Low Drying";
    if (v <= 1.2) return "Moderate Drying";
    return "High Drying";
  }
  if (kind === "dp"){
    if (v <= -1.0) return "Falling";
    if (v >= 1.0) return "Rising";
    return "Steady";
  }
  if (kind === "rain3"){
    if (v >= 20) return "High";
    if (v >= 8) return "Moderate";
    return "Low";
  }
  return "Unknown";
}

function buildPlumeExplainText(sig){
  if (!sig){
    return "Plume signal is unavailable for this selection.";
  }
  const score = sig.score;
  const label = sig.label || (score == null ? "-" : ((score >= 75) ? "High" : (score >= 55) ? "Elevated" : (score >= 35) ? "Possible" : "Low"));
  const neTxt = (sig.neFrac == null) ? "-" : `${pctText(sig.neFrac)} ${plumeComponentLabel("neFrac", sig.neFrac)}`;
  const rhTxt = (sig.rhMean == null) ? "-" : `${fmt(sig.rhMean,0)}% ${plumeComponentLabel("rh", sig.rhMean)}`;
  const vpdTxt = (sig.vpdMean == null) ? "-" : `${fmt(sig.vpdMean,2)} kPa ${plumeComponentLabel("vpd", sig.vpdMean)}`;
  const dpTxt = (sig.dp == null) ? "-" : `${fmt(sig.dp,1)} hPa/24h ${plumeComponentLabel("dp", sig.dp)}`;
  const rainTxt = (sig.rain3 == null) ? "-" : `${fmt(sig.rain3,1)} mm ${plumeComponentLabel("rain3", sig.rain3)}`;

  const scoreTxt = (score == null || !isFinite(score)) ? "-" : `${fmt(score,0)}/100`;
  const headline = `Plume is ${label} (${scoreTxt}).`;
  const detail = `NE flow ${neTxt}. Humidity ${rhTxt}. VPD ${vpdTxt}. Pressure tendency ${dpTxt}. Forecast rain next 3 days ${rainTxt}.`;
  let guidance = "";
  if (label === "High" || label === "Elevated"){
    guidance = "This combination is more supportive of a subtropical moisture feed. Watch for increasing rain and humidity changes.";
  }else if (label === "Possible"){
    guidance = "Some supporting signals are present, but the setup is not strong. Monitor for strengthening NE flow and pressure falls.";
  }else{
    guidance = "Signals for a subtropical plume are limited right now. Local drying factors may dominate unless forecast rain increases.";
  }
  return `${headline} ${detail} ${guidance}`;
}

function applyClimateDriversToUi(){
  // District tags
  setTagInner("districtEnsoTag", buildDriverTag("enso", climateDriversCache.enso));
  setTagInner("districtSamTag", buildDriverTag("sam", climateDriversCache.sam));
  setTagInner("districtMjoTag", buildDriverTag("mjo", climateDriversCache.mjo));

  // Location detail tags
  setTagInner("locEnsoTag", buildDriverTag("enso", climateDriversCache.enso));
  setTagInner("locSamTag", buildDriverTag("sam", climateDriversCache.sam));
  setTagInner("locMjoTag", buildDriverTag("mjo", climateDriversCache.mjo));

  const meta = climateDriversCache.fetchedAt
    ? `Sources: CPC ONI, CPC AAO, BoM RMM. Updated ${fmtShortDateTime(climateDriversCache.fetchedAt)}`
    : `Sources: CPC ONI, CPC AAO, BoM RMM`;

  setText("districtDriversMeta", meta);
  setText("locDriversMeta", meta);

  // Explanations
  setText("districtExplainEnso", buildEnsoExplain(climateDriversCache.enso));
  setText("districtExplainSam", buildSamExplain(climateDriversCache.sam));
  setText("districtExplainMjo", buildMjoExplain(climateDriversCache.mjo));

  setText("locExplainEnso", buildEnsoExplain(climateDriversCache.enso));
  setText("locExplainSam", buildSamExplain(climateDriversCache.sam));
  setText("locExplainMjo", buildMjoExplain(climateDriversCache.mjo));
}

async function ensureClimateDriversFetched(force=false){
  const maxAgeMs = 6 * 60 * 60 * 1000;

  if (!force && climateDriversCache.fetchedAt && (Date.now() - climateDriversCache.fetchedAt) < maxAgeMs){
    return climateDriversCache;
  }
  if (climateDriversCache.loading){
    return climateDriversCache;
  }

  climateDriversCache.loading = true;
  applyClimateDriversToUi();

  const bustKey = Date.now();
  const bust = (u) => u + (u.includes("?") ? "&" : "?") + "_=" + bustKey;

  // Prefer direct sources, then fall back to proxy wrappers for CORS resilience
  const ensoBase = "https://www.cpc.ncep.noaa.gov/data/indices/oni.ascii.txt";
  const samBaseA = "https://ftp.cpc.ncep.noaa.gov/cwlinks/norm.daily.aao.index.b790101.current.ascii";
  const samBaseB = "https://psl.noaa.gov/data/correlation/aao.data";
  const mjoBase  = "https://www.bom.gov.au/climate/mjo/graphics/rmm.74toRealtime.txt";

  const ensoUrls = [
    bust(ensoBase),
    ensoBase,
    jinaWrap(bust(ensoBase)),
    jinaWrap(ensoBase),
    "https://corsproxy.io/?" + encodeURIComponent(bust(ensoBase))
  ];

  const samUrls = [
    bust(samBaseA),
    samBaseA,
    jinaWrap(bust(samBaseA)),
    jinaWrap(samBaseA),
    "https://corsproxy.io/?" + encodeURIComponent(bust(samBaseA)),
    bust(samBaseB),
    samBaseB,
    jinaWrap(bust(samBaseB)),
    jinaWrap(samBaseB),
    "https://corsproxy.io/?" + encodeURIComponent(bust(samBaseB))
  ];

  const mjoUrls = [
    bust(mjoBase),
    mjoBase,
    jinaWrap(bust(mjoBase)),
    jinaWrap(mjoBase),
    "https://corsproxy.io/?" + encodeURIComponent(bust(mjoBase))
  ];

  const looksLikeOni = (t) => /\bSEAS\b/i.test(t) && /\bANOM\b/i.test(t);
  const looksLikeAao = (t) => /\b\d{4}\s+\d{1,2}\s+\d{1,2}\s+[-+]?\d*\.?\d+/.test(t) || /\bAAO\b/i.test(t);
  const looksLikeRmm = (t) => /\bRMM1\b/i.test(t) || /\byear\s+month\s+day\b/i.test(t);

  try{
    const [ensoTxt, samTxt, mjoTxt] = await Promise.all([
      fetchTextWithFallback(ensoUrls, 16000, looksLikeOni),
      fetchTextWithFallback(samUrls, 16000, looksLikeAao),
      fetchTextWithFallback(mjoUrls, 16000, looksLikeRmm)
    ]);

    let enso = parseEnsoOni(ensoTxt);
    let sam = parseSamAao(samTxt);
    let mjo = parseMjoRmm(mjoTxt);

    // Freshness guard so we never show very old values as if they are current
    const nowYear = new Date().getUTCFullYear();
    if (enso && enso.year != null && enso.year < (nowYear - 2)) enso = null;
    if (sam && daysSinceDateStr(sam.date) > 60) sam = null;
    if (mjo && daysSinceDateStr(mjo.date) > 30) mjo = null;

    climateDriversCache.fetchedAt = Date.now();
    climateDriversCache.enso = enso || null;
    climateDriversCache.sam = sam || null;
    climateDriversCache.mjo = mjo || null;
  }catch(e){
    // Keep prior values (if any) but stop loading
  }finally{
    climateDriversCache.loading = false;
    applyClimateDriversToUi();
  }

  return climateDriversCache;
}

/***********************
 * NRC River Data
 ***********************/
// NRC river map points feed (your emergency map uses the same pattern).
// If you already have a proxy, set window.NRC_RIVERS_URL before this script runs.
const DEFAULT_NRC_RIVERS_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://env.gurudigital.nz/WebApi/GetMapPoints/2?collectionId=19");

const NRC_RIVERS_URL =
  (typeof window !== "undefined" &&
    typeof window.NRC_RIVERS_URL === "string" &&
    window.NRC_RIVERS_URL.trim())
    ? window.NRC_RIVERS_URL.trim()
    : DEFAULT_NRC_RIVERS_URL;

const NRC_RIVER_MAX_DISTANCE_KM =
  (typeof window !== "undefined" &&
    window.NRC_RIVER_MAX_DISTANCE_KM != null &&
    isFinite(Number(window.NRC_RIVER_MAX_DISTANCE_KM)))
    ? Number(window.NRC_RIVER_MAX_DISTANCE_KM)
    : 10;


/***********************
 * NRC Groundwater Data
 ***********************/
// NRC continuous groundwater map points feed (collectionId=30).
// You can override by setting window.NRC_GW_URL before this script runs.
const DEFAULT_NRC_GW_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://env.gurudigital.nz/WebApi/GetMapPoints/2?collectionId=30");

const NRC_GW_URL =
  (typeof window !== "undefined" &&
    typeof window.NRC_GW_URL === "string" &&
    window.NRC_GW_URL.trim())
    ? window.NRC_GW_URL.trim()
    : DEFAULT_NRC_GW_URL;

const NRC_GW_MAX_DISTANCE_KM =
  (typeof window !== "undefined" &&
    window.NRC_GW_MAX_DISTANCE_KM != null &&
    isFinite(Number(window.NRC_GW_MAX_DISTANCE_KM)))
    ? Number(window.NRC_GW_MAX_DISTANCE_KM)
    : 10;

function normaliseNrcGroundwaterSite(site){
  if (!site) return null;

  const title = site.DisplayName || site.Name || "Groundwater site";
  const primary = site.PrimaryMeasurement || null;
  const primaryValue = site.PrimaryValue || null;

  const level = primaryValue && primaryValue.Value != null ? Number(primaryValue.Value) : null;
  const levelUnits = primary && primary.Units ? String(primary.Units) : "";
  const levelMeasName = primary ? (primary.Name || primary.Measurement || primary.MeasurementName || primary.Label || primary.Code || null) : null;

  const levelWhen =
    primaryValue && (primaryValue.FormattedTime || primaryValue.FormattedDate)
      ? `${primaryValue.FormattedTime || ""} ${primaryValue.FormattedDate || ""}`.trim()
      : "";

  const hilltopBase =
    (site.DataServerUrl && site.DataEndPointName)
      ? `${site.DataServerUrl}/${site.DataEndPointName}?Service=Hilltop&Request=GetData`
      : NRC_HILLTOP_BASE;

  return {
    id: site.Id != null ? String(site.Id) : "",
    name: site.Name || title,
    title,
    lat: site.Latitude,
    lon: site.Longitude,
    level,
    levelUnits,
    levelMeasName,
    levelWhen,
    measurementId: primary && primary.Id != null ? String(primary.Id) : "",
    hilltopBase
  };
}

function pickNearestGroundwaterSite(loc, sites){
  if (!Array.isArray(sites) || !sites.length) return null;

  let best = null;
  let bestD = Infinity;

  for (const s of sites){
    if (!s || !s.HasLocation || s.Latitude == null || s.Longitude == null) continue;
    const d = haversineKm(loc.lat, loc.lon, Number(s.Latitude), Number(s.Longitude));
    if (d < bestD){
      bestD = d;
      best = s;
    }
  }

  if (!best || !isFinite(bestD)) return null;
  if (bestD > NRC_GW_MAX_DISTANCE_KM) return null;
  return { site: normaliseNrcGroundwaterSite(best), distanceKm: bestD };
}

function formatGroundwaterShort(gw){
  if (!gw || !gw.site) return "-";
  const s = gw.site;
  if (s.level != null && isFinite(s.level)){
    return `${fmt(s.level, 3)} ${s.levelUnits || ""}`.trim();
  }
  return "-";
}

function buildGroundwaterGaugeHtml(gw){
  if (!gw || !gw.site){
    return `Groundwater Level: <strong class="mono">-</strong><br/>`;
  }

  const s = gw.site;
  const title = escapeHtml(s.title || "Groundwater site");
  const dist = isFinite(gw.distanceKm) ? `${fmt(gw.distanceKm, 1)} km` : "";
  const distPart = dist ? `, ${dist}` : "";

  let html = `Groundwater Level: <strong class="mono">${escapeHtml(formatGroundwaterShort(gw))}</strong> <span class="muted">(${title}${distPart})</span><br/>`;

  if (s.levelWhen){
    html += `<span class="tiny muted">Reading Time: ${escapeHtml(s.levelWhen)}</span><br/>`;
  }

  return html;
}


function haversineKm(lat1, lon1, lat2, lon2){
  const R = 6371;
  const toRad = (d) => (d * Math.PI) / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  return 2 * R * Math.asin(Math.sqrt(a));
}

function parsePercent(value){
  if (value == null) return null;
  const m = String(value).match(/-?\d+(?:\.\d+)?/);
  return m ? Number(m[0]) : null;
}

function normaliseNrcRiverSite(site){
  if (!site) return null;

  const title = site.DisplayName || site.Name || "River site";
  const primary = site.PrimaryMeasurement || null;
  const secondary = site.SecondaryMeasurement || null;
  const primaryValue = site.PrimaryValue || null;
  const secondaryValue = site.SecondaryValue || null;

  const level = primaryValue && primaryValue.Value != null ? Number(primaryValue.Value) : null;
  const levelUnits = primary && primary.Units ? String(primary.Units) : "";
  const levelMeasName = primary ? (primary.Name || primary.Measurement || primary.MeasurementName || primary.Label || primary.Code || null) : null;
  const levelWhen =
    primaryValue && (primaryValue.FormattedTime || primaryValue.FormattedDate)
      ? `${primaryValue.FormattedTime || ""} ${primaryValue.FormattedDate || ""}`.trim()
      : "";

  const flow = secondaryValue && secondaryValue.Value != null ? Number(secondaryValue.Value) : null;
  const flowUnits = secondary && secondary.Units ? String(secondary.Units) : "";
  const flowMeasName = secondary ? (secondary.Name || secondary.Measurement || secondary.MeasurementName || secondary.Label || secondary.Code || null) : null;
  const flowWhen =
    secondaryValue && (secondaryValue.FormattedTime || secondaryValue.FormattedDate)
      ? `${secondaryValue.FormattedTime || ""} ${secondaryValue.FormattedDate || ""}`.trim()
      : "";

  const droughtInfo = site.DroughtInfo || null;
  const percentDiffDMF = droughtInfo ? parsePercent(droughtInfo.PercentDiffDMF) : null;

  const trend = site.Icon && site.Icon.Name ? String(site.Icon.Name) : "";
  const summaryHtml = site.Summary || "";

  return {
    title,
    level,
    levelUnits,
    levelMeasName,
    levelWhen,
    flow,
    flowUnits,
    flowMeasName,
    flowWhen,
    percentDiffDMF,
    malfText: droughtInfo && droughtInfo.MALFText ? String(droughtInfo.MALFText) : "",
    dmfText: droughtInfo && droughtInfo.DMFText ? String(droughtInfo.DMFText) : "",
    trend,
    summaryHtml,
    lat: site.Latitude,
    lon: site.Longitude
  };
}

// Picks the nearest NRC river site to a drought location.
// Returns { site: { ...normalised }, distanceKm } or null.
function pickNearestRiverSite(loc, sites){
  if (!Array.isArray(sites) || !sites.length) return null;

  let best = null;
  let bestD = Infinity;

  for (const s of sites){
    if (!s || !s.HasLocation || s.Latitude == null || s.Longitude == null) continue;
    const d = haversineKm(loc.lat, loc.lon, Number(s.Latitude), Number(s.Longitude));
    if (d < bestD){
      bestD = d;
      best = s;
    }
  }

  if (!best || !isFinite(bestD)) return null;
  if (bestD > NRC_RIVER_MAX_DISTANCE_KM) return null;
  return { site: normaliseNrcRiverSite(best), distanceKm: bestD };
}

function formatRiverShort(river){
  if (!river || !river.site) return "-";
  const s = river.site;

  if (s.flow != null && isFinite(s.flow)){
    return `${fmt(s.flow, 2)} ${s.flowUnits || ""}`.trim();
  }
  if (s.level != null && isFinite(s.level)){
    return `${fmt(s.level, 2)} ${s.levelUnits || ""}`.trim();
  }
  return "-";
}

function buildRiverGaugeHtml(river){
  if (!river || !river.site){
    return `River Gauge: <strong class="mono">-</strong><br/>`;
  }

  const s = river.site;
  const title = escapeHtml(s.title || "River site");
  const dist = isFinite(river.distanceKm) ? `${fmt(river.distanceKm, 1)} km` : "";
  const distPart = dist ? `, ${dist}` : "";

  let html = `River Gauge: <strong class="mono">${escapeHtml(formatRiverShort(river))}</strong> <span class="muted">(${title}${distPart})</span><br/>`;

  if (s.flowWhen){
    html += `<span class="tiny muted">Flow Time: ${escapeHtml(s.flowWhen)}</span><br/>`;
  } else if (s.levelWhen){
    html += `<span class="tiny muted">Level Time: ${escapeHtml(s.levelWhen)}</span><br/>`;
  }

  if (s.percentDiffDMF != null && isFinite(s.percentDiffDMF)){
    const sign = s.percentDiffDMF > 0 ? "+" : "";
    html += `<span class="tiny muted">Relative to DMF: ${sign}${fmt(s.percentDiffDMF, 0)}%</span><br/>`;
  }

  return html;
}




/***********************
 * NRC Hilltop River History
 ***********************/
// Hilltop GetData endpoint. History is pulled per location for the nearest river gauge.
// Override proxy by setting window.NRC_HILLTOP_PROXY_PREFIX before this script runs.
// Examples:
// window.NRC_HILLTOP_PROXY_PREFIX = "https://corsproxy.io/?url=";
// window.NRC_HILLTOP_PROXY_PREFIX = "https://api.allorigins.win/raw?url=";
// window.NRC_HILLTOP_PROXY_PREFIX = "https://your-proxy.example/fetch?url={url}";
const NRC_HILLTOP_BASE = "https://hilltop.nrc.govt.nz/data.hts?Service=Hilltop&Request=GetData";

function hilltopProxyWrap(rawUrl){
  const prefix =
    (typeof window !== "undefined" &&
      typeof window.NRC_HILLTOP_PROXY_PREFIX === "string" &&
      window.NRC_HILLTOP_PROXY_PREFIX.trim())
      ? window.NRC_HILLTOP_PROXY_PREFIX.trim()
      : (DASH_CONFIG.hilltop && typeof DASH_CONFIG.hilltop.proxyPrefix === "string" && DASH_CONFIG.hilltop.proxyPrefix.trim())
      ? DASH_CONFIG.hilltop.proxyPrefix.trim()
      : "https://corsproxy.io/?url=";

  if (!prefix) return rawUrl;

  const enc = encodeURIComponent(rawUrl);
  if (prefix.includes("{url}")) return prefix.replace("{url}", enc);
  return prefix + enc;
}

// Format "YYYY-MM-DD HH:mm" in Pacific/Auckland, which matches the Apps Script monitor pattern.
function formatAuckland(dt){
  const parts = new Intl.DateTimeFormat("en-NZ", {
    timeZone: "Pacific/Auckland",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false
  }).formatToParts(dt);

  const map = {};
  for (const p of parts) map[p.type] = p.value;
  return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}`;
}

function findHilltopDataArray(obj){
  if (!obj) return null;

  if (Array.isArray(obj)){
    if (obj.length && typeof obj[0] === "object" && obj[0] && ("t" in obj[0] || "T" in obj[0]) && ("v" in obj[0] || "V" in obj[0])) return obj;
    for (const it of obj){
      const found = findHilltopDataArray(it);
      if (found) return found;
    }
    return null;
  }

  if (typeof obj !== "object") return null;

  if (Array.isArray(obj.Data) && obj.Data.length) return obj.Data;

  for (const k of Object.keys(obj)){
    const found = findHilltopDataArray(obj[k]);
    if (found) return found;
  }
  return null;
}

function parseHilltopSeries(json){
  const arr = findHilltopDataArray(json) || [];
  const times = [];
  const values = [];
  for (const p of arr){
    if (!p || typeof p !== "object") continue;
    const t = p.t ?? p.T ?? p.time ?? p.Time ?? null;
    const v = p.v ?? p.V ?? p.value ?? p.Value ?? null;
    const num = v == null ? null : Number(v);
    if (!isFinite(num) || !t) continue;
    times.push(String(t));
    values.push(num);
  }
  // Ensure ascending time order if the feed is reversed
  if (times.length >= 2 && times[0] > times[times.length - 1]){
    times.reverse();
    values.reverse();
  }
  return { times, values };
}

const riverHistoryCache = new Map();
const gwHistoryCache = new Map();

function pickRiverHistoryMeasurement(site){
  if (!site) return { name: "Stage", label: "River Level", units: "" };

  // Prefer flow if available (drought relevance), otherwise stage/level.
  if (site.flow != null && isFinite(site.flow)){
    return {
      name: site.flowMeasName || "Flow",
      label: "River Flow",
      units: site.flowUnits || ""
    };
  }

  return {
    name: site.levelMeasName || "Stage",
    label: "River Level",
    units: site.levelUnits || ""
  };
}

function pickGroundwaterHistoryMeasurement(site){
  if (!site) return { name: "Groundwater", label: "Groundwater Level", units: "" };
  return {
    name: site.levelMeasName || "Groundwater Continuous MSL",
    label: "Groundwater Level",
    units: site.levelUnits || ""
  };
}


function mergeHilltopSeries(seriesList){
  const map = new Map();
  for (const s of (seriesList || [])){
    if (!s || !s.times || !s.values) continue;
    const n = Math.min(s.times.length, s.values.length);
    for (let i=0;i<n;i++){
      const t = s.times[i];
      const v = s.values[i];
      if (t == null) continue;
      const vv = Number(v);
      if (!isFinite(vv)) continue;
      // last value wins if duplicate times occur
      map.set(String(t), vv);
    }
  }
  const entries = Array.from(map.entries());
  entries.sort((a,b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0));
  return {
    times: entries.map(e => e[0]),
    values: entries.map(e => e[1])
  };
}

async function _fetchRiverHistoryRange(siteName, measurementName, from, to){
  const fromStr = (from instanceof Date ? from : new Date(from)).toISOString();
  const toStr   = (to   instanceof Date ? to   : new Date(to)).toISOString();

  const candidates = [
    measurementName,
    String(measurementName || "").replace(/\s*\(.*?\)\s*/g, "").trim(),
    String(measurementName || "").replace(/Discharge/i, "Flow"),
    String(measurementName || "").replace(/Flow/i, "Discharge"),
    String(measurementName || "").replace(/Stage/i, "Level"),
    String(measurementName || "").replace(/Level/i, "Stage")
  ].filter(s => s && s.length >= 2);

  const tried = new Set();

  for (const meas of candidates){
    const key = meas.toLowerCase();
    if (tried.has(key)) continue;
    tried.add(key);

    const raw = `${NRC_HILLTOP_BASE}?Service=Hilltop&Request=GetData&Site=${encodeURIComponent(siteName)}&Measurement=${encodeURIComponent(meas)}&From=${encodeURIComponent(fromStr)}&To=${encodeURIComponent(toStr)}&Format=JSON`;
    const url = hilltopProxyWrap(raw);

    try{
      const json = await fetchJson(url, 25000);
      const series = parseHilltopSeries(json);
      if (series && series.values && series.values.length) return series;
    } catch (e){
      // Try other measurement name variants
    }
  }

  return { times: [], values: [] };
}

async function fetchRiverHistory(siteName, measurementName, daysBack=7, toDate=null){
  const DAY_MS = 24*60*60*1000;
  const now = (toDate instanceof Date && !isNaN(toDate.getTime())) ? toDate : new Date();

// If a hosted GitHub manifest archive is active, try to satisfy this request from the archive first
if (DASH_CONFIG?.import?.enableManifestUrlLoad && DASH_CONFIG?.import?.lazyLoadHilltopMonthFiles && isRemoteArchiveActive()){
  const fromDate = new Date(now.getTime() - (daysBack * DAY_MS));
  try{
    const remoteSeries = await remoteFetchHilltopRangeAuto_(siteName, measurementName, fromDate, now);
    if (remoteSeries && Array.isArray(remoteSeries.values) && remoteSeries.values.length){
      return remoteSeries;
    }
  } catch (e){
    console.warn("Remote Hilltop archive fetch failed, falling back to live Hilltop.", e);
  }
}

  const days = Math.max(0, Number(daysBack) || 0);

  // These help avoid CORS proxy response-size limits (often ~1MB) for long historical ranges.
  // You can override these in the browser console:
  //   window.HILLTOP_MAX_DAYS_PER_CALL = 5..120 (default 31)
  //   window.HILLTOP_CHUNK_OVERLAP_HOURS = 0..6 (default 1)
  //   window.HILLTOP_BETWEEN_CHUNK_DELAY_MS = 0..20000 (default 200)
  const maxDaysPerCall = clamp(
    Number(window.HILLTOP_MAX_DAYS_PER_CALL) || (DASH_CONFIG.hilltop && DASH_CONFIG.hilltop.maxDaysPerCall) || 31,
    5, 120
  );
  const overlapHours = clamp(
    Number(window.HILLTOP_CHUNK_OVERLAP_HOURS) || (DASH_CONFIG.hilltop && DASH_CONFIG.hilltop.chunkOverlapHours) || 1,
    0, 6
  );
  const betweenChunkDelay = clamp(
    Number(window.HILLTOP_BETWEEN_CHUNK_DELAY_MS) || (DASH_CONFIG.hilltop && DASH_CONFIG.hilltop.betweenChunkDelayMs) || 200,
    0, 20000
  );

  if (days <= maxDaysPerCall){
    const from = new Date(now.getTime() - (days * DAY_MS));
    return await _fetchRiverHistoryRange(siteName, measurementName, from, now);
  }

  const overlapMs = overlapHours * 3600000;
  const parts = [];

  let remaining = days;
  let chunkTo = new Date(now.getTime());

  while (remaining > 0){
    const span = Math.min(maxDaysPerCall, remaining);
    const chunkFrom = new Date(chunkTo.getTime() - (span * DAY_MS) - overlapMs);

    const s = await _fetchRiverHistoryRange(siteName, measurementName, chunkFrom, chunkTo);
    if (s && s.values && s.values.length) parts.push(s);

    remaining -= span;
    chunkTo = new Date(chunkTo.getTime() - (span * DAY_MS));

    if (betweenChunkDelay && remaining > 0){
      await sleep(betweenChunkDelay);
    }
  }

  return mergeHilltopSeries(parts);
}


async function hydrateNrcGaugesAtAsOf(riverForLoc, gwForLoc, asOf){
  if (!(asOf instanceof Date) || isNaN(asOf.getTime())) return;

  const tasks = [];

  // Rivers: update flow/level value and timestamp to the last sample at or before the snapshot
  (riverForLoc || []).forEach((riverGauge) => {
    if (!riverGauge || !riverGauge.site) return;
    const site = riverGauge.site;
    const meas = pickRiverHistoryMeasurement(site);
    if (!meas || !meas.name) return;

    tasks.push((async () => {
      const series = await fetchRiverHistory(site.name || site.title, meas.name, 7, asOf);
      if (!series || !Array.isArray(series.values) || !series.values.length) return;

      const lastVal = series.values[series.values.length - 1];
      const lastTime = series.times[series.times.length - 1];

      // If the chosen measurement is stage, store it in level, otherwise store in flow
      const measNameLower = String(series.measurementName || meas.name).toLowerCase();
      const isStage = measNameLower.includes("stage") || measNameLower.includes("level");

      if (isStage){
        site.level = lastVal;
        site.levelWhen = formatWhenNZ(lastTime);
        if (!site.levelUnits) site.levelUnits = series.unit || site.levelUnits || "";
      } else {
        site.flow = lastVal;
        site.flowWhen = formatWhenNZ(lastTime);
        if (!site.flowUnit) site.flowUnit = series.unit || site.flowUnit || "";
      }
    })());
  });

  // Groundwater: update level value and timestamp to the last sample at or before the snapshot
  (gwForLoc || []).forEach((gwGauge) => {
    if (!gwGauge || !gwGauge.site) return;
    const site = gwGauge.site;
    const meas = pickGroundwaterHistoryMeasurement(site);
    if (!meas || !meas.name) return;

    tasks.push((async () => {
      const series = await fetchRiverHistory(site.name || site.title, meas.name, 14, asOf);
      if (!series || !Array.isArray(series.values) || !series.values.length) return;

      const lastVal = series.values[series.values.length - 1];
      const lastTime = series.times[series.times.length - 1];

      site.level = lastVal;
      site.levelWhen = formatWhenNZ(lastTime);
      if (!site.levelUnits) site.levelUnits = series.unit || site.levelUnits || "";
    })());
  });

  await Promise.allSettled(tasks);
}




function riverDeltaText(values, units){
  if (!values || values.length < 2) return "";
  const first = values[0];
  const last = values[values.length - 1];
  if (!isFinite(first) || !isFinite(last)) return "";
  const delta = last - first;
  const sign = delta > 0 ? "+" : "";
  const pct = first !== 0 ? (delta / first) * 100 : null;
  const pctPart = pct == null || !isFinite(pct) ? "" : ` (${sign}${fmt(pct, 1)}%)`;
  const unitPart = units ? ` ${units}` : "";
  return `${sign}${fmt(delta, 2)}${unitPart}${pctPart}`;
}

async function updateRiverSpark(row){
  const c = document.getElementById("sparkRiver");
  const meta = document.getElementById("sparkRiverMeta");
  if (!c) return;

  // v5 bugfix: details panel stores the nearest gauge under row.riverGauge (not row.river).
  const river = row && row.riverGauge ? row.riverGauge : null;

  // Clear canvas if no river site
  if (!river || !river.site){
    const ctx = c.getContext("2d");
    const w = c.width = c.clientWidth * devicePixelRatio;
    const h = c.height = c.clientHeight * devicePixelRatio;
    ctx.clearRect(0,0,w,h);
    if (meta) meta.textContent = "No river site found near this location";
    setMiniTrendSeries("sparkRiver", "sparkRiverTooltip", [], [], { label: "River" });
    return;
  }

  const s = river.site;
  const meas = pickRiverHistoryMeasurement(s);
  const siteName = s.title || s.name || s.siteName || "";
  const asOf = getAsOfDate();
  const endStamp = formatDateTimeLocal(asOf);
  const cacheKey = `${siteName}||${meas.name}||${endStamp}||7`;
if (meta) meta.textContent = `Loading ${meas.label.toLowerCase()} history...`;

  let series = riverHistoryCache.get(cacheKey);
  if (!series){
    try{
      series = await fetchRiverHistory(siteName, meas.name, 7, asOf);
      riverHistoryCache.set(cacheKey, series);
    } catch (e){
      if (meta) meta.textContent = `River history unavailable (Hilltop request failed)`;
      setMiniTrendSeries("sparkRiver", "sparkRiverTooltip", [], [], { label: meas.label });
      return;
    }
  }

  if (!series || !series.values || series.values.length < 2){
    if (meta) meta.textContent = `No recent data returned for ${meas.label.toLowerCase()}`;
    setMiniTrendSeries("sparkRiver", "sparkRiverTooltip", [], [], { label: meas.label });
    return;
  }

  setMiniTrendSeries(
    "sparkRiver",
    "sparkRiverTooltip",
    series.times,
    series.values,
    {
      label: meas.label,
      valFmt: (v) => {
        if (!isFinite(v)) return "-";
        // Auto unit for discharge: show L/s when < 1 m3/s
        if (meas.units && String(meas.units).toLowerCase().includes("m3") && Math.abs(v) < 1) {
          return fmt(v * 1000, 2);
        }
        return fmt(v, 3);
      },
      yFmt: (v) => {
        if (!isFinite(v)) return "-";
        if (meas.units && String(meas.units).toLowerCase().includes("m3") && Math.abs(v) < 1) {
          return fmt(v * 1000, 0);
        }
        return fmt(v, 2);
      },
      unit: (meas.units && String(meas.units).toLowerCase().includes("m3")) ? (Math.abs(series.values[series.values.length-1]) < 1 ? "L/s" : "m³/s") : (meas.units || "")
    }
  );

    const lastVal = series.values[series.values.length - 1];
  const isDischarge = meas.units && String(meas.units).toLowerCase().includes("m3");
  const displayUnit = isDischarge ? (Math.abs(lastVal) < 1 ? "L/s" : "m³/s") : (meas.units || "");
  const displayVal = isDischarge && Math.abs(lastVal) < 1 ? (lastVal * 1000) : lastVal;

const delta = riverDeltaText(series.values, meas.units);
  const dist = isFinite(river.distanceKm) ? `${fmt(river.distanceKm, 1)} km` : "";
  const distPart = dist ? `, ${dist}` : "";
  if (meta) meta.textContent = `${meas.label}: ${fmt(displayVal, 2)}${displayUnit ? " " + displayUnit : ""} (7 days, Δ ${delta}) • ${siteName}${distPart}`;
}


async function updateGroundwaterSpark(row){
  const c = document.getElementById("sparkGW");
  const meta = document.getElementById("sparkGWMeta");
  if (!c) return;

  const gw = row && row.gwGauge ? row.gwGauge : null;

  if (!gw || !gw.site){
    const ctx = c.getContext("2d");
    const w = c.width = c.clientWidth * devicePixelRatio;
    const h = c.height = c.clientHeight * devicePixelRatio;
    ctx.clearRect(0,0,w,h);
    if (meta) meta.textContent = "No groundwater site found near this location";
    setMiniTrendSeries("sparkGW", "sparkGWTooltip", [], [], { label: "Groundwater Level" });
    return;
  }

  const s = gw.site;
  const meas = pickGroundwaterHistoryMeasurement(s);
  const siteName = s.name || s.title || "";
  const asOf = getAsOfDate();
  const endStamp = formatDateTimeLocal(asOf);
  const cacheKey = `${siteName}||${meas.name}||${endStamp}||7`;
const distPart = isFinite(gw.distanceKm) ? ` (${fmt(gw.distanceKm, 1)} km)` : "";

  if (meta) meta.textContent = `Loading ${meas.label.toLowerCase()} history...`;

  let series = gwHistoryCache.get(cacheKey);
  if (!series){
    try{
      // Reuse Hilltop fetch logic (same as rivers), defaulting to the NRC_HILLTOP_BASE endpoint.
      series = await fetchRiverHistory(siteName, meas.name, 7, asOf);
      gwHistoryCache.set(cacheKey, series);
    } catch (e){
      const ctx = c.getContext("2d");
      const w = c.width = c.clientWidth * devicePixelRatio;
      const h = c.height = c.clientHeight * devicePixelRatio;
      ctx.clearRect(0,0,w,h);
      if (meta) meta.textContent = `Groundwater history unavailable (Hilltop request failed) • ${siteName}${distPart}`;
      return;
    }
  }

  setMiniTrendSeries(
    "sparkGW",
    "sparkGWTooltip",
    series.times,
    series.values,
    { label: "Groundwater Level", unit: "m", valFmt: (v) => fmt(v, 3), yFmt: (v) => fmt(v, 2) }
  );

  const delta = riverDeltaText(series.values, meas.units || "");
  if (meta) meta.textContent = `${meas.label}${meas.units ? " " + meas.units : ""} (7 days, Δ ${delta}) • ${siteName}${distPart}`;
}


    /******************************************
     * Open-Meteo Requests
     ***********************/
    
function getRequiredLookbackDays(){
  // Ensure we have enough history for rain window, RH window, soil baseline, and trend charts
  const w = droughtConfig?.windows || {};
  const lookback = Math.max(
    Number(w.rainPastDays)||14,
    Number(w.rhPastDays)||7,
    Number(w.soilBaselineDays)||30,
    7
  );
  return lookback + 2;
}

function getRequiredLookaheadDays(forecastDays){
  const w = droughtConfig?.windows || {};
  const lookahead = Math.max(
    Number(forecastDays)||7,
    Number(w.et0ForecastDays)||7,
    Number(w.vpdForecastDays)||7
  );
  return lookahead + 2;
}

// Returns {start: Date, end: Date, asOf: Date} for historic fetch windows.
function computeHistoricFetchWindow(pastDays, forecastDays){
  const now = nowLocal();
  const preDaysRange = Math.max(Number(pastDays)||30, getRequiredLookbackDays());
  const preDaysSnapshot = Math.max(30, getRequiredLookbackDays());
  const postDays = Math.max(Number(forecastDays)||7, getRequiredLookaheadDays(forecastDays));

  // If a playback range is set, fetch for the whole range (plus buffers).
  if (historicUseRange && historicRangeStart instanceof Date && !isNaN(historicRangeStart.getTime()) &&
      historicRangeEnd instanceof Date && !isNaN(historicRangeEnd.getTime())){
    let rs = new Date(historicRangeStart.getTime());
    let re = new Date(historicRangeEnd.getTime());
    if (rs > re){ const tmp = rs; rs = re; re = tmp; }
    if (re > now) re = new Date(now.getTime());

    const start = new Date(rs.getTime());
    start.setDate(start.getDate() - preDaysRange);

    let end = new Date(re.getTime());
    end.setDate(end.getDate() + postDays);
    if (end > now) end = new Date(now.getTime());

    // Use cursor as-of if available otherwise range start.
    let asOf = (asOfSnapshot instanceof Date && !isNaN(asOfSnapshot.getTime())) ? new Date(asOfSnapshot.getTime()) : new Date(rs.getTime());
    if (asOf < rs) asOf = new Date(rs.getTime());
    if (asOf > re) asOf = new Date(re.getTime());
    return { start, end, asOf, rangeStart: rs, rangeEnd: re };
  }

  // Single historic snapshot window (plus buffers).
  let asOf = (asOfSnapshot instanceof Date && !isNaN(asOfSnapshot.getTime())) ? new Date(asOfSnapshot.getTime()) : new Date(now.getTime());
  if (asOf > now) asOf = new Date(now.getTime());

  const start = new Date(asOf.getTime());
  start.setDate(start.getDate() - preDaysSnapshot);

  let end = new Date(asOf.getTime());
  end.setDate(end.getDate() + postDays);
  if (end > now) end = new Date(now.getTime());

  return { start, end, asOf, rangeStart: null, rangeEnd: null };
}

function cacheCoversAsOf(d){
  if (!dataCache.rangeMin || !dataCache.rangeMax) return false;
  let pastDays = clamp(Number($("pastDays").value) || 30, 7, 92);
  const forecastDays = clamp(Number($("forecastDays").value) || 7, 3, 16);

  // Snapshot mode should always include at least 30 days lookback (like Live).
  if (timeMode === "historic" && !historicUseRange){
    pastDays = Math.max(pastDays, 30);
  }
  const preDays = Math.max(pastDays, getRequiredLookbackDays());
  const postDays = Math.max(forecastDays, getRequiredLookaheadDays(forecastDays));

  const reqMin = new Date(d.getTime()); reqMin.setDate(reqMin.getDate() - preDays);
  const reqMax = new Date(d.getTime()); reqMax.setDate(reqMax.getDate() + postDays);

  return reqMin >= dataCache.rangeMin && reqMax <= dataCache.rangeMax;
}

function setPlaybackStatus(msg){
  const el = document.getElementById("playbackStatus");
  if (el) el.textContent = msg;
}

function showPlaybackPanel(show){
  const p = document.getElementById("playbackPanel");
  if (p) p.style.display = show ? "" : "none";
}

function syncPlaybackInputs(){
  const rs = document.getElementById("rangeStartInput");
  const re = document.getElementById("rangeEndInput");
  const stepSel = document.getElementById("playStep");
  const speedSel = document.getElementById("playSpeed");
  const loopChk = document.getElementById("playLoop");
  const hydroChk = document.getElementById("playHydro");

  if (stepSel){
    const saved = localStorage.getItem(STORAGE_KEY_PLAY_STEP);
    if (saved) playbackState.stepMinutes = Number(saved) || playbackState.stepMinutes;
    stepSel.value = String(playbackState.stepMinutes);
  }
  if (speedSel){
    const saved = localStorage.getItem(STORAGE_KEY_PLAY_SPEED);
    if (saved) playbackState.speedMs = Number(saved) || playbackState.speedMs;
    speedSel.value = String(playbackState.speedMs);
  }
  if (loopChk){
    const saved = localStorage.getItem(STORAGE_KEY_PLAY_LOOP);
    if (saved != null) playbackState.loop = saved === "true";
    loopChk.checked = playbackState.loop;
  }
  if (hydroChk){
    const saved = localStorage.getItem(STORAGE_KEY_PLAY_HYDRO);
    if (saved != null) playbackState.hydro = saved === "true";
    hydroChk.checked = playbackState.hydro;
  }

  // Range defaults
  if (rs && re){
    const savedStart = localStorage.getItem(STORAGE_KEY_RANGE_START);
    const savedEnd = localStorage.getItem(STORAGE_KEY_RANGE_END);
    const dStart = savedStart ? new Date(savedStart) : null;
    const dEnd = savedEnd ? new Date(savedEnd) : null;

    if (dStart && !isNaN(dStart.getTime())) historicRangeStart = dStart;
    if (dEnd && !isNaN(dEnd.getTime())) historicRangeEnd = dEnd;

    // If no saved range, set a sensible default around the current as-of
    const base = getAsOfDate();
    if (!(historicRangeStart instanceof Date) || isNaN(historicRangeStart.getTime())){
      const s = new Date(base.getTime()); s.setDate(s.getDate() - 14);
      historicRangeStart = s;
    }
    if (!(historicRangeEnd instanceof Date) || isNaN(historicRangeEnd.getTime())){
      historicRangeEnd = new Date(base.getTime());
    }

    rs.value = formatDateTimeLocal(historicRangeStart);
    re.value = formatDateTimeLocal(historicRangeEnd);
  }
}

function updatePlaybackSlider(){
  const slider = document.getElementById("playSlider");
  const label = document.getElementById("playTimeLabel");
  if (!slider) return;

  const asOf = getAsOfDate();
  if (!historicUseRange || !(historicRangeStart instanceof Date) || !(historicRangeEnd instanceof Date)) {
    slider.min = "0";
    slider.max = "0";
    slider.step = "1";
    slider.value = "0";
    slider.disabled = true;
    if (label) label.textContent = `Cursor: ${formatDateTimeLocal(asOf)} | Range: not loaded (click Load Range)`;
    return;
  }

  slider.disabled = false;

  let rs = new Date(historicRangeStart.getTime());
  let re = new Date(historicRangeEnd.getTime());
  if (rs > re){ const tmp = rs; rs = re; re = tmp; }

  const stepMs = playbackState.stepMinutes * 60 * 1000;
  const steps = Math.max(0, Math.floor((re.getTime() - rs.getTime()) / stepMs));
  slider.min = "0";
  slider.max = String(steps);
  slider.step = "1";

  // Set slider to match current as-of
  const idx = Math.max(0, Math.min(steps, Math.round((asOf.getTime() - rs.getTime()) / stepMs)));
  slider.value = String(idx);

  if (label){
    label.textContent = `Cursor: ${formatDateTimeLocal(asOf)} | Range: ${formatDateTimeLocal(rs)} to ${formatDateTimeLocal(re)} | Step: ${playbackState.stepMinutes} min`;
  }
}

function getCursorFromSlider(){
  const slider = document.getElementById("playSlider");
  if (!slider || !historicUseRange || !(historicRangeStart instanceof Date) || !(historicRangeEnd instanceof Date)) return null;
  const rs = new Date(historicRangeStart.getTime());
  const stepMs = playbackState.stepMinutes * 60 * 1000;
  const idx = Number(slider.value) || 0;
  return new Date(rs.getTime() + idx * stepMs);
}

async function seekCursor(d, opts){
  const options = opts || {};
  if (!(d instanceof Date) || isNaN(d.getTime())) return;

  asOfSnapshot = d;
  localStorage.setItem(STORAGE_KEY_ASOF, asOfSnapshot.toISOString());

  const inpAsOf = document.getElementById("asOfInput");
  if (inpAsOf){
    inpAsOf.value = formatDateTimeLocal(asOfSnapshot);
    pendingAsOfStr = inpAsOf.value;
  }

  updatePlaybackSlider();

  if (timeMode !== "historic"){
    recomputeFromCache();
    return;
  }

  // If we already have enough cached data, recompute only.
  if (dataCache.wxList && cacheCoversAsOf(asOfSnapshot)){
    recomputeFromCache();
    // Optional hydrology updates (slow)
    if (playbackState.hydro){
      const nowT = asOfSnapshot.getTime();
      const last = playbackState.lastHydroAt ? playbackState.lastHydroAt.getTime() : 0;
      const minInterval = Math.max(6*60*60*1000, playbackState.stepMinutes*60*1000);
      if ((nowT - last) >= minInterval){
        playbackState.lastHydroAt = new Date(asOfSnapshot.getTime());
        try{
          await hydrateNrcGaugesAtAsOf(dataCache.riverForLoc, dataCache.gwForLoc, asOfSnapshot);
          recomputeFromCache();
        } catch(e){
          // ignore
        }
      }
    }
    return;
  }

  if (options.allowRefresh !== false){
    await refresh();
  } else {
    showToast("This timestamp is outside the loaded range. Load Range or Refresh Data.");
  }
}

function setPlayButtons(isPlaying){
  const bPlay = document.getElementById("btnPlay");
  const bPause = document.getElementById("btnPause");
  if (bPlay) bPlay.style.display = isPlaying ? "none" : "";
  if (bPause) bPause.style.display = isPlaying ? "" : "none";
}

function stopPlayback(){
  playbackState.isPlaying = false;
  if (playbackState.timer){
    clearInterval(playbackState.timer);
    playbackState.timer = null;
  }
  setPlayButtons(false);
  setPlaybackStatus("Paused");
}

function startPlayback(){
  if (playbackState.isPlaying) return;
  if (!historicUseRange){
    showToast("Load Range first.");
    playbackState.isPlaying = false;
    setPlayButtons(false);
    return;
  }
  playbackState.isPlaying = true;
  setPlayButtons(true);
  setPlaybackStatus("Playing...");

  playbackState.timer = setInterval(async () => {
    const slider = document.getElementById("playSlider");
    if (!slider){ stopPlayback(); return; }

    const max = Number(slider.max) || 0;
    let v = Number(slider.value) || 0;
    v += 1;
    if (v > max){
      if (playbackState.loop){
        v = 0;
      } else {
        stopPlayback();
        return;
      }
    }
    slider.value = String(v);
    const c = getCursorFromSlider();
    if (c) await seekCursor(c, { allowRefresh: false });
  }, playbackState.speedMs);
}


function buildForecastUrl(locs, pastDays, forecastDays){
      const hourlyVars = [
        "soil_moisture_0_1cm",
        "soil_moisture_1_3cm",
        "soil_moisture_3_9cm",
        "soil_moisture_9_27cm",
        "soil_moisture_27_81cm",
        "relative_humidity_2m",
        "vapour_pressure_deficit",
        "temperature_2m",
        "pressure_msl",
        "wind_speed_10m",
        "wind_direction_10m"
      ].join(",");

      const dailyVars = [
        "precipitation_sum",
        "et0_fao_evapotranspiration"
      ].join(",");

      const params = new URLSearchParams({
        hourly: hourlyVars,
        daily: dailyVars,
        timezone: "Pacific/Auckland"
      });

      const lats = locs.map(l => l.lat).join(",");
      const lons = locs.map(l => l.lon).join(",");
      params.set("latitude", lats);
      params.set("longitude", lons);

      // Historic mode: request an explicit window around the selected date/time or playback range.
      if (timeMode === "historic"){
        const win = computeHistoricFetchWindow(pastDays, forecastDays);
        params.set("start_date", ymdLocal(win.start));
        params.set("end_date", ymdLocal(win.end));
        return "https://historical-forecast-api.open-meteo.com/v1/forecast?" + params.toString();
      }

      params.set("past_days", String(pastDays));
      params.set("forecast_days", String(forecastDays));
      return "https://api.open-meteo.com/v1/forecast?" + params.toString();
    }

    function buildFloodUrl(locs, pastDays, forecastDays){
      const params = new URLSearchParams({
        daily: "river_discharge",
        timezone: "Pacific/Auckland"
      });

      const lats = locs.map(l => l.lat).join(",");
      const lons = locs.map(l => l.lon).join(",");
      params.set("latitude", lats);
      params.set("longitude", lons);

      if (timeMode === "historic"){
        const win = computeHistoricFetchWindow(pastDays, forecastDays);
        params.set("start_date", ymdLocal(win.start));
        params.set("end_date", ymdLocal(win.end));
        return "https://flood-api.open-meteo.com/v1/flood?" + params.toString();
      }

      params.set("past_days", String(pastDays));
      params.set("forecast_days", String(forecastDays));
      return "https://flood-api.open-meteo.com/v1/flood?" + params.toString();
    }

    /***********************
     * Drought Computation
     ***********************/
    function computeLocationIndex(wx, flood, nowDate){
      const daily = wx?.daily || {};
      const hourly = wx?.hourly || {};

      const pastRain14 = sumDailyWindow(daily.time, daily.precipitation_sum, nowDate, droughtConfig.windows.rainPastDays);
      const forecastRain7 = sumDailyFuture(daily.time, daily.precipitation_sum, nowDate, 7);

      const rainDry14 = normalizeInverse(pastRain14, droughtConfig.thresholds.rain14.wet, droughtConfig.thresholds.rain14.dry);
      const rainDryFc = normalizeInverse(forecastRain7, droughtConfig.thresholds.rain7Forecast.wet, droughtConfig.thresholds.rain7Forecast.dry);
      const rainComponent = (rainDry14 == null && rainDryFc == null) ? null :
        (0.70 * (rainDry14 ?? 0.5) + 0.30 * (rainDryFc ?? 0.5));

      // Soil moisture component (relative dryness vs recent baseline range)
      let soilComponent = null;
      let soilDetails = [];
      let soilSum = 0;
      let soilW = 0;

      for (const layer of droughtConfig.soilLayers){
        const arr = hourly[layer.key];
        if (!arr) {
          soilDetails.push({ key: layer.key, label: layer.label, current: null, dryness: null });
          continue;
        }

        const current = lastHourlyAtOrBeforeNow(hourly.time, arr, nowDate);
        const mm = minMaxHourlyWindow(hourly.time, arr, nowDate, droughtConfig.windows.soilBaselineDays);

        let dryness = null;
        if (current != null && mm.min != null && mm.max != null){
          const denom = (mm.max - mm.min);
          dryness = denom <= 1e-9 ? 0.5 : clamp(1 - ((current - mm.min) / denom), 0, 1);
        }

        soilDetails.push({ key: layer.key, label: layer.label, current, dryness, min: mm.min, max: mm.max });

        if (dryness != null){
          soilSum += dryness * layer.w;
          soilW += layer.w;
        }
      }

      if (soilW > 0) soilComponent = soilSum / soilW;

      // Evap demand component
      const et0_7 = sumDailyFuture(daily.time, daily.et0_fao_evapotranspiration, nowDate, droughtConfig.windows.et0ForecastDays);
      const et0Dry = normalize(et0_7, droughtConfig.thresholds.et07.low, droughtConfig.thresholds.et07.high);

      const vpdMean = meanHourlyFuture(hourly.time, hourly.vapour_pressure_deficit, nowDate, droughtConfig.windows.vpdForecastDays, (dt) => {
        const h = dt.getHours();
        return h >= 9 && h <= 18;
      });
      const vpdDry = normalize(vpdMean, droughtConfig.thresholds.vpd.low, droughtConfig.thresholds.vpd.high);

      const evapComponent = (et0Dry == null && vpdDry == null) ? null : (0.60 * (et0Dry ?? 0.5) + 0.40 * (vpdDry ?? 0.5));

      // Humidity component (low RH -> higher dryness)
      const rhMean7 = meanHourlyWindow(hourly.time, hourly.relative_humidity_2m, nowDate, droughtConfig.windows.rhPastDays);
      const rhDry = normalizeInverse(rhMean7, droughtConfig.thresholds.rh7.wet, droughtConfig.thresholds.rh7.dry);

      // River discharge component (modelled, optional)
      let riverComponent = null;
      let riverNow = null;
      if (flood?.daily?.river_discharge && flood?.daily?.time){
        const rd = flood.daily.river_discharge;
        const rt = flood.daily.time;
        const todayKey = nowDate.toISOString().slice(0,10);

        let idx = -1;
        for (let i=0;i<rt.length;i++){
          if (rt[i] <= todayKey) idx = i;
        }
        if (idx >= 0){
          riverNow = rd[idx];

          const start = Math.max(0, idx - 29);
          let min = Infinity, max = -Infinity, found = false;
          for (let i=start;i<=idx;i++){
            const v = rd[i];
            if (v != null && !isNaN(v)){
              min = Math.min(min, v);
              max = Math.max(max, v);
              found = true;
            }
          }
          if (found){
            const denom = (max - min);
            riverComponent = denom <= 1e-9 ? 0.5 : clamp(1 - ((riverNow - min) / denom), 0, 1);
          }
        }
      }

      const parts = [
        { key: "soil", val: soilComponent, w: droughtConfig.weights.soil },
        { key: "rain", val: rainComponent, w: droughtConfig.weights.rain },
        { key: "evap", val: evapComponent, w: droughtConfig.weights.evap },
        { key: "river", val: riverComponent, w: droughtConfig.weights.river },
        { key: "humidity", val: rhDry, w: droughtConfig.weights.humidity }
      ];

      let wSum = 0;
      let scoreSum = 0;
      for (const p of parts){
        if (p.val == null) continue;
        wSum += p.w;
        scoreSum += p.val * p.w;
      }

      const score = wSum > 0 ? clamp((scoreSum / wSum) * 100, 0, 100) : null;

      return {
        score,
        parts: {
          soil: soilComponent,
          rain: rainComponent,
          evap: evapComponent,
          humidity: rhDry,
          river: riverComponent
        },
        metrics: {
          pastRain14,
          forecastRain7,
          et0_7,
          vpdMean,
          rhMean7,
          riverNow
        },
        soilDetails
      };
    }

    /***********************
     * UI and Map
     ***********************/
    let map, markerLayer;
    let locations = [];
    let computed = [];
    let selectedId = null;

    function initMap(){
      map = L.map("map", { zoomControl: true });
      markerLayer = L.layerGroup().addTo(map);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      map.setView([-35.2, 173.6], 8);
    }

    function loadLocations(){
      const raw = localStorage.getItem(STORAGE_KEY_LOCATIONS);
      if (!raw) return DEFAULT_LOCATIONS.slice();
      const parsed = safeJsonParse(raw);
      if (!Array.isArray(parsed)) return DEFAULT_LOCATIONS.slice();
      const cleaned = parsed
        .filter(x => x && typeof x === "object")
        .map(x => ({
          id: String(x.id ?? "").trim() || ("loc_" + Math.random().toString(16).slice(2)),
          name: String(x.name ?? "Unnamed").trim(),
          lat: Number(x.lat),
          lon: Number(x.lon)
        }))
        .filter(x => isFinite(x.lat) && isFinite(x.lon) && x.name);
      return cleaned.length ? cleaned : DEFAULT_LOCATIONS.slice();
    }

    function saveLocations(list){
      localStorage.setItem(STORAGE_KEY_LOCATIONS, JSON.stringify(list, null, 2));
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function renderMarkers(){
      markerLayer.clearLayers();
      const bounds = [];

      for (const row of computed){
        const cat = categoryForIndex(row.index.score);
        const color = cat.color;

        const marker = L.circleMarker([row.loc.lat, row.loc.lon], {
          radius: 10,
          color: "rgba(255,255,255,0.20)",
          weight: 1,
          fillColor: color,
          fillOpacity: 0.85
        });

        marker.on("click", () => selectLocation(row.loc.id, true));

        marker.bindPopup(`
          <div style="font-family: system-ui; font-size: 13px;">
            <div style="font-weight: 700; margin-bottom: 6px;">${escapeHtml(row.loc.name)}</div>
            <div><strong>Index:</strong> ${fmt(row.index.score, 0)} <span style="opacity:0.8">(${cat.name})</span></div>
            <div style="margin-top: 6px; opacity: 0.85;">
              Rain 14d: ${fmt(row.index.metrics.pastRain14, 1)} mm<br/>
              Soil 9-27: ${fmt(row.soil9_27, 3)}<br/>
              Soil 27-81: ${fmt(row.soil27_81, 3)}<br/>
              ET0 7d: ${fmt(row.index.metrics.et0_7, 1)} mm<br/>
              Groundwater: ${row.gwGauge ? escapeHtml(formatGroundwaterShort(row.gwGauge)) : "-"}<br/>
              River Gauge: ${row.riverGauge ? escapeHtml(formatRiverShort(row.riverGauge)) : "-"}
            </div>
          </div>
        `);

        marker.addTo(markerLayer);
        bounds.push([row.loc.lat, row.loc.lon]);
      }

      if (bounds.length){
        const b = L.latLngBounds(bounds);
        map.fitBounds(b.pad(0.15));
      }
    }

    function renderTable(){
      const tbody = $("tbody");
      tbody.innerHTML = "";

      for (const row of computed){
        const cat = categoryForIndex(row.index.score);
        const tr = document.createElement("tr");
        tr.dataset.id = row.loc.id;

        tr.innerHTML = `
          <td><strong>${escapeHtml(row.loc.name)}</strong><div class="muted mono" style="font-size:12px;">${row.loc.lat.toFixed(4)}, ${row.loc.lon.toFixed(4)}</div></td>
          <td class="mono"><strong>${fmt(row.index.score, 0)}</strong></td>
          <td>
            <span class="tag">
              <span class="dot" style="background:${cat.color}; box-shadow: 0 0 0 4px rgba(255,255,255,0.06);"></span>
              ${cat.name}
            </span>
          </td>
          <td class="mono">${fmt(row.index.metrics.pastRain14, 1)} mm</td>
          <td class="mono">${fmt(row.soil9_27, 3)}</td>
          <td class="mono">${fmt(row.soil27_81, 3)}</td>
          <td class="mono">${fmt(row.index.metrics.et0_7, 1)} mm</td>
          <td class="mono">${fmt(row.index.metrics.rhMean7, 0)}%</td>
          <td class="mono">${row.gwGauge ? escapeHtml(formatGroundwaterShort(row.gwGauge)) : "-"}</td>
          <td class="mono">${row.riverGauge ? escapeHtml(formatRiverShort(row.riverGauge)) : "-"}</td>
        `;

        tr.addEventListener("click", () => selectLocation(row.loc.id, true));
        tbody.appendChild(tr);
      }
    }

    function renderDistrictKPIs(){
      const scores = computed.map(r => r.index.score).filter(x => x != null && !isNaN(x));
      if (!scores.length){
        $("kpiMean").textContent = "-";
        $("kpiMedian").textContent = "-";
        $("kpiWorst").textContent = "-";
        $("kpiWorstName").textContent = "";
        $("kpiRain14").textContent = "-";
        $("kpiRain7").textContent = "-";
        $("kpiET07").textContent = "-";
        $("kpiVPD7").textContent = "-";
        $("kpiRH7").textContent = "-";
        $("kpiMeanCat").textContent = "";
        $("kpiMedianCat").textContent = "";
        return;
      }

      const mean = scores.reduce((a,b)=>a+b,0) / scores.length;
      const med = median(scores);
      const worst = Math.max(...scores);
      const worstRow = computed.find(r => r.index.score === worst);

      $("kpiMean").textContent = fmt(mean, 0);
      $("kpiMedian").textContent = fmt(med, 0);
      $("kpiWorst").textContent = fmt(worst, 0);
      $("kpiWorstName").textContent = worstRow ? worstRow.loc.name : "";

      const meanCat = categoryForIndex(mean);
      const medCat = categoryForIndex(med);
      $("kpiMeanCat").textContent = meanCat.name;
      $("kpiMedianCat").textContent = medCat.name;

      const rain14Vals = computed.map(r => r.index.metrics.pastRain14).filter(x => x != null && !isNaN(x));
      const rain14Mean = rain14Vals.length ? rain14Vals.reduce((a,b)=>a+b,0)/rain14Vals.length : null;
      $("kpiRain14").textContent = rain14Mean == null ? "-" : (fmt(rain14Mean, 1) + " mm");

      const rain7Vals = computed.map(r => r.index.metrics.forecastRain7).filter(x => x != null && !isNaN(x));
      const rain7Mean = rain7Vals.length ? rain7Vals.reduce((a,b)=>a+b,0)/rain7Vals.length : null;
      $("kpiRain7").textContent = rain7Mean == null ? "-" : (fmt(rain7Mean, 1) + " mm");

      const et07Vals = computed.map(r => r.index.metrics.et0_7).filter(x => x != null && !isNaN(x));
      const et07Mean = et07Vals.length ? et07Vals.reduce((a,b)=>a+b,0)/et07Vals.length : null;
      $("kpiET07").textContent = et07Mean == null ? "-" : (fmt(et07Mean, 1) + " mm");

      const vpdVals = computed.map(r => r.index.metrics.vpdMean).filter(x => x != null && !isNaN(x));
      const vpdMean7 = vpdVals.length ? vpdVals.reduce((a,b)=>a+b,0)/vpdVals.length : null;
      $("kpiVPD7").textContent = vpdMean7 == null ? "-" : (fmt(vpdMean7, 2) + " kPa");

      const rhVals = computed.map(r => r.index.metrics.rhMean7).filter(x => x != null && !isNaN(x));
      const rhMean7 = rhVals.length ? rhVals.reduce((a,b)=>a+b,0)/rhVals.length : null;
      $("kpiRH7").textContent = rhMean7 == null ? "-" : (fmt(rhMean7, 0) + "%");

    }

    function drawSpark(canvas, values){
      const c = canvas;
      const ctx = c.getContext("2d");
      const w = c.width = c.clientWidth * devicePixelRatio;
      const h = c.height = c.clientHeight * devicePixelRatio;
      ctx.clearRect(0,0,w,h);

      if (!values || values.length < 2) return;

      const finite = values.filter(v => v != null && isFinite(v));
      if (finite.length < 2) return;

      const min = Math.min(...finite);
      const max = Math.max(...finite);
      const span = (max - min) || 1;

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(56,189,248,0.95)";
      ctx.beginPath();

      const n = values.length;
      let moved = false;
      for (let i=0;i<n;i++){
        const v = values[i];
        if (v == null || !isFinite(v)) continue;
        const x = (i / (n-1)) * (w - 10*devicePixelRatio) + 5*devicePixelRatio;
        const y = h - ((v - min) / span) * (h - 10*devicePixelRatio) - 5*devicePixelRatio;
        if (!moved){
          ctx.moveTo(x,y);
          moved = true;
        } else {
          ctx.lineTo(x,y);
        }
      }
      ctx.stroke();

      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, h - 1);
      ctx.lineTo(w, h - 1);
      ctx.stroke();
    }

    
    // District trend chart cache and renderer
    const districtTrend = {
      key: null,
      start: null,
      end: null,
      times: [],
      mean: [],
      med: [],
      worst: [],
      worstSiteIdx: [],
      minScore: [],
      maxScore: [],
      spread: [],
      building: null,
      indicatorsKey: null,
      indicators: null,
      defaultMeta: ""
    };

    function cssVar(name){
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || null;
    }
    function addLocalDays(d, n){
      const x = new Date(d);
      x.setDate(x.getDate() + n);
      return x;
    }
    function localMidday(d){
      const x = new Date(d);
      x.setHours(12,0,0,0);
      return x;
    }
    function startOfLocalDay(d){
      const x = new Date(d);
      x.setHours(0,0,0,0);
      return x;
    }

    
    function startOfLocalHour(d){
      const x = new Date(d);
      x.setMinutes(0,0,0);
      return x;
    }
    function addLocalHours(d, n){
      const x = new Date(d);
      x.setHours(x.getHours() + n);
      return x;
    }
function getDistrictTrendWindow(){
      let pastDays = clamp(Number($("pastDays").value) || 30, 7, 120);

      // Snapshot mode should mirror Live behavior with a 30d minimum lookback.
      if (timeMode === "historic" && !historicUseRange){
        pastDays = Math.max(pastDays, 30);
      }

      const end = getAsOfDate();

      if (timeMode === "historic"){
        // Only use the playback range for district charts when Range Mode is actually active.
        if (historicUseRange && historicRangeStart instanceof Date && !isNaN(historicRangeStart.getTime()) &&
            historicRangeEnd instanceof Date && !isNaN(historicRangeEnd.getTime())){
          let rs = new Date(historicRangeStart.getTime());
          let re = new Date(historicRangeEnd.getTime());
          if (rs > re){ const tmp = rs; rs = re; re = tmp; }
          return { start: startOfLocalDay(rs), end: re };
        }
        return { start: addLocalDays(startOfLocalDay(end), -(pastDays-1)), end };
      }

      return { start: addLocalDays(startOfLocalDay(end), -(pastDays-1)), end };
    }

    function windowKey(win){
      const a = win.start.toISOString().slice(0,16);
      const b = win.end.toISOString().slice(0,16);
      const loaded = dataCache?.loadedAt ? new Date(dataCache.loadedAt).toISOString().slice(0,19) : "none";
      return `${timeMode}|${a}|${b}|daily|${loaded}|${locations.length}`;
    }

    function computeDistrictStatsAt(dateObj){
      const scores = [];
      let worst = -Infinity;
      let worstSiteIdx = null;
      let min = Infinity;

      for (let i=0;i<locations.length;i++){
        const wx = dataCache?.wxList ? dataCache.wxList[i] : null;
        const flood = dataCache?.floodList ? dataCache.floodList[i] : null;
        if (!wx) continue;

        const r = computeLocationIndex(wx, flood, dateObj);
        const s = r?.score;
        if (s == null || !isFinite(s)) continue;

        scores.push(s);
        if (s > worst){ worst = s; worstSiteIdx = i; }
        if (s < min){ min = s; }
      }
      if (!scores.length) return null;

      const mean = scores.reduce((a,b)=>a+b,0)/scores.length;
      const med = median(scores);
      const max = worst;
      const spread = (isFinite(mean) && isFinite(max)) ? (max - mean) : null;

      return { mean, med, worst: max, worstSiteIdx, min, max, spread, n: scores.length };
    }

    async function ensureDistrictTrendComputed(force=false){
      const canvas = document.getElementById("districtTrendChart");
      const meta = document.getElementById("districtTrendMeta");
      if (!canvas || !meta) return;

      if (!dataCache?.wxList){ meta.textContent = "No data loaded"; return; }

      const win = getDistrictTrendWindow();

      // Clamp to loaded data range when available
      const rangeMin = dataCache.rangeMin ? new Date(dataCache.rangeMin) : null;
      const rangeMax = dataCache.rangeMax ? new Date(dataCache.rangeMax) : null;

      let start = win.start;
      let end = win.end;
      if (rangeMin && start < rangeMin) start = rangeMin;
      if (rangeMax && end > rangeMax) end = rangeMax;

      const key = windowKey({start, end});
      if (!force && districtTrend.key === key && districtTrend.times?.length > 1) return;

      if (districtTrend.building) return districtTrend.building;

      meta.textContent = "Building district trend from loaded data…";

      const buildPromise = (async ()=>{
        const times = [];
        const meanArr = [];
        const medArr = [];
        const worstArr = [];
        const worstSiteIdxArr = [];
        const minArr = [];
        const maxArr = [];
        const spreadArr = [];

        let d = localMidday(start);
        const endDay = localMidday(end);

        let safety = 0;
        while (d <= endDay && safety < 400){
          const stats = computeDistrictStatsAt(d);
          times.push(new Date(d));
          meanArr.push(stats ? stats.mean : null);
          medArr.push(stats ? stats.med : null);
          worstArr.push(stats ? stats.worst : null);
          worstSiteIdxArr.push(stats ? stats.worstSiteIdx : null);
          minArr.push(stats ? stats.min : null);
          maxArr.push(stats ? stats.max : null);
          spreadArr.push(stats ? stats.spread : null);

          d = addLocalDays(d, 1);
          safety++;
          if (safety % 5 === 0) await new Promise(r=>setTimeout(r,0));
        }

        districtTrend.key = key;
        districtTrend.start = start;
        districtTrend.end = end;
        districtTrend.times = times;
        districtTrend.mean = meanArr;
        districtTrend.med = medArr;
        districtTrend.worst = worstArr;
        districtTrend.worstSiteIdx = worstSiteIdxArr;
        districtTrend.minScore = minArr;
        districtTrend.maxScore = maxArr;
        districtTrend.spread = spreadArr;
        districtTrend.indicatorsKey = null;
        districtTrend.indicators = null;

        const latestMean = [...meanArr].reverse().find(v => v != null && isFinite(v));
        const t0 = times[0] || start;
    const t1 = times[times.length-1] || end;
    const unitStep = (step === "hour") ? "hours" : "days";
    const rangeTxt = `${formatWhenNZ(t0)} to ${formatWhenNZ(t1)} • ${times.length} ${unitStep}`;
        meta.textContent = (latestMean != null) ? `${rangeTxt} • Latest mean ${latestMean.toFixed(0)}` : rangeTxt;

        // Add a quick indicator summary for the most recent day (tunable in config)
        const cfg = (typeof DISTRICT_TREND_INDICATORS !== "undefined") ? DISTRICT_TREND_INDICATORS : null;
        if (cfg && meanArr.length){
          const streakFromEnd = (arr, pred)=>{
            let n = 0;
            for (let i=arr.length-1;i>=0;i--){
              const v = arr[i];
              if (pred(v, i)) n++;
              else break;
            }
            return n;
          };

          const bits = [];
          const s80 = streakFromEnd(meanArr, v=>v!=null && isFinite(v) && v>=cfg.district.mean80_5.threshold);
          const s84 = streakFromEnd(meanArr, v=>v!=null && isFinite(v) && v>=cfg.district.mean84_5.threshold);
          const s94 = streakFromEnd(worstArr, v=>v!=null && isFinite(v) && v>=cfg.location.threshold);

          if (s84 >= cfg.district.mean84_5.days) bits.push(`District drought stress ${s84}d`);
          else if (s80 >= cfg.district.mean80_7.days) bits.push(`District drought warning ${s80}d`);
          else if (s80 >= cfg.district.mean80_5.days) bits.push(`District warning ${s80}d`);

          if (s94 >= cfg.location.acuteDays) bits.push(`Acute location stress ${s94}d`);
          else {
            const wLast = worstArr[worstArr.length - 1];
            if (wLast != null && isFinite(wLast) && wLast >= cfg.location.threshold) bits.push("Location stress today");
          }

          if (bits.length){
            meta.textContent += ` • ${bits.join(" • ")}`;
          }
        }

        
        districtTrend.defaultMeta = meta.textContent;
renderDistrictTrendChart();
      })().finally(()=>{ districtTrend.building = null; });

      districtTrend.building = buildPromise;
      return buildPromise;
    }

    // ---- District Trend Chart (Interactive Hover) ----
    const districtTrendHover = { idx: null, x: 0, y: 0, active: false };

    function trendLayout(w, h){
      // Leave room for y-axis labels
      const padL = 42, padR = 10, padT = 10, padB = 18;
      const x0 = padL, x1 = w - padR;
      const y0 = padT, y1 = h - padB;
      const minY = 0, maxY = 100;

      const n = districtTrend.times ? districtTrend.times.length : 0;
      const xAt = (i)=> x0 + (x1 - x0) * (n <= 1 ? 0 : i / (n - 1));
      const yAt = (v)=> y1 - ((clamp(v, minY, maxY) - minY) / (maxY - minY)) * (y1 - y0);

      return { padL, padR, padT, padB, x0, x1, y0, y1, minY, maxY, n, xAt, yAt };
    }

    function drawSeries(ctx, layout, values, color, lineWidth=2){
      const finite = (values || []).filter(v => v != null && isFinite(v));
      if (finite.length < 2) return;

      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      const n = values.length;
      let started = false;

      ctx.beginPath();
      for (let i=0;i<n;i++){
        const v = values[i];
        if (v == null || !isFinite(v)){
          started = false;
          continue;
        }
        const x = layout.xAt(i);
        const y = layout.yAt(v);
        if (!started){
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    }

    
    // ---- District Trend Drought Indicators (Tunable Config) ----
    // These are used by the district trend chart to add shaded spans, guide lines, and markers.
    // Edit thresholds/days here to tune alerting behaviour.
    const DISTRICT_TREND_INDICATORS = {
      district: {
        // 80+ for 5 days: early signal
        mean80_5: { threshold: 80, days: 5, label: "[Drought Watch] Mean 80+ (5d)", colorVar: "--watch", alpha: 0.08 },

        // 80+ for 7 days: district drought warning
        mean80_7: { threshold: 80, days: 7, label: "[Drought Warning] Mean 80+ (7d)", colorVar: "--warn", alpha: 0.12 },

        // 84+ for 5 days: district drought stress
        mean84_5: { threshold: 84, days: 5, label: "[Drought Danger] Mean 84+ (5d)", colorVar: "--severe", alpha: 0.14 }
      },

      location: {
        // 94+ at any location (worst series)
        threshold: 94,
        acuteDays: 3,
        labelDay: "Location Stress 94+",
        labelAcute: "[Location danger] (94+ for 3d)",
        colorVar: "--extreme",
        alpha: 0.12
      },

      // When locations are all close together, stress is more likely district-wide rather than patchy
      spread: {
        maxPoints: 4,
        minMean: 80,
        days: 3,
        label: "District Wide Stress (Low Worst-Mean)",
        colorVar: "--watch",
        alpha: 0.08
      },

      // Horizontal guide lines in the chart
      guides: [
        { value: 80, label: "80", colorVar: "--warn", alpha: 0.55 },
        { value: 84, label: "84", colorVar: "--severe", alpha: 0.55 },
        { value: 94, label: "94", colorVar: "--extreme", alpha: 0.55 }
      ]
    };

    function hexToRgba(hex, a){
      if (!hex) return `rgba(255,255,255,${a})`;
      const c = String(hex).trim();
      if (c.startsWith("#")){
        let h = c.slice(1);
        if (h.length === 3) h = h.split("").map(ch=>ch+ch).join("");
        if (h.length !== 6) return `rgba(255,255,255,${a})`;
        const r = parseInt(h.slice(0,2),16);
        const g = parseInt(h.slice(2,4),16);
        const b = parseInt(h.slice(4,6),16);
        return `rgba(${r},${g},${b},${a})`;
      }
      if (c.startsWith("rgb(")){
        return c.replace("rgb(", "rgba(").replace(")", `,${a})`);
      }
      if (c.startsWith("rgba(")) return c;
      return c;
    }

    function streakSpans(values, predicate, minLen){
      const spans = [];
      let s = null;

      for (let i=0;i<values.length;i++){
        const ok = Boolean(predicate(values[i], i));
        if (ok){
          if (s == null) s = i;
        } else if (s != null){
          const e = i - 1;
          const len = e - s + 1;
          if (len >= minLen) spans.push({ s, e, len });
          s = null;
        }
      }

      if (s != null){
        const e = values.length - 1;
        const len = e - s + 1;
        if (len >= minLen) spans.push({ s, e, len });
      }

      return spans;
    }

    function computeDistrictTrendIndicators(){
      const key = `${districtTrend.key || "none"}|${districtTrend.times?.length || 0}|indicators_v1`;
      if (districtTrend.indicatorsKey === key && districtTrend.indicators) return districtTrend.indicators;

      const mean = districtTrend.mean || [];
      const worst = districtTrend.worst || [];
      const spread = districtTrend.spread || [];

      const cfg = DISTRICT_TREND_INDICATORS;

      const spans = [];

      // District mean spans
      spans.push(
        ...streakSpans(
          mean,
          v => v!=null && isFinite(v) && v>=cfg.district.mean80_5.threshold,
          cfg.district.mean80_5.days
        ).map(x=>({ ...x, type: "mean80_5", label: cfg.district.mean80_5.label, colorVar: cfg.district.mean80_5.colorVar, alpha: cfg.district.mean80_5.alpha }))
      );

      spans.push(
        ...streakSpans(
          mean,
          v => v!=null && isFinite(v) && v>=cfg.district.mean80_7.threshold,
          cfg.district.mean80_7.days
        ).map(x=>({ ...x, type: "mean80_7", label: cfg.district.mean80_7.label, colorVar: cfg.district.mean80_7.colorVar, alpha: cfg.district.mean80_7.alpha }))
      );

      spans.push(
        ...streakSpans(
          mean,
          v => v!=null && isFinite(v) && v>=cfg.district.mean84_5.threshold,
          cfg.district.mean84_5.days
        ).map(x=>({ ...x, type: "mean84_5", label: cfg.district.mean84_5.label, colorVar: cfg.district.mean84_5.colorVar, alpha: cfg.district.mean84_5.alpha }))
      );

      // Tight spread span: high mean and low spread over multiple days suggests district-wide stress
      spans.push(
        ...streakSpans(
          mean,
          (v,i)=>{
            const sp = spread[i];
            return v!=null && isFinite(v) && v>=cfg.spread.minMean && sp!=null && isFinite(sp) && sp<=cfg.spread.maxPoints;
          },
          cfg.spread.days
        ).map(x=>({ ...x, type: "tight_spread", label: cfg.spread.label, colorVar: cfg.spread.colorVar, alpha: cfg.spread.alpha }))
      );

      // Acute location stress span: worst location 94+ for N days
      spans.push(
        ...streakSpans(
          worst,
          v => v!=null && isFinite(v) && v>=cfg.location.threshold,
          cfg.location.acuteDays
        ).map(x=>({ ...x, type: "acute_loc", label: cfg.location.labelAcute, colorVar: cfg.location.colorVar, alpha: cfg.location.alpha }))
      );

      // Single-day markers when the worst location is 94+
      const markers = [];
      for (let i=0;i<worst.length;i++){
        const v = worst[i];
        if (v!=null && isFinite(v) && v>=cfg.location.threshold){
          markers.push({ idx: i, type: "loc94", label: cfg.location.labelDay });
        }
      }

      const out = { spans, markers };
      districtTrend.indicatorsKey = key;
      districtTrend.indicators = out;
      return out;
    }

    function spanLabelsForIdx(i, indicators){
      const labels = [];
      for (const sp of (indicators?.spans || [])){
        if (i >= sp.s && i <= sp.e) labels.push(sp.label);
      }
      return labels;
    }

    function drawSpanFill(ctx, layout, span, color){
      const x0 = layout.xAt(span.s);
      const x1 = layout.xAt(span.e);
      ctx.fillStyle = color;
      ctx.fillRect(x0, layout.y0, (x1 - x0) + 1, (layout.y1 - layout.y0));
    }

    function drawThresholdLine(ctx, layout, v, label, color){
      const y = layout.yAt(v);

      ctx.save();
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(layout.x0, y);
      ctx.lineTo(layout.x1, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = color;
      ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      ctx.fillText(label, layout.x0 + 4, y - 2);
      ctx.restore();
    }

    function drawTopTriangle(ctx, x, y, size, color){
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - size, y + size);
      ctx.lineTo(x + size, y + size);
      ctx.closePath();
      ctx.fill();
    }

function ensureDistrictTrendHoverHooks(){
      const canvas = document.getElementById("districtTrendChart");
      if (!canvas || canvas._hoverHooked) return;
      canvas._hoverHooked = true;

      const tip = document.getElementById("districtTrendTooltip");

      const onMove = (ev)=>{
        if (!districtTrend.times || districtTrend.times.length < 2){
          districtTrendHover.idx = null;
          if (tip) tip.style.display = "none";
          return;
        }

        const r = canvas.getBoundingClientRect();
        const x = ev.clientX - r.left;
        const y = ev.clientY - r.top;
    const layout = trendLayout(r.width, r.height);

        // Only show hover info inside the plot area
        if (x < layout.x0 || x > layout.x1 || y < layout.y0 || y > layout.y1){
          districtTrendHover.idx = null;
          if (tip) tip.style.display = "none";
          renderDistrictTrendChart();
          return;
        }

        const t = (x - layout.x0) / (layout.x1 - layout.x0);
        const idx = clamp(Math.round(t * (layout.n - 1)), 0, layout.n - 1);

        districtTrendHover.idx = idx;
        districtTrendHover.x = x;
        districtTrendHover.y = y;
        districtTrendHover.active = true;

        renderDistrictTrendChart();
      };

      const onLeave = ()=>{
        districtTrendHover.idx = null;
        districtTrendHover.active = false;

        const meta = document.getElementById("districtTrendMeta");
        if (meta && districtTrend.defaultMeta) meta.textContent = districtTrend.defaultMeta;

        if (tip) tip.style.display = "none";
        renderDistrictTrendChart();
      };

      canvas.addEventListener("mousemove", onMove);
      canvas.addEventListener("mouseleave", onLeave);

      // Touch support (mobile/tablet)
      canvas.addEventListener("touchstart", (e)=>{
        if (e.touches && e.touches.length) onMove(e.touches[0]);
      }, {passive:true});
      canvas.addEventListener("touchmove", (e)=>{
        if (e.touches && e.touches.length) onMove(e.touches[0]);
      }, {passive:true});
      canvas.addEventListener("touchend", onLeave);
    }

    function renderDistrictTrendChart(){
      const canvas = document.getElementById("districtTrendChart");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      ensureDistrictTrendHoverHooks();
      const tip = document.getElementById("districtTrendTooltip");

      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const dpr = window.devicePixelRatio || 1;

      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      ctx.clearRect(0, 0, w, h);

      const layout = trendLayout(w, h);

      // Gridlines (0..100)
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      for (let p=0; p<=5; p++){
        const v = layout.minY + (layout.maxY - layout.minY) * (p / 5);
        const y = layout.yAt(v);
        ctx.beginPath();
        ctx.moveTo(layout.x0, y);
        ctx.lineTo(layout.x1, y);
        ctx.stroke();
      }

      // Y-axis labels
      ctx.fillStyle = "rgba(255,255,255,0.60)";
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      for (let v=layout.minY; v<=layout.maxY; v+=20){
        const y = layout.yAt(v);
        ctx.beginPath();
        ctx.moveTo(layout.x0 - 4, y);
        ctx.lineTo(layout.x0, y);
        ctx.stroke();
        ctx.fillText(String(v), layout.x0 - 6, y);
      }

      // Left axis line
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(layout.x0, layout.y0);
      ctx.lineTo(layout.x0, layout.y1);
      ctx.stroke();

      if (!districtTrend.times || districtTrend.times.length < 2){
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText("District trend will appear once data is loaded", 10, 20);
        if (tip) tip.style.display = "none";
        return;
      }


      // Indicator overlays (background spans and guide lines)
      const indicators = computeDistrictTrendIndicators();

      if (indicators && indicators.spans && indicators.spans.length){
        const order = { mean80_5: 1, tight_spread: 2, mean80_7: 3, mean84_5: 4, acute_loc: 5 };
        const spansSorted = [...indicators.spans].sort((a,b)=> (order[a.type]||0) - (order[b.type]||0));

        for (const sp of spansSorted){
          const base = cssVar(sp.colorVar) || "#ffffff";
          const fill = hexToRgba(base, sp.alpha);
          drawSpanFill(ctx, layout, sp, fill);
        }
      }

      if (DISTRICT_TREND_INDICATORS && DISTRICT_TREND_INDICATORS.guides){
        for (const g of DISTRICT_TREND_INDICATORS.guides){
          const base = cssVar(g.colorVar) || "#ffffff";
          const col = hexToRgba(base, g.alpha);
          drawThresholdLine(ctx, layout, g.value, g.label, col);
        }
      }

      const cMean = cssVar("--ok") || "#38bdf8";
      const cMed = cssVar("--warn") || "#fbbf24";
      const cWorst = cssVar("--extreme") || "#f97316";

      drawSeries(ctx, layout, districtTrend.worst, cWorst, 2);
      drawSeries(ctx, layout, districtTrend.med, cMed, 2);
      drawSeries(ctx, layout, districtTrend.mean, cMean, 2.5);
      // Markers for worst-location 94+ days (triangles at top)
      if (indicators && indicators.markers && indicators.markers.length){
        const mkColor = cssVar(DISTRICT_TREND_INDICATORS.location.colorVar) || "#f97316";
        const yTop = layout.y0 + 2;
        for (const mk of indicators.markers){
          const x = layout.xAt(mk.idx);
          drawTopTriangle(ctx, x, yTop, 5, mkColor);
        }
      }

      // Label acute spans
      if (indicators && indicators.spans){
        const acute = indicators.spans.filter(s=>s.type === "acute_loc");
        if (acute.length){
          const lblColor = cssVar(DISTRICT_TREND_INDICATORS.location.colorVar) || "#f97316";
          ctx.fillStyle = hexToRgba(lblColor, 0.85);
          ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          for (const sp of acute){
            const x = layout.xAt(sp.s) + 4;
            ctx.fillText("Acute", x, layout.y0 + 12);
          }
        }
      }


      // Marker for current as-of day
      const asOf = getAsOfDate();
      const t0 = districtTrend.times[0]?.getTime();
      const t1 = districtTrend.times[districtTrend.times.length - 1]?.getTime();
      if (t0 && t1 && asOf){
        const tt = asOf.getTime();
        if (tt >= t0 && tt <= t1){
          const dayIdx = Math.round((tt - t0) / (24*3600*1000));
          const idx = clamp(dayIdx, 0, layout.n - 1);
          const x = layout.xAt(idx);

          ctx.strokeStyle = "rgba(255,255,255,0.35)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, layout.y0);
          ctx.lineTo(x, layout.y1);
          ctx.stroke();
        }
      }

      // Hover overlay
      const hoverIdx = (districtTrendHover && districtTrendHover.idx != null) ? districtTrendHover.idx : null;
      if (hoverIdx != null && hoverIdx >= 0 && hoverIdx < layout.n){
        const x = layout.xAt(hoverIdx);

        ctx.strokeStyle = "rgba(255,255,255,0.45)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, layout.y0);
        ctx.lineTo(x, layout.y1);
        ctx.stroke();

        const drawDot = (v, color)=>{
          if (v == null || !isFinite(v)) return null;
          const y = layout.yAt(v);
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, 3.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = 1;
          ctx.stroke();
          return y;
        };

        const vMean = districtTrend.mean?.[hoverIdx];
        const vMed = districtTrend.med?.[hoverIdx];
        const vWorst = districtTrend.worst?.[hoverIdx];

        const yMean = drawDot(vMean, cMean);
        const yMed = drawDot(vMed, cMed);
        const yWorst = drawDot(vWorst, cWorst);

        const dt = districtTrend.times[hoverIdx];
        const dtTxt = dt ? formatWhenNZ(dt) : `Day ${hoverIdx + 1}`;

        const meanTxt = (vMean != null && isFinite(vMean)) ? vMean.toFixed(0) : "-";
        const medTxt = (vMed != null && isFinite(vMed)) ? vMed.toFixed(0) : "-";
        const worstTxt = (vWorst != null && isFinite(vWorst)) ? vWorst.toFixed(0) : "-";

        const worstSiteIdx = districtTrend.worstSiteIdx ? districtTrend.worstSiteIdx[hoverIdx] : null;
        const worstSiteName = (worstSiteIdx != null && locations[worstSiteIdx]) ? locations[worstSiteIdx].name : null;
        const spreadVal = districtTrend.spread ? districtTrend.spread[hoverIdx] : null;
        const spreadTxt = (spreadVal != null && isFinite(spreadVal)) ? spreadVal.toFixed(1) : "-";
        const indLabels = spanLabelsForIdx(hoverIdx, indicators);
        const indicatorTxt = indLabels.length ? indLabels.join(" | ") : "";
        const worstSiteHtml = worstSiteName ? `<span><span style="opacity:0.75;">Worst Site</span> <span class="mono" style="font-weight:700;">${escapeHtml(worstSiteName)}</span></span>` : "";
        const indicatorHtml = indicatorTxt ? `<span><span style="opacity:0.75;">Indicators</span> ${escapeHtml(indicatorTxt)}</span>` : "";

        // Also update the text line under the chart while hovering
        const meta = document.getElementById("districtTrendMeta");
        if (meta){
          meta.textContent = `${dtTxt} • Mean ${meanTxt} • Median ${medTxt} • Worst ${worstTxt}` + (spreadTxt !== "-" ? ` • Worst-Mean ${spreadTxt}` : "") + (worstSiteName ? ` • Worst Site ${worstSiteName}` : "") + (indicatorTxt ? ` • ${indicatorTxt}` : "");
        }

        if (tip){
          tip.innerHTML = `
            <div class="mono" style="font-weight:700; margin-bottom:4px;">${escapeHtml(dtTxt)}</div>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <span><span style="opacity:0.75;">Mean</span> <span class="mono" style="font-weight:700;">${meanTxt}</span></span>
              <span><span style="opacity:0.75;">Median</span> <span class="mono" style="font-weight:700;">${medTxt}</span></span>
              <span><span style="opacity:0.75;">Worst</span> <span class="mono" style="font-weight:700;">${worstTxt}</span></span>
            </div>
            <div style="margin-top:6px; display:flex; flex-direction:column; gap:2px;">
              ${worstSiteHtml}
              <span><span style="opacity:0.75;">Worst-Mean</span> <span class="mono" style="font-weight:700;">${spreadTxt}</span></span>
              ${indicatorHtml}
            </div>
          `;
          tip.style.display = "block";

          // Position near the mean dot if possible, otherwise use the first available series
          let yRef = yMean;
          if (yRef == null) yRef = yMed;
          if (yRef == null) yRef = yWorst;
          if (yRef == null) yRef = (layout.y0 + layout.y1) / 2;

          // Force layout so we can read size
          const tipRect = tip.getBoundingClientRect();

          let left = x + 12;
          let top = yRef - tipRect.height / 2;

          // Clamp inside the chart area
          const maxLeft = w - tipRect.width - 6;
          left = clamp(left, 6, maxLeft);

          const maxTop = h - tipRect.height - 6;
          top = clamp(top, 6, maxTop);

          tip.style.left = `${left}px`;
          tip.style.top = `${top}px`;
        }
      } else {
        // Restore default meta if not hovering
        const meta = document.getElementById("districtTrendMeta");
        if (meta && districtTrend.defaultMeta) meta.textContent = districtTrend.defaultMeta;
        if (tip) tip.style.display = "none";
      }
    }
// ---- District Weather and Environment Trend (Interactive Hover) ----
const STORAGE_KEY_ENV_METRIC = "fndi_district_env_metric_v1";

const districtEnvTrend = {
  key: null,
  metric: "rain_mm",
  start: null,
  end: null,
  times: [],
  values: [],
  building: null,
  defaultMeta: ""
};

const districtEnvHover = { idx: null, x: 0, y: 0, active: false };

const ENV_METRICS = {
  rain_mm:   { label: "Rain (Daily)", unit: "mm",     digits: 1 },
  rain14_mm: { label: "Rain (14 Day Mean)", unit: "mm/day", digits: 2 },
  et0_mm:    { label: "ET0 (Daily)", unit: "mm",      digits: 1 },
  et07_mm:   { label: "ET0 (7 Day Mean)", unit: "mm/day", digits: 2 },
  temp_c:    { label: "Air Temperature (Daily Mean)", unit: "°C", digits: 1 },
  rh_pct:    { label: "Relative Humidity (Daily Mean)", unit: "%", digits: 0 },
  vpd_kpa:   { label: "VPD (Daily Mean)", unit: "kPa", digits: 2 },
  soil_9_27: { label: "Soil Moisture 9-27 cm (Daily Mean)", unit: "m³/m³", digits: 3 },
  soil_27_81:{ label: "Soil Moisture 27-81 cm (Daily Mean)", unit: "m³/m³", digits: 3 },
  soil_0_1: { label: "Soil Moisture 0-1 cm (Daily Mean)", unit: "m³/m³", digits: 3 },
  soil_1_3: { label: "Soil Moisture 1-3 cm (Daily Mean)", unit: "m³/m³", digits: 3 },
  soil_3_9: { label: "Soil Moisture 3-9 cm (Daily Mean)", unit: "m³/m³", digits: 3 },
  wind_dir_deg: { label: "Wind Direction 10m (Daily Mean)", unit: "°", digits: 0 },
  plume_idx: { label: "Tropical Plume Signal (Local Proxy)", unit: "idx", digits: 0 },
  wind_ms:   { label: "Wind Speed 10m (Daily Mean)", unit: "m/s", digits: 1 },
  msl_hpa:   { label: "Mean Sea Level Pressure (Daily Mean)", unit: "hPa", digits: 0 },
};

function clamp01(x){ return clamp(x, 0, 1); }

// ---- Tropical Plume Signal (Local Proxy) ----
// This is a context layer only. It does not modify the drought index.
// Heuristic components (0–100): NE flow persistence + moisture support + pressure fall + forecast rain.
function computeTropicalPlumeSignal(wx, asOf){
  if (!wx) return { score: null, label: "-", reason: "-" };

  const hourly = wx.hourly || {};
  const daily = wx.daily || {};

  const neFrac = computeNEFractionWindow(hourly.time, hourly.wind_direction_10m, hourly.wind_speed_10m, asOf, 3);
  const rhMean = meanHourlyWindow(hourly.time, hourly.relative_humidity_2m, asOf, 3);
  const vpdMean = meanHourlyWindow(hourly.time, hourly.vapour_pressure_deficit, asOf, 3);

  // Pressure tendency: mean last 24h minus mean previous 24h (negative = falling)
  const pNow24 = meanHourlyWindow(hourly.time, hourly.pressure_msl, asOf, 1);
  const prev24End = new Date(asOf.getTime() - 24 * 3600 * 1000);
  const pPrev24 = meanHourlyWindow(hourly.time, hourly.pressure_msl, prev24End, 1);
  const dp = (pNow24 != null && pPrev24 != null) ? (pNow24 - pPrev24) : null;

  const rain3 = sumDailyFuture(daily.time, daily.precipitation_sum, asOf, 3);

  const windScore  = (neFrac == null) ? 0 : (40 * clamp01((neFrac - 0.25) / 0.50));
  const moistBase  = (rhMean == null) ? 0 : (25 * clamp01((rhMean - 70) / 20));
  const vpdAdj     = (vpdMean == null) ? 0 : (10 * clamp01((1.2 - vpdMean) / 1.2));
  const moistScore = moistBase + vpdAdj;

  const pressScore = (dp == null) ? 0 : (15 * clamp01(((-dp) - 0.5) / 3.0));
  const rainScore  = (rain3 == null) ? 0 : (20 * clamp01((rain3 - 10) / 40));

  let score = windScore + moistScore + pressScore + rainScore;
  score = Math.round(clamp(score, 0, 100));

  const label = (score >= 75) ? "High" : (score >= 55) ? "Elevated" : (score >= 35) ? "Possible" : "Low";
  const reason = buildPlumeReason(neFrac, rhMean, vpdMean, dp, rain3);

  return { score, label, neFrac, rhMean, vpdMean, dp, rain3, reason };
}

function computeNEFractionWindow(hourlyTime, windDir, windSpd, endDate, daysBack){
  if (!hourlyTime || !windDir || !windSpd || !(endDate instanceof Date)) return null;

  const endMs = endDate.getTime();
  const startMs = endMs - daysBack * 24 * 3600 * 1000;

  let n = 0;
  let k = 0;

  for (let i=0;i<hourlyTime.length;i++){
    const dt = parseLocalDateTime(hourlyTime[i]);
    if (!dt) continue;
    const ms = dt.getTime();
    if (ms < startMs) continue;
    if (ms > endMs) continue;

    const dir = windDir[i];
    const spd = windSpd[i];
    if (dir == null || spd == null || !isFinite(dir) || !isFinite(spd)) continue;

    n++;
    if (spd >= 3 && dir >= 20 && dir <= 120) k++;
  }
  return n ? (k / n) : null;
}

function buildPlumeReason(neFrac, rhMean, vpdMean, dp, rain3){
  const bits = [];
  if (neFrac != null) bits.push(`NE flow ${Math.round(neFrac * 100)}%`);
  if (rhMean != null) bits.push(`RH ${Math.round(rhMean)}%`);
  if (vpdMean != null) bits.push(`VPD ${Number(vpdMean).toFixed(2)} kPa`);
  if (dp != null) bits.push(`ΔP ${Number(dp).toFixed(1)} hPa/24h`);
  if (rain3 != null) bits.push(`Rain+3d ${Number(rain3).toFixed(1)} mm`);
  return bits.join(" • ");
}

function computePlumeDailySeriesForLocation(wx, endDate, daysBack=14){
  const out = { dates: [], values: [] };
  if (!wx || !(endDate instanceof Date)) return out;

  const endDay = startOfLocalDay(endDate);
  const startDay = addLocalDays(endDay, -(daysBack - 1));

  let d = new Date(startDay);
  let safety = 0;
  while (d <= endDay && safety < 400){
    const eod = new Date(addLocalDays(startOfLocalDay(d), 1).getTime() - 60 * 1000);
    const sig = computeTropicalPlumeSignal(wx, eod);
    out.dates.push(ymdLocal(d));
    out.values.push(sig && sig.score != null ? sig.score : null);

    d = addLocalDays(d, 1);
    safety++;
  }
  return out;
}

function computeDistrictPlumeDailySeries(endDate, daysBack=14){
  const out = { dates: [], values: [] };
  if (!dataCache?.wxList || !dataCache.wxList.length || !(endDate instanceof Date)) return out;

  const endDay = startOfLocalDay(endDate);
  const startDay = addLocalDays(endDay, -(daysBack - 1));

  let d = new Date(startDay);
  let safety = 0;
  while (d <= endDay && safety < 400){
    const eod = new Date(addLocalDays(startOfLocalDay(d), 1).getTime() - 60 * 1000);

    let sum = 0, n = 0;
    for (let i=0;i<dataCache.wxList.length;i++){
      const wx = dataCache.wxList[i];
      const sig = computeTropicalPlumeSignal(wx, eod);
      const v = sig?.score;
      if (v == null || !isFinite(v)) continue;
      sum += v; n++;
    }

    out.dates.push(ymdLocal(d));
    out.values.push(n ? (sum / n) : null);

    d = addLocalDays(d, 1);
    safety++;
  }
  return out;
}

function updateDistrictClimatePanel(asOf){
  const plumeTag = document.getElementById("districtPlumeTag");
  const reasonEl = document.getElementById("districtPlumeReason");
  if (!plumeTag || !(asOf instanceof Date)) return;

  if (!dataCache?.wxList || !dataCache.wxList.length){
    plumeTag.innerHTML = `<span class="dot" style="background:var(--muted)"></span>Plume: <span class="mono">-</span>`;
    if (reasonEl) reasonEl.textContent = "-";
    return;
  }

  let sumScore = 0, nScore = 0;
  let sumNe = 0, nNe = 0;
  let sumRh = 0, nRh = 0;
  let sumVpd = 0, nVpd = 0;
  let sumDp = 0, nDp = 0;
  let sumRain3 = 0, nRain3 = 0;

  for (let i=0;i<dataCache.wxList.length;i++){
    const sig = computeTropicalPlumeSignal(dataCache.wxList[i], asOf);
    if (!sig) continue;

    if (sig.score != null && isFinite(sig.score)){ sumScore += sig.score; nScore++; }
    if (sig.neFrac != null && isFinite(sig.neFrac)){ sumNe += sig.neFrac; nNe++; }
    if (sig.rhMean != null && isFinite(sig.rhMean)){ sumRh += sig.rhMean; nRh++; }
    if (sig.vpdMean != null && isFinite(sig.vpdMean)){ sumVpd += sig.vpdMean; nVpd++; }
    if (sig.dp != null && isFinite(sig.dp)){ sumDp += sig.dp; nDp++; }
    if (sig.rain3 != null && isFinite(sig.rain3)){ sumRain3 += sig.rain3; nRain3++; }
  }

  const meanScore = nScore ? (sumScore / nScore) : null;
  const label = (meanScore == null) ? "-" :
    (meanScore >= 75) ? "High" :
    (meanScore >= 55) ? "Elevated" :
    (meanScore >= 35) ? "Possible" : "Low";

  const dot = (meanScore == null) ? "var(--muted)" :
    (meanScore >= 75) ? "var(--severe)" :
    (meanScore >= 55) ? "var(--warn)" :
    (meanScore >= 35) ? "var(--watch)" : "var(--ok)";

  plumeTag.innerHTML = (meanScore == null)
    ? `<span class="dot" style="background:var(--muted)"></span>Plume: <span class="mono">-</span>`
    : `<span class="dot" style="background:${dot}"></span>Plume: <span class="mono">${fmt(meanScore,0)}</span> <span class="mono" style="opacity:0.75;">${label}</span>`;

  if (reasonEl){
    const r = buildPlumeReason(
      nNe ? (sumNe / nNe) : null,
      nRh ? (sumRh / nRh) : null,
      nVpd ? (sumVpd / nVpd) : null,
      nDp ? (sumDp / nDp) : null,
      nRain3 ? (sumRain3 / nRain3) : null
    );
    reasonEl.textContent = r || "-";
  }

  const explainEl = document.getElementById("districtExplainPlume");
  if (explainEl){
    const sig = {
      score: meanScore,
      label,
      neFrac: nNe ? (sumNe / nNe) : null,
      rhMean: nRh ? (sumRh / nRh) : null,
      vpdMean: nVpd ? (sumVpd / nVpd) : null,
      dp: nDp ? (sumDp / nDp) : null,
      rain3: nRain3 ? (sumRain3 / nRain3) : null
    };
    explainEl.textContent = buildPlumeExplainText(sig);
  }

}

function getSelectedEnvMetric(){
  const sel = document.getElementById("districtEnvMetric");
  const saved = localStorage.getItem(STORAGE_KEY_ENV_METRIC);
  const fallback = saved || "rain_mm";

  if (sel){
    if (saved && sel.value !== saved) sel.value = saved;
    return sel.value || fallback;
  }
  return fallback;
}

// Interactive mini charts for Recent Trend (hover + y-axis)
const miniTrendCharts = new Map();

function niceTicks(min, max, ticks=4){
  if (!isFinite(min) || !isFinite(max)) return [];
  if (min === max){
    const v = min;
    return [v-1, v, v+1];
  }
  const span = max - min;
  const raw = span / Math.max(1, ticks-1);
  const mag = Math.pow(10, Math.floor(Math.log10(raw)));
  const norm = raw / mag;
  let step = mag;
  if (norm >= 5) step = 5*mag;
  else if (norm >= 2) step = 2*mag;
  else step = 1*mag;

  const niceMin = Math.floor(min/step)*step;
  const niceMax = Math.ceil(max/step)*step;
  const out = [];
  for (let v=niceMin; v<=niceMax+step*0.5; v+=step){
    out.push(v);
    if (out.length > 12) break;
  }
  return out;
}

function miniDefaultFmt(v){
  if (!isFinite(v)) return "-";
  const av = Math.abs(v);
  if (av >= 100) return fmt(v, 0);
  if (av >= 10) return fmt(v, 1);
  if (av >= 1) return fmt(v, 2);
  return fmt(v, 3);
}

function ensureMiniTrend(canvasId, tooltipId, opts={}){
  const c = document.getElementById(canvasId);
  const t = document.getElementById(tooltipId);
  if (!c) return null;

  let st = miniTrendCharts.get(canvasId);

  // If the detail panel is re-rendered, the canvas nodes are replaced. We must rebind the cached chart state
  // to the new DOM elements, otherwise we keep drawing into a detached canvas and the new one stays blank.
  const canvasChanged = !!(st && st.canvas && st.canvas !== c);
  const canvasDetached = !!(st && st.canvas && !st.canvas.isConnected);

  if (!st){
    st = {
      canvas: c,
      tooltip: t,
      times: [],
      values: [],
      hover: {active:false, idx:null, x:0, y:0},
      opts: opts || {}
    };
    miniTrendCharts.set(canvasId, st);
  } else {
    if (canvasChanged || canvasDetached){
      // Disconnect any ResizeObserver bound to the old canvas
      if (st._ro && typeof st._ro.disconnect === "function"){
        try { st._ro.disconnect(); } catch (e){}
      }
      st._ro = null;

      // Point state at the newly created canvas element
      st.canvas = c;

      // Reset hover state so we do not carry stale pixel coordinates
      st.hover = {active:false, idx:null, x:0, y:0};
    }

    // Always refresh tooltip reference because the panel may recreate it too
    st.tooltip = t;
  }

  // Merge options
  st.opts = Object.assign({}, st.opts || {}, opts || {});

  // Bind interactions once per canvas element
  if (!c.__miniTrendBound){
    c.__miniTrendBound = true;

    c.addEventListener("mousemove", (ev) => {
      const r = c.getBoundingClientRect();
      st.hover.active = true;
      st.hover.x = (ev.clientX - r.left);
      st.hover.y = (ev.clientY - r.top);
      renderMiniTrendChart(st);
    });

    c.addEventListener("mouseleave", () => {
      st.hover.active = false;
      st.hover.idx = null;
      if (st.tooltip) st.tooltip.style.display = "none";
      renderMiniTrendChart(st);
    });
  }

  // Redraw on resize for the current canvas
  if (typeof ResizeObserver !== "undefined"){
    if (!st._ro){
      const ro = new ResizeObserver(() => renderMiniTrendChart(st));
      ro.observe(c);
      st._ro = ro;
    } else {
      // In case the observer exists but the canvas was swapped, observe again
      try { st._ro.observe(c); } catch (e){}
    }
  } else {
    // Fallback: window resize (only bind once per chart state)
    if (!st._winResizeBound){
      st._winResizeBound = true;
      window.addEventListener("resize", () => renderMiniTrendChart(st));
    }
  }

  return st;
}

function setMiniTrendSeries(canvasId, tooltipId, times, values, opts={}){
  const st = ensureMiniTrend(canvasId, tooltipId, opts);
  if (!st) return;
  st.times = Array.isArray(times) ? times.slice() : [];
  st.values = Array.isArray(values) ? values.slice() : [];
  // reset hover if out of range
  if (!st.values.length) {
    st.hover.active = false;
    st.hover.idx = null;
    if (st.tooltip) st.tooltip.style.display = "none";
  } else if (st.hover.idx != null && st.hover.idx >= st.values.length){
    st.hover.idx = null;
  }
  renderMiniTrendChart(st);
}

function renderMiniTrendChart(st){
  if (!st || !st.canvas) return;
  const c = st.canvas;
  const ctx = c.getContext("2d");
  const dpr = devicePixelRatio || 1;

  // Use layout rect sizing (more reliable when canvases are inside grids or newly revealed panels)
  const rect = c.getBoundingClientRect();
  const cssW = Math.max(0, Math.floor((rect && rect.width) ? rect.width : (c.clientWidth || 0)));
  const cssH = Math.max(0, Math.floor((rect && rect.height) ? rect.height : (c.clientHeight || 0)));

  // If the canvas is not yet laid out (0x0), defer drawing until it is visible/measurable.
  if (cssW < 10 || cssH < 10){
    if (!st._deferDraw){
      st._deferDraw = requestAnimationFrame(() => {
        st._deferDraw = null;
        renderMiniTrendChart(st);
      });
    }
    return;
  }

  const w = c.width = Math.max(1, Math.floor(cssW * dpr));
  const h = c.height = Math.max(1, Math.floor(cssH * dpr));
  ctx.clearRect(0,0,w,h);

  const times = st.times || [];
  const values = st.values || [];
  const finite = values.map(v => (v==null ? null : Number(v))).filter(v => v!=null && isFinite(v));
  const hasData = finite.length >= 2;

  const padL = Math.floor(38 * dpr);
  const padR = Math.floor(10 * dpr);
  const padT = Math.floor(10 * dpr);
  const padB = Math.floor(18 * dpr);

  const plotX = padL;
  const plotY = padT;
  const plotW = Math.max(1, w - padL - padR);
  const plotH = Math.max(1, h - padT - padB);

  // Background grid
  ctx.save();
  ctx.lineWidth = 1 * dpr;
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for (let i=0;i<=3;i++){
    const y = plotY + (plotH * i/3);
    ctx.beginPath();
    ctx.moveTo(plotX, y);
    ctx.lineTo(plotX + plotW, y);
    ctx.stroke();
  }
  ctx.restore();

  if (!hasData){
    // No data message
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = `${12*dpr}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("No data", plotX + plotW/2, plotY + plotH/2);
    ctx.restore();
    if (st.tooltip) st.tooltip.style.display = "none";
    return;
  }

  const min = Math.min(...finite);
  const max = Math.max(...finite);
  const span = (max - min) || 1;

  const ticks = niceTicks(min, max, 4);
  const tmin = ticks.length ? ticks[0] : min;
  const tmax = ticks.length ? ticks[ticks.length-1] : max;
  const tspan = (tmax - tmin) || span;

  function yOf(v){
    const vv = (v - tmin) / tspan;
    return plotY + (1 - vv) * plotH;
  }
  function xOf(i,n){
    return plotX + (plotW * (n<=1 ? 0 : (i/(n-1))));
  }

  // y-axis labels
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  ctx.font = `${11*dpr}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  const yfmt = st.opts && typeof st.opts.yFmt === "function" ? st.opts.yFmt : miniDefaultFmt;
  for (const tv of ticks){
    const y = yOf(tv);
    ctx.fillText(yfmt(tv), plotX - 6*dpr, y);
  }
  ctx.restore();

  // line path
  const n = values.length;
  ctx.save();
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = (st.opts && st.opts.stroke) ? st.opts.stroke : "rgba(56,189,248,0.95)";
  ctx.beginPath();
  let moved=false;
  for (let i=0;i<n;i++){
    const v = values[i];
    if (v==null || !isFinite(v)) continue;
    const x = xOf(i,n);
    const y = yOf(v);
    if (!moved){ ctx.moveTo(x,y); moved=true; } else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // hover index
  if (st.hover && st.hover.active){
    const mx = (st.hover.x * dpr);
    const rel = (mx - plotX) / plotW;
    let idx = Math.round(rel * (n-1));
    if (!isFinite(idx)) idx = null;
    if (idx != null) idx = Math.max(0, Math.min(n-1, idx));
    st.hover.idx = idx;

    const hv = values[idx];
    if (hv != null && isFinite(hv)){
      const hx = xOf(idx,n);
      const hy = yOf(hv);

      // marker
      ctx.save();
      ctx.fillStyle = "rgba(56,189,248,1)";
      ctx.beginPath();
      ctx.arc(hx, hy, 3.5*dpr, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // tooltip
      if (st.tooltip){
        const label = st.opts && st.opts.label ? st.opts.label : "";
        const unit = st.opts && st.opts.unit ? st.opts.unit : "";
        const valFmt = st.opts && typeof st.opts.valFmt === "function" ? st.opts.valFmt : miniDefaultFmt;
        const timeLabel = times[idx] != null ? String(times[idx]) : `#${idx+1}`;

        st.tooltip.innerHTML =
          `<div style="font-weight:700; margin-bottom:2px;">${escapeHtml(label || "Value")}</div>` +
          `<div><span class="muted">${escapeHtml(timeLabel)}</span></div>` +
          `<div style="margin-top:3px;"><span class="mono" style="font-weight:700;">${escapeHtml(valFmt(hv))}</span>${unit ? ` <span class="muted">${escapeHtml(unit)}</span>` : ""}</div>`;

        // position tooltip near cursor, keep inside canvas box
        const r = c.getBoundingClientRect();
        const tx = (st.hover.x + 12);
        const ty = (st.hover.y + 12);
        st.tooltip.style.left = `${Math.min(tx, r.width - 140)}px`;
        st.tooltip.style.top = `${Math.min(ty, r.height - 70)}px`;
        st.tooltip.style.display = "block";
      }
    } else {
      if (st.tooltip) st.tooltip.style.display = "none";
    }
  }
}


function dailyValueOnLocalDay(dailyTime, dailyVals, dayDate){
  if (!dailyTime || !dailyVals) return null;
  const key = ymdLocal(dayDate);
  for (let i=0;i<dailyTime.length;i++){
    const t = dailyTime[i];
    if (t === key) return dailyVals[i];
    if (t > key) break;
  }
  return null;
}

function meanHourlyOnLocalDay(hourlyTime, hourlyVals, dayDate){
  if (!hourlyTime || !hourlyVals) return null;
  const start = startOfLocalDay(dayDate);
  const end = addLocalDays(start, 1);
  const t0 = start.getTime(), t1 = end.getTime();

  let sum = 0, n = 0;
  for (let i=0;i<hourlyTime.length;i++){
    const dt = parseLocalDateTime(hourlyTime[i]);
    if (!dt) continue;
    const ms = dt.getTime();
    if (ms < t0) continue;
    if (ms >= t1) break;
    const v = hourlyVals[i];
    if (v == null || !isFinite(v)) continue;
    sum += v; n++;
  }
  return n ? (sum / n) : null;
}

function meanWindDirOnLocalDay(hourlyTime, windDirDeg, dayDate){
  if (!hourlyTime || !windDirDeg) return null;
  const start = startOfLocalDay(dayDate);
  const end = addLocalDays(start, 1);
  const t0 = start.getTime(), t1 = end.getTime();

  let sumSin = 0, sumCos = 0, n = 0;
  for (let i=0;i<hourlyTime.length;i++){
    const dt = parseLocalDateTime(hourlyTime[i]);
    if (!dt) continue;
    const ms = dt.getTime();
    if (ms < t0) continue;
    if (ms >= t1) break;

    const d = windDirDeg[i];
    if (d == null || !isFinite(d)) continue;
    const rad = (Number(d) * Math.PI) / 180;
    sumSin += Math.sin(rad);
    sumCos += Math.cos(rad);
    n++;
  }

  if (!n) return null;
  const ang = Math.atan2(sumSin / n, sumCos / n);
  let deg = (ang * 180) / Math.PI;
  if (deg < 0) deg += 360;
  // Clamp to [0,360)
  if (deg >= 360) deg -= 360;
  return deg;
}

function computeLocationEnvMetricAt(wx, dayDate, metric){
  if (!wx) return null;

  const daily = wx.daily || {};
  const hourly = wx.hourly || {};

  if (metric === "rain_mm"){
    return dailyValueOnLocalDay(daily.time, daily.precipitation_sum, dayDate);
  }
  if (metric === "et0_mm"){
    return dailyValueOnLocalDay(daily.time, daily.et0_fao_evapotranspiration, dayDate);
  }
  if (metric === "temp_c"){
    return meanHourlyOnLocalDay(hourly.time, hourly.temperature_2m, dayDate);
  }
  if (metric === "rh_pct"){
    return meanHourlyOnLocalDay(hourly.time, hourly.relative_humidity_2m, dayDate);
  }
  if (metric === "vpd_kpa"){
    return meanHourlyOnLocalDay(hourly.time, hourly.vapour_pressure_deficit, dayDate);
  }
  if (metric === "soil_9_27"){
    return meanHourlyOnLocalDay(hourly.time, hourly.soil_moisture_9_27cm, dayDate);
  }
  if (metric === "soil_27_81"){
    return meanHourlyOnLocalDay(hourly.time, hourly.soil_moisture_27_81cm, dayDate);
  }
  if (metric === "soil_0_1"){
    return meanHourlyOnLocalDay(hourly.time, hourly.soil_moisture_0_1cm, dayDate);
  }
  if (metric === "soil_1_3"){
    return meanHourlyOnLocalDay(hourly.time, hourly.soil_moisture_1_3cm, dayDate);
  }
  if (metric === "soil_3_9"){
    return meanHourlyOnLocalDay(hourly.time, hourly.soil_moisture_3_9cm, dayDate);
  }
  if (metric === "wind_dir_deg"){
    return meanWindDirOnLocalDay(hourly.time, hourly.wind_direction_10m, dayDate);
  }

  if (metric === "msl_hpa"){
    return meanHourlyOnLocalDay(hourly.time, hourly.pressure_msl, dayDate);
  }
  if (metric === "wind_ms"){
    return meanHourlyOnLocalDay(hourly.time, hourly.wind_speed_10m, dayDate);
  }
  if (metric === "plume_idx"){
    const eod = new Date(addLocalDays(startOfLocalDay(dayDate), 1).getTime() - 60 * 1000);
    const sig = computeTropicalPlumeSignal(wx, eod);
    return sig && sig.score != null ? sig.score : null;
  }

  if (metric === "rain14_mm"){
    const sum14 = sumDailyLocalWindow(daily.time, daily.precipitation_sum, dayDate, 14);
    return (sum14 == null) ? null : (sum14 / 14);
  }
  if (metric === "et07_mm"){
    const sum7 = sumDailyLocalWindow(daily.time, daily.et0_fao_evapotranspiration, dayDate, 7);
    return (sum7 == null) ? null : (sum7 / 7);
  }

  return null;
}

function sumDailyLocalWindow(dailyTime, dailyVals, endDate, daysBack){
  if (!dailyTime || !dailyVals) return null;
  const endKey = ymdLocal(endDate);
  const startKey = ymdLocal(addLocalDays(startOfLocalDay(endDate), -(daysBack - 1)));

  let sum = 0, n = 0;
  for (let i=0;i<dailyTime.length;i++){
    const t = dailyTime[i];
    if (t < startKey) continue;
    if (t > endKey) break;
    const v = dailyVals[i];
    if (v == null || !isFinite(v)) continue;
    sum += v; n++;
  }
  // If data is sparse, still return sum of what's available (n>0)
  return n ? sum : null;
}

function computeDistrictEnvMeanAt(dayDate, metric){
  if (!dataCache?.wxList || !dataCache.wxList.length) return null;

  let sum = 0, n = 0;
  for (let i=0;i<dataCache.wxList.length;i++){
    const wx = dataCache.wxList[i];
    const v = computeLocationEnvMetricAt(wx, dayDate, metric);
    if (v == null || !isFinite(v)) continue;
    sum += v; n++;
  }
  return n ? (sum / n) : null;
}

async function ensureDistrictEnvTrendComputed(force=false){
  const canvas = document.getElementById("districtEnvChart");
  const meta = document.getElementById("districtEnvMeta");
  if (!canvas || !meta) return;

  if (!dataCache?.wxList){ meta.textContent = "No data loaded"; return; }

  const metric = getSelectedEnvMetric();
  const def = ENV_METRICS[metric] || ENV_METRICS.rain_mm;

  const win = getDistrictTrendWindow();

  const rangeMin = dataCache.rangeMin ? new Date(dataCache.rangeMin) : null;
  const rangeMax = dataCache.rangeMax ? new Date(dataCache.rangeMax) : null;

  let start = win.start;
  let end = win.end;
  if (rangeMin && start < rangeMin) start = rangeMin;
  if (rangeMax && end > rangeMax) end = rangeMax;

  if (start > end){
    meta.textContent = "No overlapping time window for district trend";
    return;
  }

  const key = windowKey({start, end}) + "|" + metric;
  if (!force && districtEnvTrend.key === key && districtEnvTrend.times?.length > 1) return;
  if (districtEnvTrend.building) return districtEnvTrend.building;

  meta.textContent = "Building district env trend from loaded data…";

  const buildPromise = (async ()=>{
    const times = [];
    const values = [];

    let d = localMidday(start);
    const endDay = localMidday(end);

    let safety = 0;
    while (d <= endDay && safety < 400){
      const meanV = computeDistrictEnvMeanAt(d, metric);
      times.push(new Date(d));
      values.push(meanV);

      d = addLocalDays(d, 1);
      safety++;
      if (safety % 5 === 0) await new Promise(r=>setTimeout(r,0));
    }

    districtEnvTrend.key = key;
    districtEnvTrend.metric = metric;
    districtEnvTrend.start = start;
    districtEnvTrend.end = end;
    districtEnvTrend.times = times;
    districtEnvTrend.values = values;

    const latest = [...values].reverse().find(v => v != null && isFinite(v));
    const rangeTxt = `${formatWhenNZ(start)} to ${formatWhenNZ(end)} • ${times.length} days`;
    meta.textContent = (latest != null)
      ? `${rangeTxt} • ${def.label} latest ${latest.toFixed(def.digits)} ${def.unit}`
      : `${rangeTxt} • ${def.label}`;

    districtEnvTrend.defaultMeta = meta.textContent;
    renderDistrictEnvTrendChart();
  })().finally(()=>{ districtEnvTrend.building = null; });

  districtEnvTrend.building = buildPromise;
  return buildPromise;
}

function envTrendLayout(w, h, minY, maxY){
  const padL = 56, padR = 10, padT = 10, padB = 18;
  const x0 = padL, x1 = w - padR;
  const y0 = padT, y1 = h - padB;

  const n = districtEnvTrend.times ? districtEnvTrend.times.length : 0;
  const xAt = (i)=> x0 + (x1 - x0) * (n <= 1 ? 0 : i / (n - 1));
  const yAt = (v)=> y1 - ((clamp(v, minY, maxY) - minY) / (maxY - minY)) * (y1 - y0);

  return { padL, padR, padT, padB, x0, x1, y0, y1, minY, maxY, n, xAt, yAt };
}

function computeNiceExtent(values){
  const finite = values.filter(v => v != null && isFinite(v));
  const metric2 = districtEnvTrend.metric;
  if (metric2 === "wind_dir_deg") return { min: 0, max: 360 };
  if (!finite.length) return { min: 0, max: 1 };
  let min = Math.min(...finite);
  let max = Math.max(...finite);
  if (min === max){
    const pad = (min === 0) ? 1 : Math.abs(min) * 0.15;
    min -= pad;
    max += pad;
  } else {
    const pad = (max - min) * 0.12;
    min -= pad;
    max += pad;
  }
  // Avoid negative lower bound for strictly non-negative metrics
  const metric = districtEnvTrend.metric;
  if (metric === "rain_mm" || metric === "rain14_mm" || metric === "et0_mm" || metric === "et07_mm" || metric === "rh_pct" || metric.startsWith("soil_")){
    min = Math.max(0, min);
  }
  return { min, max };
}

function drawEnvSeries(ctx, layout, values, stroke){
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  const n = values.length;
  let started = false;

  ctx.beginPath();
  for (let i=0;i<n;i++){
    const v = values[i];
    if (v == null || !isFinite(v)){
      started = false;
      continue;
    }
    const x = layout.xAt(i);
    const y = layout.yAt(v);
    if (!started){
      ctx.moveTo(x, y);
      started = true;
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
  ctx.restore();
}

function drawEnvAxes(ctx, layout, def){
  // Grid lines + y-axis labels
  const ticks = 5;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.fillStyle = "rgba(255,255,255,0.58)";
  ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

  for (let i=0;i<=ticks;i++){
    const t = i / ticks;
    const y = layout.y0 + (layout.y1 - layout.y0) * t;

    // Grid
    ctx.beginPath();
    ctx.moveTo(layout.x0, y);
    ctx.lineTo(layout.x1, y);
    ctx.stroke();

    // Label
    const v = layout.maxY - (layout.maxY - layout.minY) * t;
    const label = v.toFixed(def.digits);
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillText(label, layout.x0 - 8, y);
  }

  // x-axis baseline
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.beginPath();
  ctx.moveTo(layout.x0, layout.y1);
  ctx.lineTo(layout.x1, layout.y1);
  ctx.stroke();

  ctx.restore();
}

function ensureDistrictEnvHoverHooks(){
  const canvas = document.getElementById("districtEnvChart");
  if (!canvas || canvas._hoverHooked) return;
  canvas._hoverHooked = true;

  const tip = document.getElementById("districtEnvTooltip");

  const onMove = (e)=>{
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;

    const def = ENV_METRICS[districtEnvTrend.metric] || ENV_METRICS.rain_mm;
    const ext = computeNiceExtent(districtEnvTrend.values || []);
    const layout = envTrendLayout(r.width, r.height, ext.min, ext.max);

    if (x < layout.x0 || x > layout.x1 || y < layout.y0 || y > layout.y1){
      districtEnvHover.idx = null;
      if (tip) tip.style.display = "none";
      renderDistrictEnvTrendChart();
      return;
    }

    const t = (x - layout.x0) / (layout.x1 - layout.x0);
    const idx = clamp(Math.round(t * (layout.n - 1)), 0, layout.n - 1);

    districtEnvHover.idx = idx;
    districtEnvHover.x = x;
    districtEnvHover.y = y;
    districtEnvHover.active = true;

    renderDistrictEnvTrendChart();
  };

  const onLeave = ()=>{
    districtEnvHover.idx = null;
    districtEnvHover.active = false;

    const meta = document.getElementById("districtEnvMeta");
    if (meta && districtEnvTrend.defaultMeta) meta.textContent = districtEnvTrend.defaultMeta;

    if (tip) tip.style.display = "none";
    renderDistrictEnvTrendChart();
  };

  canvas.addEventListener("mousemove", onMove);
  canvas.addEventListener("mouseleave", onLeave);
  canvas.addEventListener("touchmove", (e)=>{
    if (!e.touches || !e.touches.length) return;
    onMove({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
  }, { passive: true });
  canvas.addEventListener("touchend", onLeave);
}

function renderDistrictEnvTrendChart(){
  const canvas = document.getElementById("districtEnvChart");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  ensureDistrictEnvHoverHooks();
  const tip = document.getElementById("districtEnvTooltip");

  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width));
  const h = Math.max(1, Math.floor(rect.height));
  const dpr = window.devicePixelRatio || 1;

  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  ctx.clearRect(0,0,w,h);

  const metric = districtEnvTrend.metric || getSelectedEnvMetric();
  const def = ENV_METRICS[metric] || ENV_METRICS.rain_mm;

  const values = districtEnvTrend.values || [];
  const ext = computeNiceExtent(values);
  const layout = envTrendLayout(w, h, ext.min, ext.max);

  // Axes + grid
  drawEnvAxes(ctx, layout, def);

  // Line
  drawEnvSeries(ctx, layout, values, cssVar("--ok"));

  // Hover marker + tooltip
  if (districtEnvHover.active && districtEnvHover.idx != null && layout.n > 0){
    const i = districtEnvHover.idx;
    const x = layout.xAt(i);
    const v = values[i];

    if (v != null && isFinite(v)){
      const y = layout.yAt(v);

      // Vertical line
      ctx.save();
      ctx.strokeStyle = "rgba(56,189,248,0.25)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, layout.y0);
      ctx.lineTo(x, layout.y1);
      ctx.stroke();

      // Dot
      ctx.fillStyle = cssVar("--ok");
      ctx.beginPath();
      ctx.arc(x, y, 3.3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      const when = districtEnvTrend.times[i];
      const dateTxt = when ? when.toLocaleDateString("en-NZ", { year:"numeric", month:"short", day:"2-digit" }) : "";
      const valTxt = v.toFixed(def.digits);

      if (tip){
        tip.style.display = "block";
        tip.style.left = Math.min(w - 160, Math.max(10, x + 10)) + "px";
        tip.style.top = "10px";
        tip.innerHTML = `<div style="font-weight:700; margin-bottom:2px;">${def.label}</div>
          <div class="muted">${dateTxt}</div>
          <div style="margin-top:6px;"><span style="font-weight:700">${valTxt}</span> <span class="muted">${def.unit}</span></div>`;
      }

      const meta = document.getElementById("districtEnvMeta");
      if (meta){
        meta.textContent = `${def.label} on ${dateTxt}: ${valTxt} ${def.unit}`;
      }
    } else {
      if (tip) tip.style.display = "none";
    }
  }
}



    
// ---- District River and Groundwater Trend (Normalised Stress, Interactive Hover) ----
// This chart shows a district-wide daily mean "hydrology stress" index per day.
// Each gauge is normalised using its own min/max over the displayed window so values are comparable
// across different rivers and bores (0 = relatively high water for that gauge, 100 = relatively low).

const districtHydroTrend = {
  key: null,
  start: null,
  end: null,
  times: [],
  river: [],
  gw: [],
  nRiver: [],
  nGw: [],
  building: null,
  defaultMeta: ""
};

const districtRiverHover = { idx: null, x: 0, y: 0, active: false };
const districtGWHover = { idx: null, x: 0, y: 0, active: false };

// Cache long-window series so we don't refetch on hover or re-render
const districtHydroHistoryCache = new Map();

function parseHilltopTimeToDate(t){
  if (!t) return null;
  if (t instanceof Date && !isNaN(t.getTime())) return t;
  const s = String(t).trim();
  // ISO or parseable formats
  let d = new Date(s);
  if (!isNaN(d.getTime())) return d;

  // Common Hilltop JSON format: "YYYY-MM-DD HH:MM[:SS]"
  const m = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
  if (m){
    const y = Number(m[1]);
    const mo = Number(m[2]) - 1;
    const da = Number(m[3]);
    const hh = Number(m[4]);
    const mm = Number(m[5]);
    const ss = Number(m[6] || 0);
    d = new Date(y, mo, da, hh, mm, ss, 0);
    if (!isNaN(d.getTime())) return d;
  }

  // Try again with a "T"
  d = new Date(s.replace(" ", "T"));
  if (!isNaN(d.getTime())) return d;

  return null;
}

function dailyMeanFromSeries(series){
  const tmp = new Map(); // dayKey -> {sum,n}
  if (!series || !Array.isArray(series.times) || !Array.isArray(series.values)) return tmp;

  for (let i=0;i<series.times.length;i++){
    const d = parseHilltopTimeToDate(series.times[i]);
    const v = series.values[i];
    if (!d || v == null || !isFinite(v)) continue;

    const key = ymdLocal(d);
    if (!key) continue;

    const cur = tmp.get(key) || { sum: 0, n: 0 };
    cur.sum += Number(v);
    cur.n += 1;
    tmp.set(key, cur);
  }

  const meanMap = new Map(); // dayKey -> mean
  for (const [k, obj] of tmp.entries()){
    meanMap.set(k, obj.n ? (obj.sum / obj.n) : null);
  }
  return meanMap;
}

function hourlyMeanFromSeries(series){
  const tmp = new Map(); // hourKey -> {sum,n}
  if (!series || !Array.isArray(series.times) || !Array.isArray(series.values)) return tmp;

  for (let i=0;i<series.times.length;i++){
    const d = parseHilltopTimeToDate(series.times[i]);
    const v = series.values[i];
    if (!d || v == null || !isFinite(v)) continue;

    const key = ymdhLocal(d);
    if (!key) continue;

    const cur = tmp.get(key) || { sum: 0, n: 0 };
    cur.sum += Number(v);
    cur.n += 1;
    tmp.set(key, cur);
  }

  const meanMap = new Map();
  for (const [k, obj] of tmp.entries()){
    meanMap.set(k, obj.n ? (obj.sum / obj.n) : null);
  }
  return meanMap;
}

function normaliseStressFromDailyMap(meanMap){
  let min = Infinity, max = -Infinity;
  for (const v of meanMap.values()){
    if (v == null || !isFinite(v)) continue;
    if (v < min) min = v;
    if (v > max) max = v;
  }
  if (!isFinite(min) || !isFinite(max) || max === min){
    return { min: null, max: null, stress: new Map() };
  }

  const stress = new Map(); // dayKey -> 0..100
  for (const [k, v] of meanMap.entries()){
    if (v == null || !isFinite(v)){
      stress.set(k, null);
      continue;
    }
    const t = (v - min) / (max - min);
    const s = clamp((1 - t) * 100, 0, 100);
    stress.set(k, s);
  }
  return { min, max, stress };
}

function hydroLayout(w, h, n){
  const padL = 42, padR = 10, padT = 10, padB = 22;
  const x0 = padL, x1 = w - padR;
  const y0 = padT, y1 = h - padB;

  const xAt = (i)=>{
    if (n <= 1) return x0;
    return x0 + (x1 - x0) * (i / (n - 1));
  };

  const yAt = (v)=>{
    const t = clamp((v - 0) / (100 - 0), 0, 1);
    return y1 - t * (y1 - y0);
  };

  return { padL, padR, padT, padB, x0, x1, y0, y1, xAt, yAt };
}

function drawHydroAxes(ctx, layout){
  const ticks = 5;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.fillStyle = "rgba(255,255,255,0.58)";
  ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

  for (let i=0;i<=ticks;i++){
    const t = i / ticks;
    const v = 0 + t * (100 - 0);
    const y = layout.yAt(v);

    ctx.beginPath();
    ctx.moveTo(layout.x0, y);
    ctx.lineTo(layout.x1, y);
    ctx.stroke();

    const txt = String(Math.round(v));
    ctx.fillText(txt, 8, y + 4);
  }
  ctx.restore();
}

function drawHydroLine(ctx, layout, values){
  const n = values ? values.length : 0;
  if (!n) return;

  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = cssVar("--ok");
  ctx.beginPath();

  let started = false;
  for (let i=0;i<n;i++){
    const v = values[i];
    if (v == null || !isFinite(v)){
      started = false;
      continue;
    }
    const x = layout.xAt(i);
    const y = layout.yAt(v);
    if (!started){
      ctx.moveTo(x, y);
      started = true;
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
  ctx.restore();
}

async function buildDistrictHydroStressSeries(kind, start, end){
  const list = (kind === "river") ? (dataCache.riverForLoc || []) : (dataCache.gwForLoc || []);
  const sites = [];

  for (const g of list){
    if (!g || !g.site) continue;
    // Enforce the same 10 km rule for safety
    if (isFinite(g.distanceKm) && g.distanceKm > 10) continue;
    sites.push(g.site);
  }

  // Unique site+measurement pairs
  const unique = new Map();
  for (const s of sites){
    const meas = (kind === "river") ? pickRiverHistoryMeasurement(s) : pickGroundwaterHistoryMeasurement(s);
    const siteName = s.name || s.title || "";
    if (!siteName) continue;
    const key = `${siteName}||${meas.name}`;
    if (!unique.has(key)) unique.set(key, { siteName, measName: meas.name });
  }

  const uniquePairs = [...unique.values()];
  const msDay = 24 * 60 * 60 * 1000;
  const daysBack = Math.max(2, Math.ceil((end.getTime() - start.getTime()) / msDay) + 2);
  const endStamp = formatDateTimeLocal(end);

  // Fetch and normalise per site
  const stressMaps = [];
  for (const p of uniquePairs){
    const cacheKey = `DH|${kind}|${p.siteName}||${p.measName}||${endStamp}||${daysBack}`;
    let series = districtHydroHistoryCache.get(cacheKey);

    if (!series){
      try{
        series = await fetchRiverHistory(p.siteName, p.measName, daysBack, end);
        districtHydroHistoryCache.set(cacheKey, series);
      } catch {
        continue;
      }
    }

    if (!series || !series.values || series.values.length < 2) continue;

    const daily = dailyMeanFromSeries(series);
    const norm = normaliseStressFromDailyMap(daily);
    if (!norm || !norm.stress || norm.stress.size === 0) continue;

    stressMaps.push(norm.stress);

    // Be nice to the UI thread
    if (stressMaps.length % 2 === 0) await new Promise(r=>setTimeout(r,0));
  }

  return { stressMaps, nSites: stressMaps.length };
}

function computeDistrictHydroDailyMean(times, stressMaps){
  const values = [];
  const nUsed = [];
  for (const d of times){
    const key = ymdLocal(d);
    let sum = 0, n = 0;
    for (const m of stressMaps){
      const v = m.get(key);
      if (v == null || !isFinite(v)) continue;
      sum += v; n++;
    }
    values.push(n ? (sum / n) : null);
    nUsed.push(n);
  }
  return { values, nUsed };
}

async function ensureDistrictHydroTrendComputed(force=false){
  const riverCanvas = document.getElementById("districtRiverChart");
  const gwCanvas = document.getElementById("districtGWChart");
  const meta = document.getElementById("districtHydroMeta");
  if (!riverCanvas || !gwCanvas || !meta) return;

  if (!dataCache?.wxList){ meta.textContent = "No data loaded"; return; }

  const win = getDistrictTrendWindow();
  const rangeMin = dataCache.rangeMin ? new Date(dataCache.rangeMin) : null;
  const rangeMax = dataCache.rangeMax ? new Date(dataCache.rangeMax) : null;

  let start = win.start;
  let end = win.end;
  if (rangeMin && start < rangeMin) start = rangeMin;
  if (rangeMax && end > rangeMax) end = rangeMax;

  if (start > end){
    meta.textContent = "No overlapping time window for hydrology";
    districtHydroTrend.key = null;
    districtHydroTrend.times = [];
    districtHydroTrend.river = [];
    districtHydroTrend.gw = [];
    renderDistrictHydroTrendCharts();
    return;
  }

  const key = `hydro|${timeMode}|${start.toISOString().slice(0,16)}|${end.toISOString().slice(0,16)}|${(dataCache.loadedAt||"")}`;

  if (!force && districtHydroTrend.key === key){
    renderDistrictHydroTrendCharts();
    if (districtHydroTrend.defaultMeta) meta.textContent = districtHydroTrend.defaultMeta;
    return;
  }

  if (districtHydroTrend.building) return districtHydroTrend.building;

  meta.textContent = "Building district hydrology trends (Hilltop)...";

  const buildPromise = (async ()=>{
    // Build daily timeline (inclusive)
    const times = [];
    let d = localMidday(start);
    const endDay = localMidday(end);
    let safety = 0;
    while (d <= endDay && safety < 400){
      times.push(new Date(d));
      d = addLocalDays(d, 1);
      safety++;
      if (safety % 10 === 0) await new Promise(r=>setTimeout(r,0));
    }

    const [riverRes, gwRes] = await Promise.all([
      buildDistrictHydroStressSeries("river", start, end),
      buildDistrictHydroStressSeries("gw", start, end)
    ]);

    const riverDaily = computeDistrictHydroDailyMean(times, riverRes.stressMaps);
    const gwDaily = computeDistrictHydroDailyMean(times, gwRes.stressMaps);

    districtHydroTrend.key = key;
    districtHydroTrend.start = start;
    districtHydroTrend.end = end;
    districtHydroTrend.times = times;
    districtHydroTrend.river = riverDaily.values;
    districtHydroTrend.gw = gwDaily.values;
    districtHydroTrend.nRiver = riverDaily.nUsed;
    districtHydroTrend.nGw = gwDaily.nUsed;

    const latestRiver = [...riverDaily.values].reverse().find(v => v != null && isFinite(v));
    const latestGw = [...gwDaily.values].reverse().find(v => v != null && isFinite(v));

    const rangeTxt = `${formatWhenNZ(start)} to ${formatWhenNZ(end)} • ${times.length} days`;
    const rTxt = (latestRiver != null) ? `River ${latestRiver.toFixed(1)} (n=${riverRes.nSites})` : `River n=${riverRes.nSites}`;
    const gTxt = (latestGw != null) ? `Groundwater ${latestGw.toFixed(1)} (n=${gwRes.nSites})` : `Groundwater n=${gwRes.nSites}`;

    meta.textContent = `${rangeTxt} • ${rTxt} • ${gTxt}`;
    districtHydroTrend.defaultMeta = meta.textContent;

    renderDistrictHydroTrendCharts();
  })().finally(()=>{ districtHydroTrend.building = null; });

  districtHydroTrend.building = buildPromise;
  return buildPromise;
}

function ensureDistrictHydroHoverHooks(){
  const riverCanvas = document.getElementById("districtRiverChart");
  const gwCanvas = document.getElementById("districtGWChart");

  if (riverCanvas && !riverCanvas._hydroHoverBound){
    riverCanvas._hydroHoverBound = true;

    const onMove = (e)=>{
      const rect = riverCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      districtRiverHover.x = x;
      districtRiverHover.y = y;
      districtRiverHover.active = true;
      renderDistrictHydroTrendCharts();
    };

    const onLeave = ()=>{
      districtRiverHover.active = false;
      districtRiverHover.idx = null;
      const tip = document.getElementById("districtRiverTooltip");
      if (tip) tip.style.display = "none";
      const meta = document.getElementById("districtHydroMeta");
      if (meta && districtHydroTrend.defaultMeta) meta.textContent = districtHydroTrend.defaultMeta;
      renderDistrictHydroTrendCharts();
    };

    riverCanvas.addEventListener("mousemove", onMove);
    riverCanvas.addEventListener("mouseleave", onLeave);
    riverCanvas.addEventListener("touchmove", (e)=>{
      if (!e.touches || !e.touches.length) return;
      onMove({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
    }, { passive:true });
    riverCanvas.addEventListener("touchend", onLeave);
  }

  if (gwCanvas && !gwCanvas._hydroHoverBound){
    gwCanvas._hydroHoverBound = true;

    const onMove = (e)=>{
      const rect = gwCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      districtGWHover.x = x;
      districtGWHover.y = y;
      districtGWHover.active = true;
      renderDistrictHydroTrendCharts();
    };

    const onLeave = ()=>{
      districtGWHover.active = false;
      districtGWHover.idx = null;
      const tip = document.getElementById("districtGWTooltip");
      if (tip) tip.style.display = "none";
      const meta = document.getElementById("districtHydroMeta");
      if (meta && districtHydroTrend.defaultMeta) meta.textContent = districtHydroTrend.defaultMeta;
      renderDistrictHydroTrendCharts();
    };

    gwCanvas.addEventListener("mousemove", onMove);
    gwCanvas.addEventListener("mouseleave", onLeave);
    gwCanvas.addEventListener("touchmove", (e)=>{
      if (!e.touches || !e.touches.length) return;
      onMove({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
    }, { passive:true });
    gwCanvas.addEventListener("touchend", onLeave);
  }
}

function renderOneHydroChart(canvasId, tooltipId, values, nUsedArr, hoverState, title){
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  ensureDistrictHydroHoverHooks();

  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width));
  const h = Math.max(1, Math.floor(rect.height));
  const dpr = window.devicePixelRatio || 1;

  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  ctx.clearRect(0,0,w,h);

  // Background
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.10)";
  ctx.fillRect(0,0,w,h);
  ctx.restore();

  const n = values ? values.length : 0;
  const layout = hydroLayout(w, h, n);

  drawHydroAxes(ctx, layout);
  drawHydroLine(ctx, layout, values);

  // Hover marker + tooltip
  const tip = document.getElementById(tooltipId);
  if (hoverState.active && n > 0){
    const x = clamp(hoverState.x, layout.x0, layout.x1);
    const frac = (layout.x1 === layout.x0) ? 0 : ((x - layout.x0) / (layout.x1 - layout.x0));
    const i = clamp(Math.round(frac * (n - 1)), 0, n - 1);
    hoverState.idx = i;

    const v = values[i];
    const xP = layout.xAt(i);

    // Vertical guide
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(xP, layout.y0);
    ctx.lineTo(xP, layout.y1);
    ctx.stroke();
    ctx.restore();

    if (v != null && isFinite(v)){
      const yP = layout.yAt(v);

      ctx.save();
      ctx.fillStyle = cssVar("--ok");
      ctx.beginPath();
      ctx.arc(xP, yP, 3.3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      const when = districtHydroTrend.times[i];
      const dateTxt = when ? when.toLocaleDateString("en-NZ", { year:"numeric", month:"short", day:"2-digit" }) : "";
      const valTxt = v.toFixed(1);
      const nTxt = (nUsedArr && nUsedArr[i] != null) ? `n=${nUsedArr[i]}` : "";

      if (tip){
        tip.style.display = "block";
        // Keep within chart
        const desiredLeft = xP + 10;
        const maxLeft = w - 180;
        tip.style.left = clamp(desiredLeft, 10, maxLeft) + "px";
        tip.style.top = "10px";
        tip.innerHTML = `<div style="font-weight:700; margin-bottom:2px;">${title}</div>` +
          `<div class="tiny muted">${dateTxt}</div>` +
          `<div style="margin-top:4px;"><span style="font-weight:700;">${valTxt}</span> / 100 <span class="tiny muted">${nTxt}</span></div>` +
          `<div class="tiny muted" style="margin-top:4px;">0 = high water for that gauge, 100 = low</div>`;
      }

      // Also update meta line for quick glance
      const meta = document.getElementById("districtHydroMeta");
      if (meta){
        const otherLatestRiver = [...(districtHydroTrend.river||[])].reverse().find(x=>x!=null && isFinite(x));
        const otherLatestGw = [...(districtHydroTrend.gw||[])].reverse().find(x=>x!=null && isFinite(x));
        const base = districtHydroTrend.defaultMeta || "";
        // Replace meta with hover context
        meta.textContent = `${dateTxt} • ${title}: ${valTxt} (${nTxt || "n=0"}) • River latest ${otherLatestRiver!=null?otherLatestRiver.toFixed(1):"–"} • Groundwater latest ${otherLatestGw!=null?otherLatestGw.toFixed(1):"–"}`;
      }
    } else {
      if (tip) tip.style.display = "none";
    }
  } else {
    if (tip) tip.style.display = "none";
  }
}

function renderDistrictHydroTrendCharts(){
  renderOneHydroChart("districtRiverChart", "districtRiverTooltip", districtHydroTrend.river, districtHydroTrend.nRiver, districtRiverHover, "River Stress");
  renderOneHydroChart("districtGWChart", "districtGWTooltip", districtHydroTrend.gw, districtHydroTrend.nGw, districtGWHover, "Groundwater Stress");
}


// District Hydrology Readings (Rivers and Groundwater) -------------------------

const STORAGE_KEY_HYDRO_READ_KIND = "fnHydroReadKind";
const STORAGE_KEY_HYDRO_READ_VIEW = "fnHydroReadView";
const STORAGE_KEY_HYDRO_READ_METRIC_RIVER = "fnHydroReadMetricRiver";
const STORAGE_KEY_HYDRO_READ_METRIC_GW = "fnHydroReadMetricGw";
const STORAGE_KEY_HYDRO_READ_SITES_RIVER = "fnHydroReadSitesRiver";
const STORAGE_KEY_HYDRO_READ_SITES_GW = "fnHydroReadSitesGw";
const STORAGE_KEY_HYDRO_READ_SCOPE = "fnHydroReadScope";
const STORAGE_KEY_HYDRO_READ_STEP = "fnHydroReadStep";
const STORAGE_KEY_HYDRO_READ_SITES_RIVER_ALL = "fnHydroReadSitesRiverAll";
const STORAGE_KEY_HYDRO_READ_SITES_GW_ALL = "fnHydroReadSitesGwAll";


const districtHydroReadings = {
  key: null,
  kind: "river",
  metric: "flow",
  view: "combined",
  unit: "",
  aggType: "sum",
  times: [],
  agg: [],
  aggN: [],
  sites: [],
  building: null,
  defaultMeta: "",
  step: "day"
};

const districtHydroReadingsCache = new Map();


const districtHydroReadHover = { idx: -1 };

function hydroReadMetricOptions(kind){
  if (kind === "gw"){
    return [
      { id: "level", label: "Level" }
    ];
  }
  return [
    { id: "flow", label: "Throughput (Flow)" },
    { id: "level", label: "Level (Stage)" }
  ];
}

function getSelectedHydroReadKind(){
  const el = document.getElementById("districtHydroKind");
  return el ? (el.value || "river") : "river";
}
function getSelectedHydroReadView(){
  const el = document.getElementById("districtHydroView");
  return el ? (el.value || "combined") : "combined";
}
function getSelectedHydroReadScope(){
  const el = document.getElementById("districtHydroScope");
  return el ? (el.value || "near") : "near";
}

function getSelectedHydroReadStep(){
  const el = document.getElementById("districtHydroStep");
  return el ? (el.value || "day") : "day";
}

function hydroReadSitesStorageKey(kind, scope){
  if (scope === "all") return (kind === "gw") ? STORAGE_KEY_HYDRO_READ_SITES_GW_ALL : STORAGE_KEY_HYDRO_READ_SITES_RIVER_ALL;
  return (kind === "gw") ? STORAGE_KEY_HYDRO_READ_SITES_GW : STORAGE_KEY_HYDRO_READ_SITES_RIVER;
}

function getSelectedHydroReadMetric(){
  const el = document.getElementById("districtHydroMetric");
  return el ? (el.value || "flow") : "flow";
}
function getSelectedHydroReadSiteIds(){
  const el = document.getElementById("districtHydroSitePicker");
  if (!el) return [];
  return Array.from(el.selectedOptions || []).map(o => o.value).filter(Boolean);
}

function setSelectValueSafe(selectEl, value){
  if (!selectEl) return;
  const opt = Array.from(selectEl.options || []).find(o => o.value === value);
  if (opt) selectEl.value = value;
}

function setMultiSelectValues(selectEl, values){
  if (!selectEl) return;
  const set = new Set(values || []);
  for (const opt of Array.from(selectEl.options || [])){
    opt.selected = set.has(opt.value);
  }
}

function collectDistrictHydroSites(kind, metric, scope){
  const out = [];
  const seen = new Set();

  const mode = (scope || getSelectedHydroReadScope() || "near");

  // Near mode uses nearest-per-location (filtered by distance)
  const withinKm = 10;

  if (mode === "all"){
    const rawSites = (kind === "gw") ? (dataCache?.gwSites || []) : (dataCache?.riverSites || []);
    for (const raw of rawSites){
      if (!raw) continue;

      const s = (kind === "gw") ? normaliseNrcGroundwaterSite(raw) : normaliseNrcRiverSite(raw);
      if (!s) continue;

      // Choose measurement and units
      let measName = "";
      let unitRaw = "";
      let label = "";

      if (kind === "gw"){
        const m = pickGroundwaterHistoryMeasurement(s);
        measName = (m.name || "").trim();
        unitRaw = m.units || s.levelUnits || "";
        label = "Level";
        if (!measName) continue;
      } else {
        if (metric === "flow"){
          measName = (s.flowMeasName || "").trim();
          unitRaw = s.flowUnits || "";
          label = "Flow";
          if (!measName) continue; // Only include flow-capable sites in Flow mode
        } else {
          measName = (s.levelMeasName || "Stage").trim();
          unitRaw = s.levelUnits || "";
          label = "Level";
        }
      }

      // Prefer raw Name for Hilltop queries where possible
      const siteName = (raw.Name || s.name || s.title || s.siteName || "").trim();
      const title = (s.title || raw.DisplayName || raw.Name || siteName || "").trim();
      if (!siteName || !title) continue;

      const id = `${siteName}||${measName}||${kind}||${metric}`;
      if (seen.has(id)) continue;
      seen.add(id);

      out.push({
        id,
        siteName,
        title,
        distanceKm: null,
        measName,
        unitRaw,
        label
      });
    }

    // Sort alphabetically
    out.sort((a,b)=> a.title.localeCompare(b.title));
    return out;
  }

  const src = (kind === "gw") ? (dataCache?.gwForLoc || []) : (dataCache?.riverForLoc || []);
  for (const ref of src){
    if (!ref || !ref.site) continue;
    if (ref.distanceKm != null && isFinite(ref.distanceKm) && ref.distanceKm > withinKm) continue;

    const s = ref.site;
    const siteName = (s.title || s.name || s.siteName || "").trim();
    if (!siteName) continue;

    let measName = "";
    let unitRaw = "";
    let label = "";

    if (kind === "gw"){
      const m = pickGroundwaterHistoryMeasurement(s);
      measName = m.name;
      unitRaw = m.units || s.levelUnits || "";
      label = "Level";
    } else {
      if (metric === "flow"){
        measName = (s.flowMeasName || "Flow").trim();
        unitRaw = s.flowUnits || "";
        label = "Flow";
      } else {
        measName = (s.levelMeasName || "Stage").trim();
        unitRaw = s.levelUnits || "";
        label = "Level";
      }
    }

    const id = `${siteName}||${measName}||${kind}||${metric}`;
    if (seen.has(id)) continue;
    seen.add(id);

    out.push({
      id,
      siteName,
      title: siteName,
      distanceKm: ref.distanceKm,
      measName,
      unitRaw,
      label
    });
  }

  // Sort by distance then name
  out.sort((a,b)=>{
    const da = (a.distanceKm == null || !isFinite(a.distanceKm)) ? 1e9 : a.distanceKm;
    const db = (b.distanceKm == null || !isFinite(b.distanceKm)) ? 1e9 : b.distanceKm;
    if (da !== db) return da - db;
    return a.title.localeCompare(b.title);
  });

  return out;
}

function normaliseHydroUnit(kind, metric, unitRaw){
  const u = String(unitRaw || "").trim();
  const lo = u.toLowerCase();

  // Rivers flow: convert everything to m3/s for aggregation
  if (kind === "river" && metric === "flow"){
    if (lo.includes("l/s") || lo.includes("ls")){
      return { unit: "m³/s", conv: (v)=> (v == null ? null : (v / 1000)) };
    }
    // Assume already m3/s or close
    return { unit: "m³/s", conv: (v)=> v };
  }

  // River stage: convert to meters
  if (kind === "river" && metric === "level"){
    if (lo === "mm" || lo.includes("mm")){
      return { unit: "m", conv: (v)=> (v == null ? null : (v / 1000)) };
    }
    if (lo === "cm" || lo.includes("cm")){
      return { unit: "m", conv: (v)=> (v == null ? null : (v / 100)) };
    }
    return { unit: "m", conv: (v)=> v };
  }

  // Groundwater level: assume meters
  if (kind === "gw"){
    if (lo === "mm" || lo.includes("mm")){
      return { unit: "m", conv: (v)=> (v == null ? null : (v / 1000)) };
    }
    if (lo === "cm" || lo.includes("cm")){
      return { unit: "m", conv: (v)=> (v == null ? null : (v / 100)) };
    }
    return { unit: "m", conv: (v)=> v };
  }

  return { unit: u, conv: (v)=> v };
}

function computeNiceExtentGeneric(values, clampMin0=false){
  const finite = values.filter(v => v != null && isFinite(v));
  if (!finite.length) return { min: 0, max: 1 };
  let min = Math.min(...finite);
  let max = Math.max(...finite);
  if (min === max){
    const pad = (min === 0) ? 1 : Math.abs(min) * 0.15;
    min -= pad; max += pad;
  } else {
    const pad = (max - min) * 0.12;
    min -= pad; max += pad;
  }
  if (clampMin0) min = Math.max(0, min);
  return { min, max };
}

function computeNiceExtentMulti(seriesList, clampMin0=false){
  const all = [];
  for (const s of seriesList || []){
    if (!s || !Array.isArray(s)) continue;
    for (const v of s){ all.push(v); }
  }
  return computeNiceExtentGeneric(all, clampMin0);
}

function hydroReadLayout(w, h, n, minY, maxY){
  const padL = 56, padR = 10, padT = 10, padB = 18;
  const x0 = padL, x1 = w - padR;
  const y0 = padT, y1 = h - padB;
  const xAt = (i)=> x0 + (x1 - x0) * (n <= 1 ? 0 : i / (n - 1));
  const yAt = (v)=> y1 - ((clamp(v, minY, maxY) - minY) / (maxY - minY)) * (y1 - y0);
  return { padL, padR, padT, padB, x0, x1, y0, y1, minY, maxY, n, xAt, yAt };
}

function drawHydroReadAxes(ctx, layout, digits=2){
  const ticks = 5;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.fillStyle = "rgba(255,255,255,0.58)";
  ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

  for (let i=0;i<=ticks;i++){
    const t = i / ticks;
    const y = layout.y0 + (layout.y1 - layout.y0) * t;

    ctx.beginPath();
    ctx.moveTo(layout.x0, y);
    ctx.lineTo(layout.x1, y);
    ctx.stroke();

    const v = layout.maxY - (layout.maxY - layout.minY) * t;
    const label = isFinite(v) ? v.toFixed(digits) : "-";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillText(label, layout.x0 - 8, y);
  }

  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.beginPath();
  ctx.moveTo(layout.x0, layout.y1);
  ctx.lineTo(layout.x1, layout.y1);
  ctx.stroke();

  ctx.restore();
}

function drawHydroReadSeries(ctx, layout, values, stroke, width=2){
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = width;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  const n = values.length;
  let started = false;
  ctx.beginPath();
  for (let i=0;i<n;i++){
    const v = values[i];
    if (v == null || !isFinite(v)){
      started = false;
      continue;
    }
    const x = layout.xAt(i);
    const y = layout.yAt(v);
    if (!started){
      ctx.moveTo(x, y);
      started = true;
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
  ctx.restore();
}

function buildHydroReadLegend(items){
  const legend = document.getElementById("districtHydroReadingsLegend");
  if (!legend) return;
  if (!items || !items.length){
    legend.style.display = "none";
    legend.innerHTML = "";
    return;
  }
  legend.style.display = "block";
  legend.innerHTML = items.map(it => {
    const safeName = escapeHtml(it.label || it.title || "");
    return `<span class="tag"><span class="dot" style="background:${it.color}"></span>${safeName}</span>`;
  }).join(" ");
}

function populateHydroReadMetricSelector(kind){
  const metricSel = document.getElementById("districtHydroMetric");
  if (!metricSel) return;

  const opts = hydroReadMetricOptions(kind);
  const existing = metricSel.value;

  metricSel.innerHTML = opts.map(o => `<option value="${o.id}">${escapeHtml(o.label)}</option>`).join("");

  // Restore last used metric per kind
  let saved = null;
  if (kind === "gw") saved = localStorage.getItem(STORAGE_KEY_HYDRO_READ_METRIC_GW);
  else saved = localStorage.getItem(STORAGE_KEY_HYDRO_READ_METRIC_RIVER);

  const target = saved || existing || opts[0].id;
  setSelectValueSafe(metricSel, target);
}

function populateHydroReadSitePicker(kind, metric, scope){
  const picker = document.getElementById("districtHydroSitePicker");
  if (!picker) return;

  const mode = (scope || getSelectedHydroReadScope() || "near");
  const sites = collectDistrictHydroSites(kind, metric, mode);

  picker.innerHTML = sites.map(s => {
    const dist = (s.distanceKm != null && isFinite(s.distanceKm)) ? ` (${fmt(s.distanceKm, 1)} km)` : "";
    const txt = `${s.title}${dist}`;
    return `<option value="${escapeHtml(s.id)}">${escapeHtml(txt)}</option>`;
  }).join("");

  const storageKey = hydroReadSitesStorageKey(kind, mode);
  let saved = null;
  try{ saved = JSON.parse(localStorage.getItem(storageKey) || "null"); }catch(e){ saved = null; }

  // Default selection
  const view = getSelectedHydroReadView();
  let defaults = sites.map(s => s.id);

  if (mode === "all"){
    // Avoid selecting everything by default since this can be heavy
    const lim = (view === "combined") ? 12 : 6;
    defaults = sites.slice(0, lim).map(s => s.id);
  } else {
    // Near mode matches previous behavior
    if (view === "individual") defaults = sites.slice(0, 6).map(s => s.id);
  }

  const sel = Array.isArray(saved) && saved.length ? saved : defaults;
  setMultiSelectValues(picker, sel);
}

function persistHydroReadSelections(){
  const kind = getSelectedHydroReadKind();
  const view = getSelectedHydroReadView();
  const metric = getSelectedHydroReadMetric();
  const scope = getSelectedHydroReadScope();
  const step = getSelectedHydroReadStep();

  localStorage.setItem(STORAGE_KEY_HYDRO_READ_KIND, kind);
  localStorage.setItem(STORAGE_KEY_HYDRO_READ_VIEW, view);
  localStorage.setItem(STORAGE_KEY_HYDRO_READ_SCOPE, scope);
  localStorage.setItem(STORAGE_KEY_HYDRO_READ_STEP, step);

  if (kind === "gw") localStorage.setItem(STORAGE_KEY_HYDRO_READ_METRIC_GW, metric);
  else localStorage.setItem(STORAGE_KEY_HYDRO_READ_METRIC_RIVER, metric);

  const siteIds = getSelectedHydroReadSiteIds();
  const storageKey = hydroReadSitesStorageKey(kind, scope);
  try{ localStorage.setItem(storageKey, JSON.stringify(siteIds)); }catch(e){}
}

async function ensureDistrictHydroReadingsComputed(force=false){
  const canvas = document.getElementById("districtHydroReadingsChart");
  const meta = document.getElementById("districtHydroReadingsMeta");
  if (!canvas || !meta) return;

  if (!dataCache){ meta.textContent = "No data loaded"; return; }

  const kind = getSelectedHydroReadKind();
  const view = getSelectedHydroReadView();
  const metric = getSelectedHydroReadMetric();
  const scope = getSelectedHydroReadScope();
  const step = getSelectedHydroReadStep();

  const win = getDistrictTrendWindow();
  const rangeMin = dataCache.rangeMin ? new Date(dataCache.rangeMin) : null;
  const rangeMax = dataCache.rangeMax ? new Date(dataCache.rangeMax) : null;

  let start = win.start;
  let end = win.end;
  if (rangeMin && start < rangeMin) start = rangeMin;
  if (rangeMax && end > rangeMax) end = rangeMax;

  if (start > end){ meta.textContent = "No overlapping time window for hydrology readings"; return; }

  // Selected sites
  const selected = getSelectedHydroReadSiteIds();
  const key = windowKey({start,end}) + `|hydroRead|${kind}|${metric}|${view}|${scope}|${step}|` + selected.join(",");

  if (!force && districtHydroReadings.key === key && districtHydroReadings.times?.length > 1) return;
  if (districtHydroReadings.building) return districtHydroReadings.building;

  meta.textContent = "Building district hydrology readings trend (Hilltop)...";

  const buildPromise = (async ()=>{
    // Build time buckets
    const times = [];
    const stepLabel = (step === "hour") ? "hourly" : "daily";
    let d = (step === "hour") ? startOfLocalHour(start) : localMidday(start);
    const endBucket = (step === "hour") ? startOfLocalHour(end) : localMidday(end);
    let safety = 0;
    const safetyMax = (step === "hour") ? 9600 : 400;
    while (d <= endBucket && safety < safetyMax){
      times.push(new Date(d));
      d = (step === "hour") ? addLocalHours(d, 1) : addLocalDays(d, 1);
      safety++;
      if (safety % 40 === 0) await new Promise(r=>setTimeout(r,0));
    }

    // Build site definitions from current picker options
    const allCandidates = collectDistrictHydroSites(kind, metric, scope);
    const pickedSet = new Set(selected);
    const pickedSites = allCandidates.filter(s => pickedSet.has(s.id));

    if (!pickedSites.length){
      districtHydroReadings.key = key;
      districtHydroReadings.kind = kind;
      districtHydroReadings.metric = metric;
      districtHydroReadings.view = view;
      districtHydroReadings.times = times;
      districtHydroReadings.sites = [];
      districtHydroReadings.agg = [];
      districtHydroReadings.aggN = [];
      districtHydroReadings.unit = "";
      districtHydroReadings.aggType = (metric === "flow") ? "sum" : "mean";
      meta.textContent = "No sites selected";
      districtHydroReadings.defaultMeta = meta.textContent;
      renderDistrictHydroReadingsChart();
      return;
    }

    // Fetch and align each site
    const daysBack = Math.max(7, Math.round((end.getTime() - start.getTime()) / (24*3600*1000)) + 2);
    const asOf = getAsOfDate();

    const siteSeries = [];

    for (let i=0;i<pickedSites.length;i++){
      const s = pickedSites[i];
      const unitNorm = normaliseHydroUnit(kind, metric, s.unitRaw);

      const cacheKey = `hydroRead||${s.siteName}||${s.measName}||${kind}||${metric}||${step}||${formatDateTimeLocal(asOf)}||${daysBack}`;

      let dailyMap = districtHydroReadingsCache.get(cacheKey);
      if (!dailyMap){
        try{
          const series = await fetchRiverHistory(s.siteName, s.measName, daysBack, asOf);
          const meanMapRaw = (step === "hour") ? hourlyMeanFromSeries(series) : dailyMeanFromSeries(series);
          // Apply conversion
          const meanMap = new Map();
          for (const [k,v] of meanMapRaw.entries()){
            const vv = (v == null || !isFinite(v)) ? null : unitNorm.conv(Number(v));
            meanMap.set(k, (vv == null || !isFinite(vv)) ? null : vv);
          }
          dailyMap = { meanMap, unit: unitNorm.unit };
          districtHydroReadingsCache.set(cacheKey, dailyMap);
        } catch (e){
          dailyMap = { meanMap: new Map(), unit: unitNorm.unit, error: true };
          districtHydroReadingsCache.set(cacheKey, dailyMap);
        }
      }

      const values = [];
      for (const t of times){
        const k = (step === "hour") ? ymdhLocal(t) : ymdLocal(t);
        const v = dailyMap.meanMap.get(k);
        values.push(v == null || !isFinite(v) ? null : v);
      }

      siteSeries.push({
        id: s.id,
        title: s.title,
        measName: s.measName,
        unit: dailyMap.unit || unitNorm.unit,
        values
      });

      if (i % 2 === 1) await new Promise(r=>setTimeout(r,0));
    }

    // Aggregate
    const agg = [];
    const aggN = [];
    const aggType = (metric === "flow") ? "sum" : "mean";

    for (let i=0;i<times.length;i++){
      let sum = 0;
      let n = 0;
      for (const ss of siteSeries){
        const v = ss.values[i];
        if (v == null || !isFinite(v)) continue;
        sum += v; n++;
      }
      aggN.push(n);
      if (!n){ agg.push(null); }
      else {
        agg.push(aggType === "sum" ? sum : (sum / n));
      }
    }

    // Determine unit label for aggregate
    let unit = "";
    if (metric === "flow") unit = "m³/s";
    else unit = "m";

    districtHydroReadings.key = key;
    districtHydroReadings.kind = kind;
    districtHydroReadings.metric = metric;
    districtHydroReadings.view = view;
    districtHydroReadings.unit = unit;
    districtHydroReadings.aggType = aggType;
    districtHydroReadings.times = times;
    districtHydroReadings.sites = siteSeries;
    districtHydroReadings.agg = agg;
    districtHydroReadings.aggN = aggN;

    const latest = [...agg].reverse().find(v => v != null && isFinite(v));
    const rangeTxt = `${formatWhenNZ(start)} to ${formatWhenNZ(end)} • ${times.length} days`;

    const modeTxt = (kind === "gw") ? "Groundwater" : "Rivers";
    const metricTxt = (metric === "flow") ? "Flow" : "Level";
    const aggTxt = (aggType === "sum") ? "Total" : "Mean";
    const latestTxt = (latest != null) ? `${aggTxt} ${metricTxt}: ${fmt(latest, metric === "flow" ? 3 : 2)} ${unit}` : `${aggTxt} ${metricTxt}: -`;

    meta.textContent = `${rangeTxt} • ${modeTxt} • ${latestTxt} • Sites ${siteSeries.length}`;
    districtHydroReadings.defaultMeta = meta.textContent;

    renderDistrictHydroReadingsChart();
  })().finally(()=>{ districtHydroReadings.building = null; });

  districtHydroReadings.building = buildPromise;
  return buildPromise;
}

function renderDistrictHydroReadingsChart(){
  const canvas = document.getElementById("districtHydroReadingsChart");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;

  ctx.clearRect(0,0,w,h);

  const kind = districtHydroReadings.kind;
  const metric = districtHydroReadings.metric;
  const view = getSelectedHydroReadView();
  const unit = districtHydroReadings.unit || "";

  const palette = [cssVar("--ok"), cssVar("--watch"), cssVar("--warn"), cssVar("--severe"), cssVar("--extreme")];

  const seriesToDraw = [];
  let legendItems = [];

  if (view === "individual"){
    const selected = getSelectedHydroReadSiteIds();
    const set = new Set(selected);
    const chosen = (districtHydroReadings.sites || []).filter(s => set.has(s.id));

    for (let i=0;i<chosen.length;i++){
      seriesToDraw.push(chosen[i].values);
      legendItems.push({ label: chosen[i].title, color: palette[i % palette.length] });
    }
    buildHydroReadLegend(legendItems);
  } else {
    seriesToDraw.push(districtHydroReadings.agg || []);
    buildHydroReadLegend([]);
  }

  const n = (districtHydroReadings.times || []).length;
  if (n < 2){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "12px system-ui";
    ctx.fillText("No trend data", 12, 18);
    ctx.restore();
    return;
  }

  const clampMin0 = (kind === "river" && metric === "flow");
  const ext = computeNiceExtentMulti(seriesToDraw, clampMin0);
  const layout = hydroReadLayout(w, h, n, ext.min, ext.max);

  drawHydroReadAxes(ctx, layout, metric === "flow" ? 3 : 2);

  if (view === "individual"){
    for (let i=0;i<seriesToDraw.length;i++){
      drawHydroReadSeries(ctx, layout, seriesToDraw[i], palette[i % palette.length], 2);
    }
  } else {
    drawHydroReadSeries(ctx, layout, seriesToDraw[0], cssVar("--ok"), 2.5);
  }

  // Hover point
  const i = districtHydroReadHover.idx;
  if (i != null && i >= 0 && i < n){
    let showV = null;
    if (view === "individual"){
      // If multiple series, just snap to first valid
      for (const arr of seriesToDraw){
        const v = arr[i];
        if (v != null && isFinite(v)){ showV = v; break; }
      }
    } else {
      const v = seriesToDraw[0][i];
      if (v != null && isFinite(v)) showV = v;
    }

    if (showV != null && isFinite(showV)){
      const xP = layout.xAt(i);
      const yP = layout.yAt(showV);
      ctx.save();
      ctx.fillStyle = cssVar("--ok");
      ctx.beginPath();
      ctx.arc(xP, yP, 3.3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }
}

function ensureDistrictHydroReadHoverHooks(){
  const canvas = document.getElementById("districtHydroReadingsChart");
  if (!canvas || canvas._hoverHooked) return;
  canvas._hoverHooked = true;

  const tip = document.getElementById("districtHydroReadingsTooltip");
  const meta = document.getElementById("districtHydroReadingsMeta");

  const onMove = (e)=>{
    const times = districtHydroReadings.times || [];
    if (times.length < 2) return;

    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) * devicePixelRatio;

    const w = canvas.width || 1;
    const padL = 56;
    const padR = 10;
    const x0 = padL;
    const x1 = w - padR;

    const t = clamp((x - x0) / (x1 - x0), 0, 1);
    const idx = Math.round(t * (times.length - 1));
    districtHydroReadHover.idx = idx;

    const when = times[idx];
    const step = getSelectedHydroReadStep();
    const dateTxt = when ? (
      step === "hour"
        ? when.toLocaleString("en-NZ", { year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" })
        : when.toLocaleDateString("en-NZ", { year:"numeric", month:"short", day:"2-digit" })
    ) : "";

    const kind = getSelectedHydroReadKind();
    const metric = getSelectedHydroReadMetric();
    const view = getSelectedHydroReadView();

    const unit = districtHydroReadings.unit || "";

    if (tip){
      tip.style.display = "block";
      const pad = 8;
      const offsetX = 14;
      const offsetY = 14;
      let left = e.clientX + offsetX;
      let top = e.clientY + offsetY;
      tip.style.left = left + "px";
      tip.style.top = top + "px";
      const maxLeft = Math.max(pad, (window.innerWidth || document.documentElement.clientWidth || 0) - tip.offsetWidth - pad);
      const maxTop = Math.max(pad, (window.innerHeight || document.documentElement.clientHeight || 0) - tip.offsetHeight - pad);
      if (left > maxLeft) left = e.clientX - tip.offsetWidth - offsetX;
      if (top > maxTop) top = e.clientY - tip.offsetHeight - offsetY;
      left = clamp(left, pad, maxLeft);
      top = clamp(top, pad, maxTop);
      tip.style.left = left + "px";
      tip.style.top = top + "px";

      const modeTxt = (kind === "gw") ? "Groundwater" : "Rivers";
      const metricTxt = (metric === "flow") ? "Flow" : "Level";

      if (view === "combined"){
        const v = (districtHydroReadings.agg || [])[idx];
        const nUsed = (districtHydroReadings.aggN || [])[idx];
        const valTxt = (v == null || !isFinite(v)) ? "-" : fmt(v, metric === "flow" ? 3 : 2);
        tip.innerHTML = `<div style="font-weight:700; margin-bottom:2px;">${escapeHtml(modeTxt)} ${escapeHtml(metricTxt)}</div>` +
          `<div class="tiny muted">${escapeHtml(dateTxt)}</div>` +
          `<div style="margin-top:4px;"><span style="font-weight:700;">${escapeHtml(valTxt)}</span> <span class="tiny muted">${escapeHtml(unit)}</span> <span class="tiny muted">n=${nUsed||0}</span></div>`;
      } else {
        const selected = getSelectedHydroReadSiteIds();
        const set = new Set(selected);
        const chosen = (districtHydroReadings.sites || []).filter(s => set.has(s.id));
        const rows = [];
        const maxRows = 12;
        for (let ii=0; ii<chosen.length && ii<maxRows; ii++){
          const s = chosen[ii];
          const v = s.values[idx];
          const valTxt = (v == null || !isFinite(v)) ? "-" : fmt(v, metric === "flow" ? 3 : 2);
          rows.push(`<div class="tiny"><span style="font-weight:700;">${escapeHtml(valTxt)}</span> <span class="muted">${escapeHtml(s.title)}</span></div>`);
        }
        if (chosen.length > maxRows){
          rows.push(`<div class="tiny muted">+${chosen.length - maxRows} more (switch to Combined if you need a compact view)</div>`);
        }

        tip.innerHTML = `<div style="font-weight:700; margin-bottom:2px;">${escapeHtml(modeTxt)} ${escapeHtml(metricTxt)}</div>` +
          `<div class="tiny muted">${escapeHtml(dateTxt)}</div>` +
          `<div style="margin-top:4px;">${rows.join("")}</div>`;
      }
    }

    if (meta){
      meta.textContent = districtHydroReadings.defaultMeta || meta.textContent;
    }

    renderDistrictHydroReadingsChart();
  };

  const onLeave = ()=>{
    districtHydroReadHover.idx = -1;
    if (tip) tip.style.display = "none";
    if (meta) meta.textContent = districtHydroReadings.defaultMeta || meta.textContent;
    renderDistrictHydroReadingsChart();
  };

  canvas.addEventListener("mousemove", onMove);
  canvas.addEventListener("mouseleave", onLeave);
}

function hookDistrictHydroReadControls(){
  const kindSel = document.getElementById("districtHydroKind");
  const metricSel = document.getElementById("districtHydroMetric");
  const viewSel = document.getElementById("districtHydroView");
  const scopeSel = document.getElementById("districtHydroScope");
    const stepSel = document.getElementById("districtHydroStep");
const picker = document.getElementById("districtHydroSitePicker");

  if (!kindSel || !metricSel || !viewSel || !scopeSel || !stepSel || !picker) return;
  if (kindSel._hooked) return;
  kindSel._hooked = metricSel._hooked = viewSel._hooked = scopeSel._hooked = stepSel._hooked = picker._hooked = true;

  // Restore saved kind, view, and scope
  const savedKind = localStorage.getItem(STORAGE_KEY_HYDRO_READ_KIND);
  const savedView = localStorage.getItem(STORAGE_KEY_HYDRO_READ_VIEW);
  const savedScope = localStorage.getItem(STORAGE_KEY_HYDRO_READ_SCOPE);

    const savedStep = localStorage.getItem(STORAGE_KEY_HYDRO_READ_STEP);
if (savedKind) setSelectValueSafe(kindSel, savedKind);
  if (savedView) setSelectValueSafe(viewSel, savedView);
  if (savedScope) setSelectValueSafe(scopeSel, savedScope);

    if (savedStep) setSelectValueSafe(stepSel, savedStep);
populateHydroReadMetricSelector(getSelectedHydroReadKind());
  populateHydroReadSitePicker(getSelectedHydroReadKind(), getSelectedHydroReadMetric(), getSelectedHydroReadScope());

  kindSel.addEventListener("change", ()=>{
    populateHydroReadMetricSelector(getSelectedHydroReadKind());
    populateHydroReadSitePicker(getSelectedHydroReadKind(), getSelectedHydroReadMetric(), getSelectedHydroReadScope());
    districtHydroReadings.key = null;
    persistHydroReadSelections();
    scheduleDistrictTrendBuild();
  });

  metricSel.addEventListener("change", ()=>{
    populateHydroReadSitePicker(getSelectedHydroReadKind(), getSelectedHydroReadMetric(), getSelectedHydroReadScope());
    districtHydroReadings.key = null;
    persistHydroReadSelections();
    scheduleDistrictTrendBuild();
  });

  viewSel.addEventListener("change", ()=>{
    // Update defaults when switching view if selection empty
    populateHydroReadSitePicker(getSelectedHydroReadKind(), getSelectedHydroReadMetric(), getSelectedHydroReadScope());
    districtHydroReadings.key = null;
    persistHydroReadSelections();
    scheduleDistrictTrendBuild();
  });

  scopeSel.addEventListener("change", ()=>{
    populateHydroReadSitePicker(getSelectedHydroReadKind(), getSelectedHydroReadMetric(), getSelectedHydroReadScope());
    districtHydroReadings.key = null;
    persistHydroReadSelections();
    scheduleDistrictTrendBuild();
  });

  
  stepSel.addEventListener("change", ()=>{
    districtHydroReadings.key = null;
    persistHydroReadSelections();
    scheduleDistrictTrendBuild();
  });
picker.addEventListener("change", ()=>{
    districtHydroReadings.key = null;
    persistHydroReadSelections();
    scheduleDistrictTrendBuild();
  });

  ensureDistrictHydroReadHoverHooks();
}



function scheduleDistrictTrendBuild(){
      const canvas = document.getElementById("districtTrendChart");
      if (!canvas) return;

      // Make sure env selector is initialised even if the user never opens District Summary first.
      const envSel = document.getElementById("districtEnvMetric");
      if (envSel && !envSel._hooked){
        envSel._hooked = true;
        const saved = localStorage.getItem(STORAGE_KEY_ENV_METRIC);
        if (saved) envSel.value = saved;
        envSel.addEventListener("change", ()=>{
          localStorage.setItem(STORAGE_KEY_ENV_METRIC, envSel.value);
          // Force rebuild for new metric
          districtEnvTrend.key = null;
          scheduleDistrictTrendBuild();
        });
      }

      window.clearTimeout(scheduleDistrictTrendBuild._t);
      scheduleDistrictTrendBuild._t = window.setTimeout(()=>{
        ensureDistrictTrendComputed(false).catch(()=>{});
        renderDistrictTrendChart();

        ensureDistrictEnvTrendComputed(false).catch(()=>{});
        renderDistrictEnvTrendChart();

        ensureDistrictHydroTrendComputed(false).catch(()=>{});
        renderDistrictHydroTrendCharts();

        hookDistrictHydroReadControls();
        ensureDistrictHydroReadingsComputed(false).catch(()=>{});
        renderDistrictHydroReadingsChart();
}, 60);
    }

    function selectLocation(id, panTo=false){
      selectedId = id;
      localStorage.setItem(STORAGE_KEY_LASTSEL, id);

      const row = computed.find(r => r.loc.id === id);
      if (!row) return;

      const trs = $("tbody").querySelectorAll("tr");
      trs.forEach(tr => {
        if (tr.dataset.id === id) tr.style.outline = "2px solid rgba(56,189,248,0.25)";
        else tr.style.outline = "none";
      });

      if (panTo && map){
        map.setView([row.loc.lat, row.loc.lon], Math.max(map.getZoom(), 9));
      }

      renderDetails(row);
    }

    function renderDetails(row){
      const cat = categoryForIndex(row.index.score);
      const panel = $("detailPanel");

      const parts = row.index.parts;
      const m = row.index.metrics;

      panel.innerHTML = `
        <h3>${escapeHtml(row.loc.name)}</h3>

        <div class="grid2">
          <div class="miniCard">
            <div class="k">Drought Index</div>
            <div class="v mono">${fmt(row.index.score, 0)} <span style="font-size:12px; font-weight:600; opacity:0.85;">${cat.name}</span></div>
            <div class="s">Composite signal from soil, rain, evap demand, humidity and river when available</div>
          </div>

          <div class="miniCard">
            <div class="k">Key Observations</div>
            <div class="s">
              Rain 14d: <strong class="mono">${fmt(m.pastRain14, 1)} mm</strong><br/>
              Forecast Rain 7d: <strong class="mono">${fmt(m.forecastRain7, 1)} mm</strong><br/>
              Forecast ET0 7d: <strong class="mono">${fmt(m.et0_7, 1)} mm</strong><br/>
              Forecast VPD Mean: <strong class="mono">${fmt(m.vpdMean, 2)}</strong><br/>
              RH Mean 7d: <strong class="mono">${fmt(m.rhMean7, 0)}%</strong><br/>
              ${buildRiverGaugeHtml(row.riverGauge)}
              ${buildGroundwaterGaugeHtml(row.gwGauge)}
              River Discharge (Modelled): <strong class="mono">${m.riverNow == null ? "-" : fmt(m.riverNow, 2)}</strong>
            </div>
          </div>
        </div>

        <div class="grid2">
          <div class="miniCard">
            <div class="k">Component Scores (0 wet, 1 dry)</div>
            <div class="s">
              Soil: <strong class="mono">${fmt(parts.soil, 2)}</strong><br/>
              Rain: <strong class="mono">${fmt(parts.rain, 2)}</strong><br/>
              Evap Demand: <strong class="mono">${fmt(parts.evap, 2)}</strong><br/>
              Humidity: <strong class="mono">${fmt(parts.humidity, 2)}</strong><br/>
              River: <strong class="mono">${fmt(parts.river, 2)}</strong>
            </div>
          </div>

          <div class="miniCard">
            <div class="k">Soil Moisture Layers</div>
            <div class="s">
              ${row.index.soilDetails.map(d => {
                const cur = d.current == null ? "-" : fmt(d.current, 3);
                const dry = d.dryness == null ? "-" : fmt(d.dryness, 2);
                return `<div style="display:flex; justify-content:space-between; gap:10px;">
                  <span>${escapeHtml(d.label)}</span>
                  <span class="mono">${cur} <span style="opacity:0.75;">dry ${dry}</span></span>
                </div>`;
              }).join("")}
            </div>
          </div>
        </div>
        <div class="miniCard">
          <div class="k">Climate Drivers and Plume Signal</div>
          <div class="s muted">Context layer only. This does not change the drought score.</div>

          <div class="trendLegend" style="margin:8px 0 2px 0;">
            <span class="tag" id="locEnsoTag"><span class="dot" style="background:var(--ok)"></span>ENSO: <span class="mono">Loading</span></span>
            <span class="tag" id="locSamTag"><span class="dot" style="background:var(--ok)"></span>SAM: <span class="mono">Loading</span></span>
            <span class="tag" id="locMjoTag"><span class="dot" style="background:var(--ok)"></span>MJO: <span class="mono">Loading</span></span>
            <span class="tag" id="locPlumeTag"><span class="dot" style="background:var(--ok)"></span>Plume: <span class="mono">${row.plumeNow ? fmt(row.plumeNow.score, 0) : "-"}</span> <span class="mono" style="opacity:0.75;">${row.plumeNow ? escapeHtml(row.plumeNow.label) : "-"}</span></span>
          </div>
          <div class="tiny muted" id="locDriversMeta">Best effort fetch of global indices</div>

          <div class="tiny muted" id="locPlumeReason" style="margin-top:8px;">${row.plumeNow ? escapeHtml(row.plumeNow.reason) : "-"}</div>
	          <div class="climateExplainGrid" id="locClimateExplainGrid">
	            <div class="explainItem"><div class="explainTitle">ENSO</div><div class="explainBody" id="locExplainEnso">-</div></div>
	            <div class="explainItem"><div class="explainTitle">SAM</div><div class="explainBody" id="locExplainSam">-</div></div>
	            <div class="explainItem"><div class="explainTitle">MJO</div><div class="explainBody" id="locExplainMjo">-</div></div>
	            <div class="explainItem"><div class="explainTitle">Tropical Plume Signal</div><div class="explainBody" id="locExplainPlume">${escapeHtml(buildPlumeExplainText(row.plumeNow))}</div></div>
	          </div>

        </div>

        <div class="miniCard">
          <div class="k">Recent Trend (Daily Rain Soil River Groundwater)</div>
          <div class="s muted">Daily rain (mm), daily average soil moisture (9-27 cm), river history (nearest gauge), and groundwater level history (nearest bore) for the last 7 days</div>
          <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:10px; margin-top:8px;">
            <div>
              <div class="muted" style="font-size:12px; margin-bottom:6px;">Daily Rain</div>
              <div class="trendWrap"><canvas class="spark recentCanvas" id="sparkRain"></canvas><div id="sparkRainTooltip" class="chartTooltip" style="display:none;"></div></div>
            </div>
            <div>
              <div class="muted" style="font-size:12px; margin-bottom:6px;">Soil 9-27 cm (Daily Avg)</div>
              <div class="trendWrap"><canvas class="spark recentCanvas" id="sparkSoil"></canvas><div id="sparkSoilTooltip" class="chartTooltip" style="display:none;"></div></div>
            </div>
            <div>
              <div class="muted" style="font-size:12px; margin-bottom:6px;">River (Nearest Gauge)</div>
              <div class="trendWrap"><canvas class="spark recentCanvas" id="sparkRiver"></canvas><div id="sparkRiverTooltip" class="chartTooltip" style="display:none;"></div></div>
              <div class="tiny muted" id="sparkRiverMeta" style="margin-top:4px;"></div>
            </div>
            <div>
              <div class="muted" style="font-size:12px; margin-bottom:6px;">Groundwater (Nearest Bore)</div>
              <div class="trendWrap"><canvas class="spark recentCanvas" id="sparkGW"></canvas><div id="sparkGWTooltip" class="chartTooltip" style="display:none;"></div></div>
              <div class="tiny muted" id="sparkGWMeta" style="margin-top:4px;"></div>
            </div>
          </div>
        </div>

        <div class="miniCard">
          <div class="k">Interpretation Tips</div>
          <div class="s">
            This index is designed to be operational. If soil dryness is high and rain dryness is high, your drought risk is elevated even if humidity is moderate. If forecast rain is substantial, rain dryness will be lower and the index should ease. If you see a mismatch with local impacts, tune thresholds and weights in the droughtConfig block.
          </div>
        </div>
      `;

      setTimeout(() => {
  ensureClimateDriversFetched();
  applyClimateDriversToUi();
  const asOf = getAsOfDate();
  const dates = row.dailySeries?.dates ?? [];
  const rainFull = row.dailySeries?.precip ?? [];
  const soilFull = row.dailySeries?.soil9_27_avg ?? [];

  const rain = sliceDailyToWindowSeries(dates, rainFull, asOf, 7);
  const soil = sliceDailyToWindowSeries(dates, soilFull, asOf, 7);

  setMiniTrendSeries(
    "sparkRain",
    "sparkRainTooltip",
    rain.dates,
    rain.values,
    { label: "Daily Rain", unit: "mm", valFmt: (v) => fmt(v, 1), yFmt: (v) => fmt(v, 1) }
  );

  setMiniTrendSeries(
    "sparkSoil",
    "sparkSoilTooltip",
    soil.dates,
    soil.values,
    { label: "Soil 9–27 cm (Daily Avg)", unit: "", valFmt: (v) => fmt(v, 3), yFmt: (v) => fmt(v, 2) }
  );

  const plume = row.plumeSeries || { dates: [], values: [] };
  setMiniTrendSeries(
    "sparkPlume",
    "sparkPlumeTooltip",
    plume.dates,
    plume.values,
    { label: "Tropical Plume Signal", unit: "", valFmt: (v) => fmt(v, 0), yFmt: (v) => fmt(v, 0) }
  );


  updateRiverSpark(row);
  updateGroundwaterSpark(row);
}, 0);
}

    function computeDailySeries(wx){
      const daily = wx?.daily || {};
      const hourly = wx?.hourly || {};
      const out = { dates: [], precip: [], soil9_27_avg: [] };

      if (Array.isArray(daily.time) && Array.isArray(daily.precipitation_sum)){
        out.dates = daily.time.slice();
        out.precip = daily.precipitation_sum.slice();
      }

      if (Array.isArray(hourly.time) && Array.isArray(hourly.soil_moisture_9_27cm)){
        const byDay = new Map();
        for (let i=0;i<hourly.time.length;i++){
          const k = dayKeyFromIso(hourly.time[i]);
          const v = hourly.soil_moisture_9_27cm[i];
          if (v == null || isNaN(v)) continue;
          const cur = byDay.get(k) || { sum: 0, n: 0 };
          cur.sum += v;
          cur.n += 1;
          byDay.set(k, cur);
        }
        const dates = out.dates.length ? out.dates : Array.from(byDay.keys()).sort();
        out.soil9_27_avg = dates.map(d => {
          const s = byDay.get(d);
          return s && s.n ? (s.sum / s.n) : null;
        });
        if (!out.dates.length) out.dates = dates;
      }

      return out;
    }

    /***********************
     * Main Data Flow
     ***********************/
    async function refresh(opts){
      const options = opts || {};
      const forceProviders = !!options.forceProviders;

      if (!Array.isArray(locations) || !locations.length){
        showToast("No locations are loaded.");
        return;
      }

      let pastDays = clamp(Number($("pastDays").value) || 30, 7, 92);
      const forecastDays = clamp(Number($("forecastDays").value) || 7, 3, 16);

  // Snapshot mode should always include at least 30 days lookback (like Live).
  if (timeMode === "historic" && !historicUseRange){
    pastDays = Math.max(pastDays, 30);
  }
      $("pastDays").value = pastDays;
      $("forecastDays").value = forecastDays;

      if (timeMode === "historic"){
        const now = nowLocal();
        if (!(asOfSnapshot instanceof Date) || isNaN(asOfSnapshot.getTime())){
          asOfSnapshot = new Date(now.getTime());
        }
        if (asOfSnapshot > now){
          asOfSnapshot = new Date(now.getTime());
          localStorage.setItem(STORAGE_KEY_ASOF, asOfSnapshot.toISOString());
          updateTimeControls();
          showToast("Historic date is in the future. Using current time instead.");
        }
        $("tableHint").textContent = `Loading historical data as of ${formatDateTimeLocal(asOfSnapshot)}...`;
      } else {
        $("tableHint").textContent = "Loading Open-Meteo, river and groundwater data...";
      }
      setStatus("Loading");

      // Cache-first: if the loaded cache fully covers the current view, do not call providers.
      const preferCache = !!(DASH_CONFIG?.cache?.preferCacheWhenAvailable);
      const cursor = (timeMode === "historic") ? asOfSnapshot : nowLocal();
      const maxAgeMin = DASH_CONFIG?.cache?.maxCacheAgeMinutes;

      // Optional UI toggle (not always present): when true, never fall back to live providers.
      // If the checkbox isn't in this build, it simply defaults to false.
      const providersOff = !!(document.getElementById("providersOff")?.checked);

      const ageOk = (maxAgeMin == null || !(dataCache.loadedAt instanceof Date) || isNaN(dataCache.loadedAt.getTime()))
        ? true
        : ((Date.now() - dataCache.loadedAt.getTime()) <= (Number(maxAgeMin) * 60 * 1000));

      if (!forceProviders && preferCache && dataCache.wxList && cacheMatchesCurrentLocations() && cacheCoversAsOf(cursor) && ageOk){
        ensureCacheLocationsSig();
        try{
          // Hydrology values are snapshot-based in historic mode, so update them from cache/archive if available.
          if (timeMode === "historic"){
            await hydrateNrcGaugesAtAsOf(dataCache.riverForLoc, dataCache.gwForLoc, cursor);
          }
        } catch(e){
          // Non-fatal: drought scoring can still render without a hydrology update.
          console.warn("Hydrology hydrate from cache/archive failed:", e);
        }

        const minStr = (dataCache.rangeMin instanceof Date) ? ymdLocal(dataCache.rangeMin) : "";
        const maxStr = (dataCache.rangeMax instanceof Date) ? ymdLocal(dataCache.rangeMax) : "";
        $("tableHint").textContent = (minStr && maxStr)
          ? `Using cached data (${minStr} to ${maxStr}). No provider calls were made.`
          : "Using cached data. No provider calls were made.";

        recomputeFromCache();
        if (timeMode === "historic"){
          updatePlaybackSlider();
          setPlaybackStatus("Using cached data (no provider calls).");
        }
        setStatus("Ready");
        return;
      }

      // If the cache is missing coverage and provider fallback is disabled, stop here.
      if (!forceProviders && preferCache && dataCache.wxList && (providersOff || DASH_CONFIG?.import?.providerFallbackWhenMissing === false)){
        showToast("Archive does not cover the requested window and provider fallback is disabled.");
        setStatus("Ready");
        return;
      }

try{
        // Open-Meteo requests are batched to avoid 414 Request-URI Too Large when many locations are loaded.
        // NRC river and groundwater datasets remain "best effort".
        const nrcRiversP = (NRC_RIVERS_URL ? fetchJson(NRC_RIVERS_URL, 25000) : Promise.resolve(null));
        const nrcGwP = (NRC_GW_URL ? fetchJson(NRC_GW_URL, 25000) : Promise.resolve(null));

        const om = await fetchOpenMeteoBatched(locations, pastDays, forecastDays);
        const forecastData = om.forecastData;
        const floodData = om.floodData;

        if (!forecastData || !forecastData.length){
          throw new Error("Forecast API failed");
        }

        const [nrcRivers, nrcGw] = await Promise.allSettled([nrcRiversP, nrcGwP])
          .then(results => results.map(r => r.status === "fulfilled" ? r.value : null));

        const wxList = forecastData;
        const floodList = floodData || [];

const riverSites = Array.isArray(nrcRivers) ? nrcRivers : [];
const riverForLoc = locations.map(loc => pickNearestRiverSite(loc, riverSites));

const gwSites = Array.isArray(nrcGw) ? nrcGw : [];
const gwForLoc = locations.map(loc => pickNearestGroundwaterSite(loc, gwSites));

if (timeMode === "historic"){
  await hydrateNrcGaugesAtAsOf(riverForLoc, gwForLoc, getAsOfDate());
}

dataCache.wxList = wxList;
dataCache.floodList = floodList;
dataCache.riverSites = riverSites;
dataCache.gwSites = gwSites;
dataCache.riverForLoc = riverForLoc;
dataCache.gwForLoc = gwForLoc;
dataCache.locationsSig = fingerprintLocations(locations);
dataCache.loadedAt = new Date();
dataCache.pastDays = pastDays;
dataCache.forecastDays = forecastDays;

const range = deriveWxRange(wxList[0]);
dataCache.rangeMin = range.min;
dataCache.rangeMax = range.max;
updateTimeInputMinMax();
clampAsOfToRange();

recomputeFromCache();

if (timeMode === "historic"){
  updatePlaybackSlider();
  if (historicRangeStart && historicRangeEnd){
    setPlaybackStatus("Range loaded. Press Play.");
  }
}

setStatus("Ready");

      } catch (err){
        console.error(err);
        setStatus("Error");
        document.getElementById("tableHint").textContent = "Error loading data";
        showToast("Could not load one or more datasets. Check your network and try again.");
      }
    }

    /***********************
     * Locations Modal
     ***********************/
    function openModal(){
      document.getElementById("locationsJson").value = JSON.stringify(locations, null, 2);
      document.getElementById("modalBack").style.display = "flex";
    }
    function closeModal(){
      document.getElementById("modalBack").style.display = "none";
    }

    /***********************
     * Boot
     ***********************/
    window.addEventListener("load", () => {
      locations = loadLocations();
      initMap();

  // Best effort fetch of global climate drivers for context tags
  ensureClimateDriversFetched();
  applyClimateDriversToUi();

// District env metric selector
const envSel = document.getElementById("districtEnvMetric");
if (envSel && !envSel._hooked){
  envSel._hooked = true;
  const saved = localStorage.getItem(STORAGE_KEY_ENV_METRIC);
  if (saved) envSel.value = saved;
  envSel.addEventListener("change", ()=>{
    localStorage.setItem(STORAGE_KEY_ENV_METRIC, envSel.value);
    districtEnvTrend.key = null;
    scheduleDistrictTrendBuild();
  });
}

// Time explorer controls
const selTimeMode = document.getElementById("timeMode");
const inpAsOf = document.getElementById("asOfInput");
if (selTimeMode && inpAsOf){
  const savedMode = localStorage.getItem(STORAGE_KEY_TIMEMODE);
  if (savedMode === "historic" || savedMode === "live") timeMode = savedMode;
  else if (savedMode === "snapshot") timeMode = "historic";

  const savedAsOf = localStorage.getItem(STORAGE_KEY_ASOF);
  if (savedAsOf){
    const d = new Date(savedAsOf);
    if (!isNaN(d.getTime())) asOfSnapshot = d;
  }
  if (!asOfSnapshot) asOfSnapshot = new Date();

  updateTimeControls();

  
selTimeMode.addEventListener("change", async () => {
    stopPlayback();
    timeMode = selTimeMode.value === "historic" ? "historic" : "live";
    localStorage.setItem(STORAGE_KEY_TIMEMODE, timeMode);

    if (timeMode === "historic"){
      // Snapshot mode is the default. Load Range switches Playback on.
      historicUseRange = false;
      // Keep existing loaded cursor (or now) but do not auto-fetch.
      if (!(asOfSnapshot instanceof Date) || isNaN(asOfSnapshot.getTime())){
        asOfSnapshot = new Date(nowLocal().getTime());
        localStorage.setItem(STORAGE_KEY_ASOF, asOfSnapshot.toISOString());
      }
      pendingAsOfStr = formatDateTimeLocal(asOfSnapshot);
      updateTimeControls();
      updatePlaybackSlider();
      setPlaybackStatus("Pick a Historic Date Time then click Load Snapshot, or use Playback to load a range.");
      // Show whatever is currently in cache without forcing fetch
      recomputeFromCache();
      return;
    }

    // Live mode: return to now and refresh providers normally
    pendingAsOfStr = null;
    updateTimeControls();
    updatePlaybackSlider();
    await refresh();
  });

  inpAsOf.addEventListener("change", () => {
    if (timeMode !== "historic") return;
    pendingAsOfStr = inpAsOf.value;
    const btnSnap = document.getElementById("btnLoadSnapshot");
    if (btnSnap) btnSnap.disabled = !parseDateTimeLocal(pendingAsOfStr);
    // No auto-load here.
  });

  const btnLoadSnapshot = document.getElementById("btnLoadSnapshot");
  if (btnLoadSnapshot){
    btnLoadSnapshot.addEventListener("click", async () => {
      if (timeMode !== "historic") return;
      stopPlayback();
      historicUseRange = false;
      const d = parseDateTimeLocal(inpAsOf.value);
      if (!d){
        showToast("Invalid historic date and time.");
        return;
      }
      pendingAsOfStr = inpAsOf.value;
      setPlaybackStatus(`Loading snapshot ${formatDateTimeLocal(d)}...`);
      await seekCursor(d, { allowRefresh: true });
      setPlaybackStatus(`Snapshot loaded: ${formatDateTimeLocal(getAsOfDate())}`);
      // Button disable state depends on the picker value
      btnLoadSnapshot.disabled = !parseDateTimeLocal(inpAsOf.value);
    });
  }
}


  if (inpAsOf && timeMode === "live") inpAsOf.disabled = true;


// Playback controls (historic range)
syncPlaybackInputs();
showPlaybackPanel(timeMode === "historic");
updatePlaybackSlider();

const inpRangeStart = document.getElementById("rangeStartInput");
const inpRangeEnd = document.getElementById("rangeEndInput");
const btnLoadRange = document.getElementById("btnLoadRange");
const btnPlay = document.getElementById("btnPlay");
const btnPause = document.getElementById("btnPause");
const btnStepBack = document.getElementById("btnStepBack");
const btnStepFwd = document.getElementById("btnStepFwd");
const selStep = document.getElementById("playStep");
const selSpeed = document.getElementById("playSpeed");
const chkLoop = document.getElementById("playLoop");
const chkHydro = document.getElementById("playHydro");
const playSlider = document.getElementById("playSlider");

function readAndPersistPlaybackSettings(){
  if (selStep){
    playbackState.stepMinutes = Number(selStep.value) || playbackState.stepMinutes;
    localStorage.setItem(STORAGE_KEY_PLAY_STEP, String(playbackState.stepMinutes));
  }
  if (selSpeed){
    playbackState.speedMs = Number(selSpeed.value) || playbackState.speedMs;
    localStorage.setItem(STORAGE_KEY_PLAY_SPEED, String(playbackState.speedMs));
  }
  if (chkLoop){
    playbackState.loop = !!chkLoop.checked;
    localStorage.setItem(STORAGE_KEY_PLAY_LOOP, String(playbackState.loop));
  }
  if (chkHydro){
    playbackState.hydro = !!chkHydro.checked;
    localStorage.setItem(STORAGE_KEY_PLAY_HYDRO, String(playbackState.hydro));
  }
}

if (selStep) selStep.addEventListener("change", () => { readAndPersistPlaybackSettings(); updatePlaybackSlider(); });
if (selSpeed) selSpeed.addEventListener("change", () => { readAndPersistPlaybackSettings(); if (playbackState.isPlaying){ stopPlayback(); startPlayback(); } });
if (chkLoop) chkLoop.addEventListener("change", () => { readAndPersistPlaybackSettings(); });
if (chkHydro) chkHydro.addEventListener("change", () => { readAndPersistPlaybackSettings(); });

if (btnLoadRange){
  btnLoadRange.addEventListener("click", async () => {
    readAndPersistPlaybackSettings();
    stopPlayback();
    historicUseRange = true;

    const dStart = inpRangeStart ? parseDateTimeLocal(inpRangeStart.value) : null;
    const dEnd = inpRangeEnd ? parseDateTimeLocal(inpRangeEnd.value) : null;
    if (!dStart || !dEnd){
      showToast("Please set Range Start and Range End.");
      return;
    }

    historicRangeStart = dStart;
    historicRangeEnd = dEnd;
    if (historicRangeStart > historicRangeEnd){
      const tmp = historicRangeStart; historicRangeStart = historicRangeEnd; historicRangeEnd = tmp;
    }

    localStorage.setItem(STORAGE_KEY_RANGE_START, historicRangeStart.toISOString());
    localStorage.setItem(STORAGE_KEY_RANGE_END, historicRangeEnd.toISOString());

    // Set cursor to range start for a consistent playback start
    asOfSnapshot = new Date(historicRangeStart.getTime());
    localStorage.setItem(STORAGE_KEY_ASOF, asOfSnapshot.toISOString());
    if (inpAsOf){
    inpAsOf.value = formatDateTimeLocal(asOfSnapshot);
    pendingAsOfStr = inpAsOf.value;
  }

    updatePlaybackSlider();
    setPlaybackStatus(`Loading range ${formatDateTimeLocal(historicRangeStart)} to ${formatDateTimeLocal(historicRangeEnd)}...`);

    // Fetch once for the whole range (with buffers)
    await refresh();

    setPlaybackStatus("Range loaded. Press Play.");
    updatePlaybackSlider();
  });
}

if (playSlider){
  playSlider.addEventListener("input", async () => {
    stopPlayback();
    const c = getCursorFromSlider();
    if (c) await seekCursor(c, { allowRefresh: false });
  });
}

if (btnStepBack){
  btnStepBack.addEventListener("click", async () => {
    stopPlayback();
    const slider = document.getElementById("playSlider");
    if (!slider) return;
    let v = Number(slider.value) || 0;
    v = Math.max(Number(slider.min)||0, v-1);
    slider.value = String(v);
    const c = getCursorFromSlider();
    if (c) await seekCursor(c, { allowRefresh: false });
  });
}

if (btnStepFwd){
  btnStepFwd.addEventListener("click", async () => {
    stopPlayback();
    const slider = document.getElementById("playSlider");
    if (!slider) return;
    let v = Number(slider.value) || 0;
    v = Math.min(Number(slider.max)||0, v+1);
    slider.value = String(v);
    const c = getCursorFromSlider();
    if (c) await seekCursor(c, { allowRefresh: false });
  });
}

if (btnPlay) btnPlay.addEventListener("click", () => { readAndPersistPlaybackSettings(); startPlayback(); });
if (btnPause) btnPause.addEventListener("click", () => { stopPlayback(); });

      document.getElementById("btnRefresh").addEventListener("click", () => refresh({ forceProviders: true }));
      document.getElementById("btnEditLocations").addEventListener("click", openModal);

      document.getElementById("btnDownloadData").addEventListener("click", async () => {
        try{
          const bundle = buildExportBundle();
          await downloadObjectAsFile(bundle);
        } catch (e){
          console.error(e);
          showToast("Could not build a download bundle. See console for details.");
        }
      });

      

      const btnZip = document.getElementById("btnExportZip");
      if (btnZip){
        btnZip.addEventListener("click", async () => {
          try{
            await exportZipGithubLayout();
          } catch (e){
            console.error(e);
            showToast("ZIP export failed. See console for details.");
          }
        });
      }

const fileInp = document.getElementById("fileLoadData");
      document.getElementById("btnLoadData").addEventListener("click", () => {
        if (fileInp) fileInp.click();
      });

      if (fileInp){
        fileInp.addEventListener("change", async (e) => {
          const f = e.target.files && e.target.files[0] ? e.target.files[0] : null;
          if (!f) return;
          try{
            const bundle = await parseBundleFromFile(f);
            if (!applyLoadedBundle(bundle)){
              showToast("Bundle could not be loaded.");
            }
          } catch (err){
            console.error(err);
            showToast("Could not read that file. If it is .gz, your browser may not support DecompressionStream.");
          } finally {
            fileInp.value = "";
          }
        });

      // Load ZIP manifest (split GitHub layout)
      const zipInp = document.getElementById("fileLoadZipManifest");
      document.getElementById("btnLoadZipManifest").addEventListener("click", () => {
        if (zipInp) zipInp.click();
      });

      if (zipInp){
        zipInp.addEventListener("change", async (e) => {
          const f = e.target.files && e.target.files[0] ? e.target.files[0] : null;
          if (!f) return;
          try{
            await loadZipManifestSplitLayout(f);
          } finally {
            zipInp.value = "";
          }
        });
      }

      }

      
// Hosted manifest URL import (GitHub raw/GitHub Pages)
const manifestUrlField = document.getElementById("manifestUrlField");
const manifestUrlInput = document.getElementById("manifestUrlInput");
const btnLoadManifestUrl = document.getElementById("btnLoadManifestUrl");

if (DASH_CONFIG?.import?.enableManifestUrlLoad){
  if (manifestUrlField) manifestUrlField.style.display = "inline-flex";
  if (btnLoadManifestUrl) btnLoadManifestUrl.style.display = "inline-block";

  const rememberKey = DASH_CONFIG?.import?.manifestUrlRememberKey || "";
  const remembered = rememberKey ? localStorage.getItem(rememberKey) : null;

  if (manifestUrlInput){
    manifestUrlInput.value = (remembered && String(remembered).trim()) ? String(remembered) : String(DASH_CONFIG?.import?.manifestUrlDefault || "");
    manifestUrlInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter"){
        e.preventDefault();
        if (btnLoadManifestUrl) btnLoadManifestUrl.click();
      }
    });
  }

  if (btnLoadManifestUrl){
    btnLoadManifestUrl.addEventListener("click", async () => {
      const u = manifestUrlInput ? String(manifestUrlInput.value || "").trim() : "";
      if (!u){
        showToast("Please enter a manifest URL.");
        return;
      }
      try{
        await loadHostedManifestUrl(u);
        if (rememberKey) localStorage.setItem(rememberKey, u);
      } catch (e){
        console.error(e);
        showToast("Hosted manifest load failed. See console for details.");
      }
    });
  }
} else {
  if (manifestUrlField) manifestUrlField.style.display = "none";
  if (btnLoadManifestUrl) btnLoadManifestUrl.style.display = "none";
}

document.getElementById("btnClearLoadedData").addEventListener("click", () => {
        clearLoadedData();
      });

      document.getElementById("btnCloseModal").addEventListener("click", closeModal);

      document.getElementById("btnResetLocations").addEventListener("click", () => {
        locations = DEFAULT_LOCATIONS.slice();
        document.getElementById("locationsJson").value = JSON.stringify(locations, null, 2);
        showToast("Reset to default locations.");
      });

      document.getElementById("btnSaveLocations").addEventListener("click", () => {
        const parsed = safeJsonParse(document.getElementById("locationsJson").value);
        if (!Array.isArray(parsed)){
          showToast("Invalid JSON. Expected an array of locations.");
          return;
        }
        const cleaned = parsed
          .filter(x => x && typeof x === "object")
          .map(x => ({
            id: String(x.id ?? "").trim() || ("loc_" + Math.random().toString(16).slice(2)),
            name: String(x.name ?? "Unnamed").trim(),
            lat: Number(x.lat),
            lon: Number(x.lon)
          }))
          .filter(x => isFinite(x.lat) && isFinite(x.lon) && x.name);

        if (!cleaned.length){
          showToast("No valid locations found. Each location needs name, lat and lon.");
          return;
        }
        locations = cleaned;
        saveLocations(locations);
        closeModal();
        showToast("Locations saved. Refreshing data.");
        refresh();
      });

      document.getElementById("modalBack").addEventListener("click", (e) => {
        if (e.target === document.getElementById("modalBack")) closeModal();
      });
      if (DASH_CONFIG?.startup?.autoRefreshOnLoad){
        refresh({ forceProviders: true });
      } else {
        // Stay idle until the user clicks Refresh or loads an archive ZIP/manifest
        $("tableHint").textContent = "Ready. Load an archive ZIP/manifest or click Refresh to fetch from providers.";
        setStatus("Ready");
      }
    });
  </script>
</body>
</html>
