<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Te Reo Maori Segmenter V12 Regression Suite</title>
  <style>
    :root{
      --bg:#0b0d10;
      --panel:#12161b;
      --panel2:#0f1318;
      --text:#e7eef7;
      --muted:#a8b3c2;
      --border:#222a33;
      --accent:#6aa9ff;
      --good:#3ddc97;
      --bad:#ff6b6b;
      --warn:#ffd166;
      --shadow: 0 8px 30px rgba(0,0,0,.35);
      --radius: 14px;
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      background:radial-gradient(1200px 700px at 20% -10%, rgba(106,169,255,.18), transparent 60%),
                 radial-gradient(900px 600px at 100% 20%, rgba(61,220,151,.12), transparent 55%),
                 var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height:1.45;
    }

    header{
      padding:18px 18px 10px 18px;
      position:sticky;
      top:0;
      backdrop-filter: blur(10px);
      background: rgba(11,13,16,.72);
      border-bottom:1px solid var(--border);
      z-index:10;
    }

    .wrap{ max-width:1180px; margin:0 auto; }

    .titleRow{ display:flex; gap:12px; align-items:flex-start; justify-content:space-between; }

    h1{ font-size:18px; margin:0; letter-spacing:.2px; }

    .sub{ margin:4px 0 0 0; color:var(--muted); font-size:12px; }

    nav{ display:flex; gap:8px; flex-wrap:wrap; }

    .tab{
      border:1px solid var(--border);
      background: rgba(18,22,27,.85);
      color:var(--text);
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:12px;
    }

    .tab.active{ border-color: rgba(106,169,255,.55); box-shadow: 0 0 0 3px rgba(106,169,255,.14); }

    main{ padding:16px 18px 32px 18px; }

    .card{
      background: linear-gradient(180deg, rgba(18,22,27,.95), rgba(15,19,24,.95));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px;
    }

    .stack{ display:flex; flex-direction:column; gap:12px; }

    h2{ font-size:14px; margin:0 0 6px 0; }
    h3{ font-size:13px; margin:10px 0 6px 0; }

    p{ margin:6px 0; color:var(--muted); font-size:12px; }

    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    .tag{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      font-size:12px;
      color:var(--text);
      background: rgba(0,0,0,.15);
    }

    button.tag{ cursor:pointer; }

    .tag.good{ border-color: rgba(61,220,151,.45); }
    .tag.bad{ border-color: rgba(255,107,107,.45); }
    .tag.warn{ border-color: rgba(255,209,102,.45); }

    .btn{
      border:1px solid var(--border);
      background: rgba(18,22,27,.85);
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
    }

    .btn.primary{ border-color: rgba(106,169,255,.55); }

    .btn:active{ transform: translateY(1px); }

    input[type="text"], input[type="search"], textarea{
      width:100%;
      background: rgba(0,0,0,.22);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:10px 10px;
      outline:none;
      font-size:12px;
    }

    textarea{ min-height: 200px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .controls{
      display:grid;
      grid-template-columns: 1fr auto auto auto auto;
      gap:8px;
      align-items:center;
    }

    @media (max-width: 900px){
      .controls{ grid-template-columns: 1fr 1fr; }
      .titleRow{ flex-direction:column; align-items:flex-start; }
    }

    .split{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap:12px;
      align-items:start;
    }

    @media (max-width: 980px){
      .split{ grid-template-columns: 1fr; }
    }

    table{ width:100%; border-collapse: collapse; overflow:hidden; border-radius: 12px; }
    th, td{ padding:10px 10px; border-bottom:1px solid var(--border); vertical-align: top; font-size:12px; }
    th{ text-align:left; color:var(--muted); font-weight:600; position:sticky; top:0; background: rgba(18,22,27,.98); }
    tr:hover td{ background: rgba(106,169,255,.06); }
    tr.selected td{ background: rgba(106,169,255,.10); }

    pre{ margin:0; white-space: pre-wrap; word-break: break-word; background: rgba(0,0,0,.18); border:1px solid var(--border); border-radius: 10px; padding:10px; font-size:12px; }
    code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    @media (max-width: 780px){
      .twoCol{ grid-template-columns: 1fr; }
    }

    .muted{ color:var(--muted); }

    .checkbox{
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      font-size:12px;
      color:var(--muted);
      padding:7px 10px;
      border:1px solid var(--border);
      border-radius:10px;
      background: rgba(0,0,0,.10);
    }

    .checkbox input{ transform: translateY(1px); }

    .hidden{ display:none !important; }

    .pillGrid{ display:flex; flex-wrap:wrap; gap:8px; }

    .ruleLayout{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:start;
    }

    @media (max-width: 980px){
      .ruleLayout{ grid-template-columns: 1fr; }
    }

    .ruleTitle{ font-size:13px; margin:0; }

    .divider{ height:1px; background: var(--border); margin:10px 0; }

    .miniTable td{ padding:8px 10px; }

    .scorePill{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:rgba(18,22,27,.75); font-size:12px; }
    .scoreDot{ width:10px; height:10px; border-radius:999px; background:var(--muted); }
    .scoreDot.good{ background: var(--good); }
    .scoreDot.warn{ background: var(--warn); }
    .scoreDot.bad{ background: var(--bad); }

    .tokenTable{ width:100%; border-collapse:collapse; overflow:hidden; border-radius:12px; border:1px solid var(--border); }
    .tokenTable th, .tokenTable td{ padding:10px 12px; border-bottom:1px solid var(--border); vertical-align:top; }
    .tokenTable th{ text-align:left; font-size:12px; color:var(--muted); background:rgba(18,22,27,.75); }
    .tokenTable tr:last-child td{ border-bottom:none; }

    .listEditor{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 980px){ .listEditor{ grid-template-columns:1fr; } }
    .listEditor textarea{ min-height:72px; }

    details.tokenDetails{ margin-top:8px; }
    details.tokenDetails summary{ cursor:pointer; color:var(--muted); }
    details.tokenDetails pre{ white-space:pre-wrap; }

    .signalLayout{ display:grid; grid-template-columns: 1fr 1.2fr; gap:12px; }
    @media (max-width: 980px){ .signalLayout{ grid-template-columns:1fr; } }

  
    .hlText{ padding:12px; border:1px solid var(--border); border-radius:12px; background:rgba(0,0,0,.18); line-height:1.7; white-space:pre-wrap; }
    .hlTok{ display:inline-block; padding:2px 6px; margin:1px 1px; border-radius:10px; border:1px solid transparent; cursor:pointer; user-select:none; }
    .hlTok.good{ background:rgba(61,220,151,.18); border-color:rgba(61,220,151,.25); }
    .hlTok.warn{ background:rgba(244,187,90,.18); border-color:rgba(244,187,90,.25); }
    .hlTok.bad{ background:rgba(255,83,112,.14); border-color:rgba(255,83,112,.22); }
    .hlTok.sel{ outline:2px solid rgba(106,169,255,.55); }
    
    .hlTok.inc{ box-shadow: inset 0 -2px 0 rgba(61,220,151,.30); }
    .hlTok.inc::after{ content:"•"; font-size:10px; opacity:.55; margin-left:4px; vertical-align:middle; }
    .hlTok.ovr{ border-style:dashed; }
    .hlTok.ovr::before{ content:"↻"; font-size:10px; opacity:.45; margin-right:4px; vertical-align:middle; }
.detectBlockLayout{ display:grid; grid-template-columns: 1.3fr .9fr; gap:12px; }
    @media (max-width: 980px){ .detectBlockLayout{ grid-template-columns: 1fr; } }


    /* STT Included Token Indicator */
    .hlTok.incl{ box-shadow: inset 0 -2px 0 rgba(106,169,255,.35); }
    .hlTok.manual{ outline: 1px dashed rgba(244,181,67,.35); outline-offset: -1px; }
    .hlTok.sel{ border-color: rgba(106,169,255,.65) !important; }
    </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="titleRow">
        <div>
          <h1>Te Reo Maori Segmenter V12 With Regression Suite</h1>
          <div class="sub">Standalone file. Segmenter logic and regression runner in one place. Includes rules pills and word history.</div>
        </div>
        <nav>
          <button class="tab active" id="tabRegression" type="button">Regression</button>
          <button class="tab" id="tabDemo" type="button">Demo</button>
          <button class="tab" id="tabG2P" type="button">G2P</button>
          <button class="tab" id="tabG2PAwsTts" type="button">G2P - AWS TTS</button>
                    <button class="tab" id="tabIpaLookupKeyboard" type="button">IPA Lookup And Keyboard</button>
          <button class="tab" id="tabSTT" type="button">Speech To Text</button>
<button class="tab" id="tabDetect" type="button">Te Reo Detect</button>
          <button class="tab" id="tabDetectBlock" type="button">Detect Text Block</button>
          <button class="tab" id="tabRules" type="button">Rules</button>
        </nav>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap">
      <section id="pageRegression" class="stack"></section>
      <section id="pageDemo" class="stack hidden"></section>
      <section id="pageG2P" class="stack hidden"></section>
      <section id="pageG2PAwsTts" class="stack hidden"></section>
            <section id="pageIpaLookupKeyboard" class="stack hidden"></section>
      <section id="pageSTT" class="stack hidden"></section>
<section id="pageDetect" class="stack hidden"></section>
      <section id="pageDetectBlock" class="stack hidden"></section>
      <section id="pageRules" class="stack hidden"></section>
    </div>
  </main>

<script src="https://sdk.amazonaws.com/js/aws-sdk-2.1545.0.min.js"></script>

<script>
  function el(tag, attrs={}, children=[]){
    const node = document.createElement(tag);
    for(const [k,v] of Object.entries(attrs||{})){
      if(k === 'class') node.className = v;
      else if(k === 'html') node.innerHTML = v;
      else if(k.startsWith('on') && typeof v === 'function') node.addEventListener(k.slice(2), v);
      else node.setAttribute(k, v);
    }
    for(const c of (children||[])){
      if(typeof c === 'string') node.appendChild(document.createTextNode(c));
      else if(c) node.appendChild(c);
    }
    return node;
  }

  function escapeHtml(s){
    return String(s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
  }

  function downloadText(filename, text, mime='text/plain'){
    const blob = new Blob([text], {type:mime});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function safeJsonParse(text){
    try{ return {ok:true, value: JSON.parse(text)}; }
    catch(e){ return {ok:false, error: String(e && e.message ? e.message : e)}; }
  }

  
  // Shared focus tracking and insertion helpers (IPA keyboard and SSML inserters)
  const APP_SHARED = window.APP_SHARED = window.APP_SHARED || {};
  if(!APP_SHARED.__focusTrackerInstalled){
    APP_SHARED.__focusTrackerInstalled = true;
    APP_SHARED.lastFocused = null;
    APP_SHARED.onFocus = APP_SHARED.onFocus || null;
    document.addEventListener('focusin', (e)=>{
      APP_SHARED.lastFocused = e.target;
      if(typeof APP_SHARED.onFocus === 'function'){
        try { APP_SHARED.onFocus(e); } catch(_e) {}
      }
    }, true);
  }

  const IPA_SYMBOL_OPTIONS_HTML = `          <optgroup label="Tone And Pitch Modifiers">
            <option value="˥">˥ - Extra high pitch</option>
            <option value="˦">˦ - High pitch</option>
            <option value="˧">˧ - Mid pitch</option>
            <option value="˨">˨ - Low pitch</option>
            <option value="˩">˩ - Extra low pitch</option>
            <option value="˩˥">˩˥ - Rising pitch</option>
            <option value="˥˩">˥˩ - Falling pitch</option>
          </optgroup>
          <optgroup label="Timing And Length Modifiers">
            <option value="ː">ː - Long vowel</option>
            <option value="ˑ">ˑ - Half-long</option>
            <option value="˘">˘ - Extra short</option>
            <option value="ˈ">ˈ - Primary stress</option>
            <option value="ˌ">ˌ - Secondary stress</option>
            <option value=".">. - Syllable break</option>
            <option value="̚">̚ - No audible release</option>
          </optgroup>
          <optgroup label="Phonation And Voice Quality">
            <option value="̤">̤ - Breathy</option>
            <option value="̰">̰ - Creaky</option>
            <option value="ʰ">ʰ - Aspirated</option>
            <option value="ɦ">ɦ - Voiced glottal fricative</option>
            <option value="̥">̥ - Voiceless</option>
            <option value="̬">̬ - Voiced emphasis</option>
            <option value="ˤ">ˤ - Pharyngealised</option>
            <option value="ʕ">ʕ - Pharyngeal approximant</option>
            <option value="˞">˞ - R-coloring</option>
            <option value="̝">̝ - Raised articulation</option>
            <option value="̞">̞ - Lowered articulation</option>
          </optgroup>
          <optgroup label="Place And Articulation Modifiers">
            <option value="ʲ">ʲ - Palatalised</option>
            <option value="ʷ">ʷ - Labialised</option>
            <option value="̪">̪ - Dental articulation</option>
            <option value="̠">̠ - Retracted articulation</option>
            <option value="̩">̩ - Syllabic consonant</option>
            <option value="̯">̯ - Non-syllabic vowel</option>
          </optgroup>
          <optgroup label="Glottal And Nasality Control">
            <option value="ʔ">ʔ - Glottal stop</option>
            <option value="ⁿ">ⁿ - Nasal release</option>
            <option value="̃">̃ - Nasalised vowel</option>
            <option value="ŋ">ŋ - Velar nasal</option>
          </optgroup>
          <optgroup label="Voicing And Articulation Variants">
            <option value="̙">̙ - Advanced tongue root (ATR)</option>
            <option value="̘">̘ - Retracted tongue root (RTR)</option>
            <option value="̺">̺ - Apical articulation (tongue tip)</option>
            <option value="̻">̻ - Laminal articulation (tongue blade)</option>
            <option value="ˠ">ˠ - Velarised (dark sound)</option>
            <option value="ˡ">ˡ - Lateral release</option>
            <option value="˞">˞ - Rhoticity (R-coloring)</option>
          </optgroup>
          <optgroup label="Special And Advanced">
            <option value="͡">͡ - Tie bar (coarticulation)</option>
            <option value="͜">͜ - Double tie bar</option>
            <option value="̼">̼ - Linguolabial</option>
            <option value="͍">͍ - Breathy underline</option>
          </optgroup>
          <optgroup label="Rhythm And Phrase Control">
            <option value="|">| - Minor (foot) group</option>
            <option value="‖">‖ - Major phrase boundary</option>
            <option value="↓">↓ - Pitch lowering (non-tonal)</option>
            <option value="↑">↑ - Pitch raising (non-tonal)</option>
            <option value="↗">↗ - Rising intonation</option>
            <option value="↘">↘ - Falling intonation</option>
          </optgroup>
          <optgroup label="IPA Base Characters - Vowels">
            <option value="a">a - Open front unrounded vowel</option>
            <option value="ɑ">ɑ - Open back unrounded vowel</option>
            <option value="æ">æ - Near-open front unrounded vowel</option>
            <option value="ɐ">ɐ - Near-open central vowel</option>
            <option value="e">e - Close-mid front unrounded vowel</option>
            <option value="ɛ">ɛ - Open-mid front unrounded vowel</option>
            <option value="ə">ə - Mid-central vowel</option>
            <option value="ɜ">ɜ - Open-mid central vowel</option>
            <option value="ɞ">ɞ - Open-mid central rounded vowel</option>
            <option value="i">i - Close front unrounded vowel</option>
            <option value="ɪ">ɪ - Near-close near-front unrounded vowel</option>
            <option value="o">o - Close-mid back rounded vowel</option>
            <option value="ɔ">ɔ - Open-mid back rounded vowel</option>
            <option value="u">u - Close back rounded vowel</option>
            <option value="ʊ">ʊ - Near-close near-back rounded vowel</option>
            <option value="y">y - Close front rounded vowel</option>
            <option value="ʏ">ʏ - Near-close near-front rounded vowel</option>
          </optgroup>
          <optgroup label="IPA Base Characters - R Variants">
            <option value="r">r - Alveolar trill</option>
            <option value="ɾ">ɾ - Alveolar flap</option>
            <option value="ʀ">ʀ - Uvular trill</option>
            <option value="ɹ">ɹ - Alveolar approximant (English r)</option>
            <option value="ɻ">ɻ - Retroflex approximant</option>
            <option value="ɽ">ɽ - Retroflex flap</option>
            <option value="ʁ">ʁ - Voiced uvular fricative</option>
          </optgroup>
          <optgroup label="IPA Base Characters - Consonants">
            <option value="b">b - Voiced bilabial plosive</option>
            <option value="d">d - Voiced alveolar plosive</option>
            <option value="g">g - Voiced velar plosive</option>
            <option value="k">k - Voiceless velar plosive</option>
            <option value="p">p - Voiceless bilabial plosive</option>
            <option value="t">t - Voiceless alveolar plosive</option>
            <option value="m">m - Bilabial nasal</option>
            <option value="n">n - Alveolar nasal</option>
            <option value="ŋ">ŋ - Velar nasal</option>
            <option value="f">f - Voiceless labiodental fricative</option>
            <option value="v">v - Voiced labiodental fricative</option>
            <option value="θ">θ - Voiceless dental fricative</option>
            <option value="ð">ð - Voiced dental fricative</option>
            <option value="s">s - Voiceless alveolar fricative</option>
            <option value="z">z - Voiced alveolar fricative</option>
            <option value="ʃ">ʃ - Voiceless postalveolar fricative</option>
            <option value="ʒ">ʒ - Voiced postalveolar fricative</option>
            <option value="h">h - Voiceless glottal fricative</option>
            <option value="ɦ">ɦ - Voiced glottal fricative</option>
            <option value="l">l - Alveolar lateral approximant</option>
            <option value="ʎ">ʎ - Palatal lateral approximant</option>
            <option value="ʔ">ʔ - Glottal stop</option>
          </optgroup>
          <optgroup label="Digraphs And Clusters - Maori Specific">
            <option value="ŋ">ng - ŋ</option>
            <option value="f">wh - f</option>
            <option value="ɸ">wh alternative - ɸ</option>
            <option value="ŋˤ">ng nasal deep - ŋˤ</option>
            <option value="d̞">r soft d - d̞</option>
            <option value="ɾ͡d">r flap-tap - ɾ͡d</option>
            <option value="ʀdʀ">r uvular roll - ʀdʀ</option>
            <option value="ʁ̞">r deep glottal - ʁ̞</option>
            <option value="ŋ̞">ng softened - ŋ̞</option>
            <option value="ŋˤː">ng emphatic long - ŋˤː</option>
          </optgroup>
          <optgroup label="Diphthongs - Maori Vowel Combinations">
            <option value="a̯i">ai - a̯i</option>
            <option value="a̯u">au - a̯u</option>
            <option value="e̯i">ei - e̯i</option>
            <option value="o̯u">ou - o̯u</option>
            <option value="u̯i">ui - u̯i</option>
            <option value="o̯i">oi - o̯i</option>
            <option value="i̯a">ia - i̯a</option>
            <option value="e̯a">ea - e̯a</option>
            <option value="i̯o">io - i̯o</option>
            <option value="a̯e">ae - a̯e</option>
            <option value="o̯a">oa - o̯a</option>
            <option value="u̯a">ua - u̯a</option>
          </optgroup>
          <optgroup label="Diphthongs - English Vowel Combinations">
            <option value="aɪ">aɪ - eye</option>
            <option value="aʊ">aʊ - ow</option>
            <option value="eɪ">eɪ - ay</option>
            <option value="oʊ">oʊ - oh</option>
            <option value="ɔɪ">ɔɪ - oy</option>
            <option value="ɪə">ɪə - ear (common in British English)</option>
            <option value="eə">eə - air (British variant)</option>
            <option value="ʊə">ʊə - oor (British variant)</option>
          </optgroup>
          <optgroup label="R Variants And Combinations Tested">
            <option value="ɾ">ɾ - Tap r</option>
            <option value="d̞">d̞ - Soft d</option>
            <option value="ɾ͡d">ɾ͡d - Flap plus soft d</option>
            <option value="ɾ͡d̞">ɾ͡d̞ - Flap tied to soft d</option>
            <option value="ɾ͡d˞">ɾ͡d˞ - Flap plus r-color</option>
            <option value="ʀ">ʀ - Uvular trill</option>
            <option value="ʀdʀ">ʀdʀ - Strong rolled r</option>
            <option value="ʁ̞">ʁ̞ - Soft glottal r</option>
            <option value="ɹ̠">ɹ̠ - Retracted English r</option>
          </optgroup>
          <optgroup label="Ng Variants And Combinations Tested">
            <option value="ŋ">ŋ - Standard ng</option>
            <option value="ŋˤ">ŋˤ - Pharyngealised ng</option>
            <option value="ŋ̞">ŋ̞ - Softened ng</option>
            <option value="ŋˤː">ŋˤː - Long deep nasal</option>
            <option value="ⁿg">ⁿg - Nasal release with following g</option>
            <option value="ʔŋ">ʔŋ - Glottal plus ng onset</option>
          </optgroup>
        `;

  function insertAtCursorText(el, text){
    if(!el) return;
    const tag = (el.tagName || '').toLowerCase();
    if(tag !== 'input' && tag !== 'textarea') return;
    const start = (typeof el.selectionStart === 'number') ? el.selectionStart : (el.value || '').length;
    const end = (typeof el.selectionEnd === 'number') ? el.selectionEnd : (el.value || '').length;
    const before = (el.value || '').slice(0, start);
    const after = (el.value || '').slice(end);
    el.value = before + text + after;
    el.focus();
    const pos = start + text.length;
    try {
      el.selectionStart = el.selectionEnd = pos;
    } catch(_e) {}
    el.dispatchEvent(new Event('input', {bubbles:true}));
  }

  function wrapSelectionText(el, before, after){
    if(!el) return;
    const tag = (el.tagName || '').toLowerCase();
    if(tag !== 'input' && tag !== 'textarea') return;
    const start = (typeof el.selectionStart === 'number') ? el.selectionStart : 0;
    const end = (typeof el.selectionEnd === 'number') ? el.selectionEnd : start;
    const selected = (el.value || '').slice(start, end);
    const pre = (el.value || '').slice(0, start);
    const post = (el.value || '').slice(end);
    el.value = pre + before + selected + after + post;
    el.focus();
    const pos = start + before.length + selected.length;
    try {
      el.selectionStart = el.selectionEnd = pos;
    } catch(_e) {}
    el.dispatchEvent(new Event('input', {bubbles:true}));
  }

  function normalizeWord(input){
    if(input == null) return '';
    return String(input).trim().toLowerCase().replace(/\u00AD/g,'');
  }

  function normalizeSegments(segs){
    return (segs || []).map(s => String(s).trim().toLowerCase()).filter(Boolean);
  }

  function segmentsToString(segs){
    return (segs || []).join(' + ');
  }

  function deriveWordFromExpected(expectedSegments){
    return (expectedSegments || []).join('');
  }

  function buildDiff(expected, actual){
    const maxLen = Math.max(expected.length, actual.length);
    for(let i=0;i<maxLen;i++){
      if(expected[i] !== actual[i]){
        const e = expected[i] == null ? '∅' : expected[i];
        const a = actual[i] == null ? '∅' : actual[i];
        return `First mismatch at index ${i}: expected "${e}" got "${a}"`;
      }
    }
    return 'No diff';
  }
  // Rule registry (Source: Logic Version 8, V12 Aligned)
  const RULES = [
    { id:'V8-R01', cat:'Pipeline', title:'Input Normalization', desc:`Convert input to string, trim whitespace and lowercase.
Remove soft hyphen characters (U+00AD).
If the normalized word is empty return an empty result with error "empty".
If the normalized word length is less than 2 return the word as the only segment.` },
    { id:'V8-R02', cat:'Pipeline', title:'Prefix Initialization', desc:`If the word starts with "wh" or "ng" then set prefix to the first 3 characters of the word.
Otherwise if the first character is a consonant and the second character is a vowel then set prefix to the first 2 characters.
Otherwise set prefix to the first character only.
Set remaining to the substring after the prefix.` },
    { id:'V8-R03', cat:'Pipeline', title:'Prefix Adjustment', desc:`If remaining begins with a vowel then append that vowel to the prefix and remove it from remaining.
Note: in v12 this adjustment always occurs when remaining starts with a vowel because the internal condition is always true.` },
    { id:'V8-R04', cat:'Pipeline', title:'Dynamic Suffix Split', desc:`Split remaining into middle and suffix using dynamicSuffixSplit.
Try suffix lengths 3 through 6 in order. For each candidate suffix:
- Segment the candidate suffix with segmentSyllables.
- If the segmentation has length 2 or less and at least one segment is a diphthong then accept this split.
If no candidate passes, fall back to middle = remaining without the last 3 characters and suffix = last 3 characters.` },
    { id:'V8-R05', cat:'Boundary Fixes', title:'Orphan Vowel Fix at Middle-Suffix Boundary', desc:`If middle ends with a vowel and the first character of suffix is a vowel:
- If the pair (lastMiddleVowel + suffixFirstVowel) is a diphthong then move the last middle vowel from middle to the start of suffix.` },
    { id:'V8-R06', cat:'Boundary Fixes', title:'Digraph Boundary Fix', desc:`If middle and suffix exist and suffix has at least 2 characters and suffix[1] is a vowel:
- If middle ends with "n" and suffix starts with "g" then replace this boundary with "ng" at the start of suffix and remove the trailing "n" from middle.
- Else if middle ends with "w" and suffix starts with "h" then replace this boundary with "wh" at the start of suffix and remove the trailing "w" from middle.` },
    { id:'V8-R07', cat:'Boundary Fixes', title:'Consonant Shift To Suffix', desc:`If suffix starts with a vowel and middle ends with a consonant:
- If middle ends with digraph "ng" or "wh" then move that digraph from middle to the start of suffix.
- Otherwise move the final consonant character from middle to the start of suffix.` },
    { id:'V8-R08', cat:'Pipeline', title:'Middle Segmentation', desc:`Segment middle using segmentSyllables.
segmentSyllables scans left to right and emits segments based on digraph logic, diphthong logic and CV fallback.` },
    { id:'V8-R09', cat:'Suffix Segmentation', title:'Suffix Segmentation High-Level', desc:`Suffix segmentation begins with a VCV grouping check then applies digraph specific handling and finally uses segmentSyllables as the general fallback.
Suffix rules may override earlier results from segmentSyllables.` },
    { id:'V8-R10', cat:'Suffix Segmentation', title:'Suffix Rule: VCV Chunking at Suffix Start', desc:`If suffix starts with Vowel + Consonant + Vowel then create a single first suffix chunk of those 3 characters.
Then segment any remaining characters after position 3 using segmentSyllables.` },
    { id:'V8-R11', cat:'Suffix Segmentation', title:'Suffix Rule: Digraph Plus Orphaned Vowel Pair', desc:`If suffix starts with "ng" or "wh" and suffix[2] and suffix[3] are vowels:
- Let vv = suffix[2] + suffix[3].
- If vv is a diphthong then set suffix segments to [digraph + vv] plus segmentation of any remaining substring after position 4.
- Else set suffix segments to [digraph + suffix[2]] plus segmentation of the remaining substring after position 3.` },
    { id:'V8-R12', cat:'Suffix Segmentation', title:'Suffix Rule: Preserve Digraph Plus Diphthong as Unit', desc:`If suffix starts with "ng" or "wh" and the substring after the digraph (suffix[2:]) is itself a diphthong then preserve the entire suffix as a single segment.
Example class: "ngae" and "whei".` },
    { id:'V8-R13', cat:'Suffix Segmentation', title:'Suffix Rule: Split Longer Digraph Suffixes Into CV Then Rest', desc:`If suffix starts with "ng" or "wh" and suffix length is greater than 3:
- Create first chunk as the first 3 characters (digraph + vowel).
- Segment the remainder using segmentSyllables.` },
    { id:'V8-R14', cat:'Suffix Segmentation', title:'Suffix Rule: Preserve Short Digraph Suffixes', desc:`If suffix starts with "ng" or "wh" and no earlier digraph rules apply then preserve the suffix as a single segment.` },
    { id:'V8-R15', cat:'Pipeline', title:'Final Assembly', desc:`Return the final segments as [prefix] + middleSegments + suffixSegments, removing any empty items.
The returned structure includes prefix, middle, suffix and per part segment lists.` },
    { id:'V8-S01', cat:'segmentSyllables', title:'Digraph Handling', desc:`At any index i, if the next two characters are "ng" or "wh":
- Consume the digraph.
- If the next character is a vowel then attempt to pair it with the next vowel to form a diphthong.
- If a diphthong exists then emit digraph + diphthong and advance by 2 vowels.
- Otherwise emit digraph + single vowel and advance by 1 vowel.
- If no vowel follows the digraph then emit the digraph alone.` },
    { id:'V8-S02', cat:'segmentSyllables', title:'Consonant Then Diphthong Then Vowel Preference', desc:`If the current character is a consonant and the next two characters form a diphthong and a third vowel follows:
- Emit consonant + diphthong as one segment.
- Leave the third vowel for the next iteration.
This prioritizes splits like tai + o instead of ta + i + o.` },
    { id:'V8-S03', cat:'segmentSyllables', title:'Consonant Then Diphthong', desc:`If the current character is a consonant and the next two characters form a diphthong:
- Emit consonant + diphthong.` },
    { id:'V8-S04', cat:'segmentSyllables', title:'Consonant Then Vowel Fallback', desc:`If the current character is a consonant and the next character is a vowel:
- Emit consonant + vowel.` },
    { id:'V8-S05', cat:'segmentSyllables', title:'Single Consonant Fallback', desc:`If the current character is a consonant and no vowel follows:
- Emit the consonant alone.` },
    { id:'V8-S06', cat:'segmentSyllables', title:'Bare Diphthong and Bare Vowel', desc:`If the current character is a vowel:
- If it and the next character form a diphthong, emit the diphthong.
- Otherwise emit the single vowel.` },
  ];

  const RULE_BY_ID = new Map(RULES.map(r => [r.id, r]));

  function uniquePreserveOrder(arr){
    const seen = new Set();
    const out = [];
    for(const v of (arr||[])){
      if(!seen.has(v)){
        seen.add(v);
        out.push(v);
      }
    }
    return out;
  }

  function renderRulePills(ruleIds, opts={}){
    const ids = uniquePreserveOrder(ruleIds || []);
    const wrap = el('div', {class:'row'});

    if(!ids.length){
      wrap.appendChild(el('span', {class:'tag warn'}, ['no rules detected']));
      return wrap;
    }

    const max = typeof opts.max === 'number' ? opts.max : 9999;
    const shown = ids.slice(0, max);
    const moreCount = Math.max(0, ids.length - shown.length);

    for(const id of shown){
      const r = RULE_BY_ID.get(id);
      const label = r ? `${r.id}` : id;
      const b = el('button', {type:'button', class:'tag', title: r ? r.title : id, onclick: ()=> openRule(id) }, [label]);
      wrap.appendChild(b);
    }

    if(moreCount){
      wrap.appendChild(el('span', {class:'tag'}, [`+${moreCount} more`]));
    }

    return wrap;
  }

  // Storage
  const STORAGE_KEYS = {
    tests: 'reorite_segmenter_v12_tests_json',
    regressionHistory: 'reorite_segmenter_v12_regression_test_history',
    regressionRunHistory: 'reorite_segmenter_v12_regression_run_history',
    history: 'reorite_segmenter_v12_word_history',
    g2pHistory: 'reorite_segmenter_v12_g2p_word_history',
    g2pPrefs: 'reorite_segmenter_v12_g2p_prefs'
  ,
    g2pAwsTtsHistory: 'reorite_segmenter_v12_g2p_aws_tts_history',
    g2pAwsTtsPrefs: 'reorite_segmenter_v12_g2p_aws_tts_prefs',
    g2pAwsTtsCreds: 'reorite_segmenter_v12_g2p_aws_tts_creds',
    detectHistory: 'reorite_segmenter_v12_detect_history',
    detectPrefs: 'reorite_segmenter_v12_detect_prefs',
    detectAmbiguous: 'reorite_segmenter_v12_detect_ambiguous_tokens',
    detectParticles: 'reorite_segmenter_v12_detect_particle_tokens',
    detectBlockHistory: 'reorite_segmenter_v12_detect_block_history',
    sttPrefs: 'reorite_segmenter_v12_stt_prefs',
    sttHistory: 'reorite_segmenter_v12_stt_history'
  };

  function saveToStorage(key, value){
    try{ localStorage.setItem(key, value); return true; }
    catch(_){ return false; }
  }

  function loadFromStorage(key){
    try{ return localStorage.getItem(key) || ''; }
    catch(_){ return ''; }
  }

  function loadHistory(){
    const raw = loadFromStorage(STORAGE_KEYS.history);
    if(!raw) return [];
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !Array.isArray(parsed.value)) return [];
    return parsed.value;
  }

  function saveHistory(items){
    return saveToStorage(STORAGE_KEYS.history, JSON.stringify(items || [], null, 2));
  }

  function addHistoryEntry(entry){
    const items = loadHistory();

    // De-dupe by word and segments string
    const sig = `${entry.word}::${segmentsToString(entry.segments)}`;
    const filtered = items.filter(x => `${x.word}::${segmentsToString(x.segments)}` !== sig);

    filtered.unshift(entry);
    const capped = filtered.slice(0, 200);
    saveHistory(capped);
  }



  // Regression test edit history
  function loadRegressionHistory(){
    const raw = loadFromStorage(STORAGE_KEYS.regressionHistory);
    if(!raw) return [];
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !Array.isArray(parsed.value)) return [];
    return parsed.value;
  }

  function saveRegressionHistory(items){
    return saveToStorage(STORAGE_KEYS.regressionHistory, JSON.stringify(items || [], null, 2));
  }

  function addRegressionHistoryEntry(entry){
    const items = loadRegressionHistory();
    items.unshift(entry);
    saveRegressionHistory(items.slice(0, 400));
  }


  // Regression run history
  function loadRegressionRunHistory(){
    const raw = loadFromStorage(STORAGE_KEYS.regressionRunHistory);
    if(!raw) return [];
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !Array.isArray(parsed.value)) return [];
    return parsed.value;
  }

  function saveRegressionRunHistory(items){
    return saveToStorage(STORAGE_KEYS.regressionRunHistory, JSON.stringify(items || [], null, 2));
  }

  function addRegressionRunHistoryEntry(entry){
    const items = loadRegressionRunHistory();
    items.unshift(entry);
    // cap to avoid localStorage bloat
    saveRegressionRunHistory(items.slice(0, 200));
  }

  function simpleHash(str){
    // FNV-1a 32-bit
    let h = 0x811c9dc5;
    for(let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
    }
    return ('00000000' + h.toString(16)).slice(-8);
  }

  // Segmenter V12 Logic
  const vowels = 'aeiouāēīōū';
  const diphthongs = [
    'aa','ae','ai','ao','au',
    'ea','ee','ei','eo','eu',
    'ia','ie','ii','io','iu',
    'oa','oe','oi','oo','ou',
    'ua','ue','ui','uo','uu',
    'āa','aā','āā','āe','āē','āi','aī','āī','āo','aō','āō','āu','aū','āū',
    'ēa','eā','ēā','ēe','ēē','ēi','eī','ēī','ēo','eō','ēō','ēu','eū','ēū',
    'īa','iā','īā','īe','īē','īi','iī','īī','īo','iō','īō','īu','iū','īū',
    'ōa','oā','ōā','ōe','ōē','ōi','oī','ōī','ōo','oō','ōō','ōu','oū','ōū',
    'ūa','uā','ūā','ūe','ūē','ūi','uī','ūī','ūo','aō','ūō','ūu','uū','ūū'
  ];

  function segmentSyllables(text, options = {}){
    const segments = [];
    let i = 0;
    const events = Array.isArray(options.events) ? options.events : null;
    const ctx = options.ctx || '';

    const hit = (id, meta={}) => {
      if(!events) return;
      events.push({ id, ctx, ...meta });
    };

    while(i < text.length){
      const digraph = text.slice(i, i + 2);
      if((digraph === 'ng' || digraph === 'wh') && i + 2 <= text.length){
        i += 2;
        if(i < text.length && vowels.includes(text[i])){
          if(i + 1 < text.length && diphthongs.includes(text.slice(i, i + 2))){
            hit('V8-S01', {at:i-2, value: digraph + text.slice(i, i+2)});
            segments.push(digraph + text.slice(i, i + 2));
            i += 2;
          } else {
            hit('V8-S01', {at:i-2, value: digraph + text[i]});
            segments.push(digraph + text[i]);
            i++;
          }
        } else {
          segments.push(digraph);
        }
        continue;
      }

      // Consonant followed by diphthong then a vowel
      if(!vowels.includes(text[i])){
        const cons = text[i];
        const v1 = text[i + 1];
        const v2 = text[i + 2];
        const v3 = text[i + 3];
        const pair = (v1 || '') + (v2 || '');

        if(vowels.includes(v1) && vowels.includes(v2) && diphthongs.includes(pair) && vowels.includes(v3)){
          hit('V8-S02', {at:i, value: cons + pair});
          segments.push(cons + pair);
          i += 3;
          continue;
        }

        if(vowels.includes(v1) && vowels.includes(v2) && diphthongs.includes(pair)){
          hit('V8-S03', {at:i, value: cons + pair});
          segments.push(cons + pair);
          i += 3;
          continue;
        }

        if(vowels.includes(v1)){
          hit('V8-S04', {at:i, value: cons + v1});
          segments.push(cons + v1);
          i += 2;
          continue;
        }
        hit('V8-S05', {at:i, value: cons});
        segments.push(cons);
        i++;
        continue;
      }

      const dip = text.slice(i, i + 2);
      if(diphthongs.includes(dip)){
        hit('V8-S06', {at:i, value: dip});
        segments.push(dip);
        i += 2;
        continue;
      }

      hit('V8-S06', {at:i, value: text[i]});
      segments.push(text[i]);
      i++;
    }

    return segments;
  }

  function dynamicSuffixSplitInstrumented(text){
    for(let i = 3; i <= 6; i++){
      const suffix = text.slice(-i);
      const middle = text.slice(0, -i);
      const testSeg = segmentSyllables(suffix);
      const hasDiph = testSeg.some(s => diphthongs.includes(s));
      if(testSeg.length <= 2 && hasDiph){
        return { middle, suffix, chosenLen: i, matched: true, testSeg };
      }
    }
    return { middle: text.slice(0, -3), suffix: text.slice(-3), chosenLen: 3, matched: false, testSeg: segmentSyllables(text.slice(-3)) };
  }

  function segmentWordCore(inputWord, options = {}){
    const trace = [];
    const ruleHits = [];
    const word = normalizeWord(inputWord);

    const hit = (id) => { ruleHits.push(id); };
    hit('V8-R01');
    const syllableEvents = [];

    if(!word){
      return { word:'', error:'empty', prefix:'', middle:'', suffix:'', middleSegments:[], suffixSegments:[], segments:[], trace, ruleIds:[] };
    }

    if(word.length < 2){
      return { word, prefix: word, middle:'', suffix:'', middleSegments:[], suffixSegments:[], segments:[word], trace, ruleIds:[] };
    }

    let prefix = '';
    if(word.startsWith('wh') || word.startsWith('ng')){
      prefix = word.slice(0, 3);
    } else {
      if(!vowels.includes(word[0]) && vowels.includes(word[1])){
        prefix = word.slice(0, 2);
      } else {
        prefix = word[0];
      }
    }
    hit('V8-R02');

    let remaining = word.slice(prefix.length);
    if(options.trace) trace.push({ step:'prefix_init', prefix, remaining });

    const prefixBeforeAdjust = prefix;
    if(remaining.length){
      const firstChar = remaining[0];
      if(vowels.includes(firstChar)){
        prefix += firstChar;
        remaining = remaining.slice(1);
        hit('V8-R03');
      }
    }

    if(options.trace) trace.push({ step:'prefix_adjust', prefix, remaining, prefixBeforeAdjust });

    const splitMeta = dynamicSuffixSplitInstrumented(remaining);
    let middle = splitMeta.middle;
    let suffix = splitMeta.suffix;
    hit('V8-R04');

    if(options.trace) trace.push({ step:'suffix_split', middle, suffix, chosenLen: splitMeta.chosenLen, matched: splitMeta.matched, testSeg: splitMeta.testSeg });

    const middleBeforeOrphan = middle;
    const suffixBeforeOrphan = suffix;

    if(middle && suffix){
      const lastMiddleChar = middle.slice(-1);
      if(vowels.includes(lastMiddleChar) && diphthongs.includes(lastMiddleChar + suffix[0])){
        middle = middle.slice(0, -1);
        suffix = lastMiddleChar + suffix;
        hit('V8-R05');
      }
    }

    if(options.trace) trace.push({ step:'orphan_vowel_fix', middle, suffix, middleBeforeOrphan, suffixBeforeOrphan });

    const middleBeforeBoundary = middle;
    const suffixBeforeBoundary = suffix;

    if(middle && suffix && suffix.length > 1 && vowels.includes(suffix[1])){
      if(middle.endsWith('n') && suffix.startsWith('g')){
        suffix = 'ng' + suffix.slice(1);
        middle = middle.slice(0, -1);
        hit('V8-R06');
      } else if(middle.endsWith('w') && suffix.startsWith('h')){
        suffix = 'wh' + suffix.slice(1);
        middle = middle.slice(0, -1);
        hit('V8-R06');
      }
    }

    if(options.trace) trace.push({ step:'boundary_digraph_fix', middle, suffix, middleBeforeBoundary, suffixBeforeBoundary });

    const middleBeforeShift = middle;
    const suffixBeforeShift = suffix;

    if(middle && suffix && vowels.includes(suffix[0]) && !vowels.includes(middle.slice(-1))){
      if(middle.slice(-2) === 'ng' || middle.slice(-2) === 'wh'){
        suffix = middle.slice(-2) + suffix;
        middle = middle.slice(0, -2);
        hit('V8-R07');
      } else {
        suffix = middle.slice(-1) + suffix;
        middle = middle.slice(0, -1);
        hit('V8-R07');
      }
    }

    if(options.trace) trace.push({ step:'consonant_shift_to_suffix', middle, suffix, middleBeforeShift, suffixBeforeShift });

    hit('V8-R08');
    const middleSegments = segmentSyllables(middle, { events: syllableEvents, ctx: 'middle' });
    hit('V8-R09');

    let suffixParts = [];

    const maybeDigraph = suffix.slice(0, 2);
    const firstVowel = suffix[2];
    const secondVowel = suffix[3];

    const s1 = suffix[0], s2 = suffix[1], s3 = suffix[2];
    if(vowels.includes(s1) && !vowels.includes(s2) && vowels.includes(s3)){
      hit('V8-R10');
      suffixParts = [s1 + s2 + s3];
      if(suffix.length > 3) suffixParts.push(...segmentSyllables(suffix.slice(3), { events: syllableEvents, ctx: 'suffix_tail' }));
    } else {
      suffixParts = segmentSyllables(suffix, { events: syllableEvents, ctx: 'suffix' });
    }

    if((maybeDigraph === 'ng' || maybeDigraph === 'wh') && vowels.includes(firstVowel) && vowels.includes(secondVowel)){
      const vv = firstVowel + secondVowel;
      if(diphthongs.includes(vv)){
        hit('V8-R11');
        suffixParts = [maybeDigraph + vv];
        if(suffix.length > 4) suffixParts.push(...segmentSyllables(suffix.slice(4), { events: syllableEvents, ctx: 'suffix_tail' }));
      } else {
        hit('V8-R11');
        suffixParts = [maybeDigraph + firstVowel, ...segmentSyllables(suffix.slice(3), { events: syllableEvents, ctx: 'suffix_tail' })];
      }
    } else if((maybeDigraph === 'ng' || maybeDigraph === 'wh') && diphthongs.includes(suffix.slice(2))){
      hit('V8-R12');
      suffixParts = [suffix];
    } else if((suffix.startsWith('ng') || suffix.startsWith('wh')) && suffix.length > 3){
      hit('V8-R13');
      const first = suffix.slice(0, 3);
      const rest = suffix.slice(3);
      suffixParts = [first, ...segmentSyllables(rest, { events: syllableEvents, ctx: 'suffix_tail' })];
    } else if(suffix.startsWith('ng') || suffix.startsWith('wh')){
      hit('V8-R14');
      suffixParts = [suffix];
    }

    hit('V8-R15');

    const segments = [prefix, ...middleSegments, ...suffixParts].filter(Boolean);

    const ruleIds = uniquePreserveOrder([...ruleHits, ...syllableEvents.map(e => e.id)]);

    if(options.trace){
      trace.push({ step:'segments_final', prefix, middle, suffix, middleSegments, suffixParts, segments, ruleIds });
    }

    return { word, prefix, middle, suffix, middleSegments, suffixSegments: suffixParts, segments, trace, ruleIds, syllableEvents };
  }



  // G2P Lexicon (Source: segment to IPA full v3 - lexicon.xlsx)
  // Columns: Unit, Proper IPA, Unit Number
  const LEXICON_ROWS = [{"unit": "Ngūū", "unit_norm": "ngūū", "ipa": "ŋˤŋuːuː", "unit_number": 1165}, {"unit": "Nguū", "unit_norm": "nguū", "ipa": "ŋˤŋʊːuː", "unit_number": 1164}, {"unit": "Ngūu", "unit_norm": "ngūu", "ipa": "ŋˤŋuːʊː", "unit_number": 1163}, {"unit": "Ngūō", "unit_norm": "ngūō", "ipa": "ŋˤŋuːɔːr", "unit_number": 1162}, {"unit": "Ngaō", "unit_norm": "ngaō", "ipa": "ŋˤŋɑɔːr", "unit_number": 1161}, {"unit": "Ngūo", "unit_norm": "ngūo", "ipa": "ŋˤŋuːɔː", "unit_number": 1160}, {"unit": "Ngūī", "unit_norm": "ngūī", "ipa": "ŋˤŋuːiːː", "unit_number": 1159}, {"unit": "Nguī", "unit_norm": "nguī", "ipa": "ŋˤŋʊːiːː", "unit_number": 1158}, {"unit": "Ngūi", "unit_norm": "ngūi", "ipa": "ŋˤŋuːiː", "unit_number": 1157}, {"unit": "Ngūē", "unit_norm": "ngūē", "ipa": "ŋˤŋuːɛː", "unit_number": 1156}, {"unit": "Ngūe", "unit_norm": "ngūe", "ipa": "ŋˤŋuːɛh", "unit_number": 1155}, {"unit": "Ngūā", "unit_norm": "ngūā", "ipa": "ŋˤŋuːɑːː", "unit_number": 1154}, {"unit": "Nguā", "unit_norm": "nguā", "ipa": "ŋˤŋʊːɑːː", "unit_number": 1153}, {"unit": "Ngūa", "unit_norm": "ngūa", "ipa": "ŋˤŋuːɑ", "unit_number": 1152}, {"unit": "Ngōū", "unit_norm": "ngōū", "ipa": "ŋˤŋɔːruː", "unit_number": 1151}, {"unit": "Ngoū", "unit_norm": "ngoū", "ipa": "ŋˤŋɔːuː", "unit_number": 1150}, {"unit": "Ngōu", "unit_norm": "ngōu", "ipa": "ŋˤŋɔːrʊː", "unit_number": 1149}, {"unit": "Ngōō", "unit_norm": "ngōō", "ipa": "ŋˤŋɔːrɔːr", "unit_number": 1148}, {"unit": "Ngoō", "unit_norm": "ngoō", "ipa": "ŋˤŋɔːɔːr", "unit_number": 1147}, {"unit": "Ngōo", "unit_norm": "ngōo", "ipa": "ŋˤŋɔːrɔː", "unit_number": 1146}, {"unit": "Ngōī", "unit_norm": "ngōī", "ipa": "ŋˤŋɔːriːː", "unit_number": 1145}, {"unit": "Ngoī", "unit_norm": "ngoī", "ipa": "ŋˤŋɔːiːː", "unit_number": 1144}, {"unit": "Ngōi", "unit_norm": "ngōi", "ipa": "ŋˤŋɔːriː", "unit_number": 1143}, {"unit": "Ngōē", "unit_norm": "ngōē", "ipa": "ŋˤŋɔːrɛː", "unit_number": 1142}, {"unit": "Ngōe", "unit_norm": "ngōe", "ipa": "ŋˤŋɔːrɛh", "unit_number": 1141}, {"unit": "Ngōā", "unit_norm": "ngōā", "ipa": "ŋˤŋɔːrɑːː", "unit_number": 1140}, {"unit": "Ngoā", "unit_norm": "ngoā", "ipa": "ŋˤŋɔːɑːː", "unit_number": 1139}, {"unit": "Ngōa", "unit_norm": "ngōa", "ipa": "ŋˤŋɔːrɑ", "unit_number": 1138}, {"unit": "Ngīū", "unit_norm": "ngīū", "ipa": "ŋˤŋiːːuː", "unit_number": 1137}, {"unit": "Ngiū", "unit_norm": "ngiū", "ipa": "ŋˤŋiːuː", "unit_number": 1136}, {"unit": "Ngīu", "unit_norm": "ngīu", "ipa": "ŋˤŋiːːʊː", "unit_number": 1135}, {"unit": "Ngīō", "unit_norm": "ngīō", "ipa": "ŋˤŋiːːɔːr", "unit_number": 1134}, {"unit": "Ngiō", "unit_norm": "ngiō", "ipa": "ŋˤŋiːɔːr", "unit_number": 1133}, {"unit": "Ngīo", "unit_norm": "ngīo", "ipa": "ŋˤŋiːːɔː", "unit_number": 1132}, {"unit": "Ngīī", "unit_norm": "ngīī", "ipa": "ŋˤŋiːːiːː", "unit_number": 1131}, {"unit": "Ngiī", "unit_norm": "ngiī", "ipa": "ŋˤŋiːiːː", "unit_number": 1130}, {"unit": "Ngīi", "unit_norm": "ngīi", "ipa": "ŋˤŋiːːiː", "unit_number": 1129}, {"unit": "Ngīē", "unit_norm": "ngīē", "ipa": "ŋˤŋiːːɛː", "unit_number": 1128}, {"unit": "Ngīe", "unit_norm": "ngīe", "ipa": "ŋˤŋiːːɛh", "unit_number": 1127}, {"unit": "Ngīā", "unit_norm": "ngīā", "ipa": "ŋˤŋiːːɑːː", "unit_number": 1126}, {"unit": "Ngiā", "unit_norm": "ngiā", "ipa": "ŋˤŋiːɑːː", "unit_number": 1125}, {"unit": "Ngīa", "unit_norm": "ngīa", "ipa": "ŋˤŋiːːɑ", "unit_number": 1124}, {"unit": "Ngēū", "unit_norm": "ngēū", "ipa": "ŋˤŋɛːuː", "unit_number": 1123}, {"unit": "Ngeū", "unit_norm": "ngeū", "ipa": "ŋˤŋɛhuː", "unit_number": 1122}, {"unit": "Ngēu", "unit_norm": "ngēu", "ipa": "ŋˤŋɛːʊː", "unit_number": 1121}, {"unit": "Ngēō", "unit_norm": "ngēō", "ipa": "ŋˤŋɛːɔːr", "unit_number": 1120}, {"unit": "Ngeō", "unit_norm": "ngeō", "ipa": "ŋˤŋɛhɔːr", "unit_number": 1119}, {"unit": "Ngēo", "unit_norm": "ngēo", "ipa": "ŋˤŋɛːɔː", "unit_number": 1118}, {"unit": "Ngēī", "unit_norm": "ngēī", "ipa": "ŋˤŋɛːiːː", "unit_number": 1117}, {"unit": "Ngeī", "unit_norm": "ngeī", "ipa": "ŋˤŋɛhiːː", "unit_number": 1116}, {"unit": "Ngēi", "unit_norm": "ngēi", "ipa": "ŋˤŋɛːiː", "unit_number": 1115}, {"unit": "Ngēē", "unit_norm": "ngēē", "ipa": "ŋˤŋɛːɛː", "unit_number": 1114}, {"unit": "Ngēe", "unit_norm": "ngēe", "ipa": "ŋˤŋɛːɛh", "unit_number": 1113}, {"unit": "Ngēā", "unit_norm": "ngēā", "ipa": "ŋˤŋɛːɑːː", "unit_number": 1112}, {"unit": "Ngeā", "unit_norm": "ngeā", "ipa": "ŋˤŋɛhɑːː", "unit_number": 1111}, {"unit": "Ngēa", "unit_norm": "ngēa", "ipa": "ŋˤŋɛːɑ", "unit_number": 1110}, {"unit": "Ngāū", "unit_norm": "ngāū", "ipa": "ŋˤŋɑːːuː", "unit_number": 1109}, {"unit": "Ngaū", "unit_norm": "ngaū", "ipa": "ŋˤŋɑuː", "unit_number": 1108}, {"unit": "Ngāu", "unit_norm": "ngāu", "ipa": "ŋˤŋɑːːʊː", "unit_number": 1107}, {"unit": "Ngāō", "unit_norm": "ngāō", "ipa": "ŋˤŋɑːːɔːr", "unit_number": 1106}, {"unit": "Ngaō", "unit_norm": "ngaō", "ipa": "ŋˤŋɑɔːr", "unit_number": 1105}, {"unit": "Ngāo", "unit_norm": "ngāo", "ipa": "ŋˤŋɑːːɔː", "unit_number": 1104}, {"unit": "Ngāī", "unit_norm": "ngāī", "ipa": "ŋˤŋɑːːiːː", "unit_number": 1103}, {"unit": "Ngaī", "unit_norm": "ngaī", "ipa": "ŋˤŋɑiːː", "unit_number": 1102}, {"unit": "Ngāi", "unit_norm": "ngāi", "ipa": "ŋˤŋɑːːiː", "unit_number": 1101}, {"unit": "Ngāē", "unit_norm": "ngāē", "ipa": "ŋˤŋɑːːɛː", "unit_number": 1100}, {"unit": "Ngāe", "unit_norm": "ngāe", "ipa": "ŋˤŋɑːːɛh", "unit_number": 1099}, {"unit": "Ngāā", "unit_norm": "ngāā", "ipa": "ŋˤŋɑːːɑːː", "unit_number": 1098}, {"unit": "Ngaā", "unit_norm": "ngaā", "ipa": "ŋˤŋɑɑːː", "unit_number": 1097}, {"unit": "Ngāa", "unit_norm": "ngāa", "ipa": "ŋˤŋɑːːɑ", "unit_number": 1096}, {"unit": "Nguu", "unit_norm": "nguu", "ipa": "ŋˤŋʊːʊː", "unit_number": 1095}, {"unit": "Nguo", "unit_norm": "nguo", "ipa": "ŋˤŋʊːɔː", "unit_number": 1094}, {"unit": "Ngui", "unit_norm": "ngui", "ipa": "ŋˤŋʊːiː", "unit_number": 1093}, {"unit": "Ngue", "unit_norm": "ngue", "ipa": "ŋˤŋʊːɛh", "unit_number": 1092}, {"unit": "Ngua", "unit_norm": "ngua", "ipa": "ŋˤŋʊːɑ", "unit_number": 1091}, {"unit": "Ngou", "unit_norm": "ngou", "ipa": "ŋˤŋɔːʊː", "unit_number": 1090}, {"unit": "Ngoo", "unit_norm": "ngoo", "ipa": "ŋˤŋɔːɔː", "unit_number": 1089}, {"unit": "Ngoi", "unit_norm": "ngoi", "ipa": "ŋˤŋɔːiː", "unit_number": 1088}, {"unit": "Ngoe", "unit_norm": "ngoe", "ipa": "ŋˤŋɔːɛh", "unit_number": 1087}, {"unit": "Ngoa", "unit_norm": "ngoa", "ipa": "ŋˤŋɔːɑ", "unit_number": 1086}, {"unit": "Ngiu", "unit_norm": "ngiu", "ipa": "ŋˤŋiːʊː", "unit_number": 1085}, {"unit": "Ngio", "unit_norm": "ngio", "ipa": "ŋˤŋiːɔː", "unit_number": 1084}, {"unit": "Ngii", "unit_norm": "ngii", "ipa": "ŋˤŋiːiː", "unit_number": 1083}, {"unit": "Ngie", "unit_norm": "ngie", "ipa": "ŋˤŋiːɛh", "unit_number": 1082}, {"unit": "Ngia", "unit_norm": "ngia", "ipa": "ŋˤŋiːɑ", "unit_number": 1081}, {"unit": "Ngeu", "unit_norm": "ngeu", "ipa": "ŋˤŋɛhʊː", "unit_number": 1080}, {"unit": "Ngeo", "unit_norm": "ngeo", "ipa": "ŋˤŋɛhɔː", "unit_number": 1079}, {"unit": "Ngei", "unit_norm": "ngei", "ipa": "ŋˤŋɛhiː", "unit_number": 1078}, {"unit": "Ngee", "unit_norm": "ngee", "ipa": "ŋˤŋɛhɛh", "unit_number": 1077}, {"unit": "Ngea", "unit_norm": "ngea", "ipa": "ŋˤŋɛhɑ", "unit_number": 1076}, {"unit": "Ngau", "unit_norm": "ngau", "ipa": "ŋˤŋɑʊː", "unit_number": 1075}, {"unit": "Ngao", "unit_norm": "ngao", "ipa": "ŋˤŋɑɔː", "unit_number": 1074}, {"unit": "Ngai", "unit_norm": "ngai", "ipa": "ŋˤŋɑiː", "unit_number": 1073}, {"unit": "Ngae", "unit_norm": "ngae", "ipa": "ŋˤŋɑɛh", "unit_number": 1072}, {"unit": "Ngaa", "unit_norm": "ngaa", "ipa": "ŋˤŋɑɑ", "unit_number": 1071}, {"unit": "Ngū", "unit_norm": "ngū", "ipa": "ŋˤŋuː", "unit_number": 1070}, {"unit": "Ngō", "unit_norm": "ngō", "ipa": "ŋˤŋɔːr", "unit_number": 1069}, {"unit": "Ngī", "unit_norm": "ngī", "ipa": "ŋˤŋiːː", "unit_number": 1068}, {"unit": "Ngē", "unit_norm": "ngē", "ipa": "ŋˤŋɛː", "unit_number": 1067}, {"unit": "Ngā", "unit_norm": "ngā", "ipa": "ŋˤŋɑːː", "unit_number": 1066}, {"unit": "Ngu", "unit_norm": "ngu", "ipa": "ŋˤŋʊː", "unit_number": 1065}, {"unit": "Ngo", "unit_norm": "ngo", "ipa": "ŋˤŋɔː", "unit_number": 1064}, {"unit": "Ngi", "unit_norm": "ngi", "ipa": "ŋˤŋiː", "unit_number": 1063}, {"unit": "Nge", "unit_norm": "nge", "ipa": "ŋˤŋɛh", "unit_number": 1062}, {"unit": "Nga", "unit_norm": "nga", "ipa": "ŋˤŋɑ", "unit_number": 1061}, {"unit": "Whūū", "unit_norm": "whūū", "ipa": "fuːuː", "unit_number": 1060}, {"unit": "Whuū", "unit_norm": "whuū", "ipa": "fʊːuː", "unit_number": 1059}, {"unit": "Whūu", "unit_norm": "whūu", "ipa": "fuːʊː", "unit_number": 1058}, {"unit": "Whūō", "unit_norm": "whūō", "ipa": "fuːɔːr", "unit_number": 1057}, {"unit": "Whaō", "unit_norm": "whaō", "ipa": "fɑɔːr", "unit_number": 1056}, {"unit": "Whūo", "unit_norm": "whūo", "ipa": "fuːɔː", "unit_number": 1055}, {"unit": "Whūī", "unit_norm": "whūī", "ipa": "fuːiːː", "unit_number": 1054}, {"unit": "Whuī", "unit_norm": "whuī", "ipa": "fʊːiːː", "unit_number": 1053}, {"unit": "Whūi", "unit_norm": "whūi", "ipa": "fuːiː", "unit_number": 1052}, {"unit": "Whūē", "unit_norm": "whūē", "ipa": "fuːɛː", "unit_number": 1051}, {"unit": "Whūe", "unit_norm": "whūe", "ipa": "fuːɛh", "unit_number": 1050}, {"unit": "Whūā", "unit_norm": "whūā", "ipa": "fuːɑːː", "unit_number": 1049}, {"unit": "Whuā", "unit_norm": "whuā", "ipa": "fʊːɑːː", "unit_number": 1048}, {"unit": "Whūa", "unit_norm": "whūa", "ipa": "fuːɑ", "unit_number": 1047}, {"unit": "Whōū", "unit_norm": "whōū", "ipa": "fɔːruː", "unit_number": 1046}, {"unit": "Whoū", "unit_norm": "whoū", "ipa": "fɔːuː", "unit_number": 1045}, {"unit": "Whōu", "unit_norm": "whōu", "ipa": "fɔːrʊː", "unit_number": 1044}, {"unit": "Whōō", "unit_norm": "whōō", "ipa": "fɔːrɔːr", "unit_number": 1043}, {"unit": "Whoō", "unit_norm": "whoō", "ipa": "fɔːɔːr", "unit_number": 1042}, {"unit": "Whōo", "unit_norm": "whōo", "ipa": "fɔːrɔː", "unit_number": 1041}, {"unit": "Whōī", "unit_norm": "whōī", "ipa": "fɔːriːː", "unit_number": 1040}, {"unit": "Whoī", "unit_norm": "whoī", "ipa": "fɔːiːː", "unit_number": 1039}, {"unit": "Whōi", "unit_norm": "whōi", "ipa": "fɔːriː", "unit_number": 1038}, {"unit": "Whōē", "unit_norm": "whōē", "ipa": "fɔːrɛː", "unit_number": 1037}, {"unit": "Whōe", "unit_norm": "whōe", "ipa": "fɔːrɛh", "unit_number": 1036}, {"unit": "Whōā", "unit_norm": "whōā", "ipa": "fɔːrɑːː", "unit_number": 1035}, {"unit": "Whoā", "unit_norm": "whoā", "ipa": "fɔːɑːː", "unit_number": 1034}, {"unit": "Whōa", "unit_norm": "whōa", "ipa": "fɔːrɑ", "unit_number": 1033}, {"unit": "Whīū", "unit_norm": "whīū", "ipa": "fiːːuː", "unit_number": 1032}, {"unit": "Whiū", "unit_norm": "whiū", "ipa": "fiːuː", "unit_number": 1031}, {"unit": "Whīu", "unit_norm": "whīu", "ipa": "fiːːʊː", "unit_number": 1030}, {"unit": "Whīō", "unit_norm": "whīō", "ipa": "fiːːɔːr", "unit_number": 1029}, {"unit": "Whiō", "unit_norm": "whiō", "ipa": "fiːɔːr", "unit_number": 1028}, {"unit": "Whīo", "unit_norm": "whīo", "ipa": "fiːːɔː", "unit_number": 1027}, {"unit": "Whīī", "unit_norm": "whīī", "ipa": "fiːːiːː", "unit_number": 1026}, {"unit": "Whiī", "unit_norm": "whiī", "ipa": "fiːiːː", "unit_number": 1025}, {"unit": "Whīi", "unit_norm": "whīi", "ipa": "fiːːiː", "unit_number": 1024}, {"unit": "Whīē", "unit_norm": "whīē", "ipa": "fiːːɛː", "unit_number": 1023}, {"unit": "Whīe", "unit_norm": "whīe", "ipa": "fiːːɛh", "unit_number": 1022}, {"unit": "Whīā", "unit_norm": "whīā", "ipa": "fiːːɑːː", "unit_number": 1021}, {"unit": "Whiā", "unit_norm": "whiā", "ipa": "fiːɑːː", "unit_number": 1020}, {"unit": "Whīa", "unit_norm": "whīa", "ipa": "fiːːɑ", "unit_number": 1019}, {"unit": "Whēū", "unit_norm": "whēū", "ipa": "fɛːuː", "unit_number": 1018}, {"unit": "Wheū", "unit_norm": "wheū", "ipa": "fɛhuː", "unit_number": 1017}, {"unit": "Whēu", "unit_norm": "whēu", "ipa": "fɛːʊː", "unit_number": 1016}, {"unit": "Whēō", "unit_norm": "whēō", "ipa": "fɛːɔːr", "unit_number": 1015}, {"unit": "Wheō", "unit_norm": "wheō", "ipa": "fɛhɔːr", "unit_number": 1014}, {"unit": "Whēo", "unit_norm": "whēo", "ipa": "fɛːɔː", "unit_number": 1013}, {"unit": "Whēī", "unit_norm": "whēī", "ipa": "fɛːiːː", "unit_number": 1012}, {"unit": "Wheī", "unit_norm": "wheī", "ipa": "fɛhiːː", "unit_number": 1011}, {"unit": "Whēi", "unit_norm": "whēi", "ipa": "fɛːiː", "unit_number": 1010}, {"unit": "Whēē", "unit_norm": "whēē", "ipa": "fɛːɛː", "unit_number": 1009}, {"unit": "Whēe", "unit_norm": "whēe", "ipa": "fɛːɛh", "unit_number": 1008}, {"unit": "Whēā", "unit_norm": "whēā", "ipa": "fɛːɑːː", "unit_number": 1007}, {"unit": "Wheā", "unit_norm": "wheā", "ipa": "fɛhɑːː", "unit_number": 1006}, {"unit": "Whēa", "unit_norm": "whēa", "ipa": "fɛːɑ", "unit_number": 1005}, {"unit": "Whāū", "unit_norm": "whāū", "ipa": "fɑːːuː", "unit_number": 1004}, {"unit": "Whaū", "unit_norm": "whaū", "ipa": "fɑuː", "unit_number": 1003}, {"unit": "Whāu", "unit_norm": "whāu", "ipa": "fɑːːʊː", "unit_number": 1002}, {"unit": "Whāō", "unit_norm": "whāō", "ipa": "fɑːːɔːr", "unit_number": 1001}, {"unit": "Whaō", "unit_norm": "whaō", "ipa": "fɑɔːr", "unit_number": 1000}, {"unit": "Whāo", "unit_norm": "whāo", "ipa": "fɑːːɔː", "unit_number": 999}, {"unit": "Whāī", "unit_norm": "whāī", "ipa": "fɑːːiːː", "unit_number": 998}, {"unit": "Whaī", "unit_norm": "whaī", "ipa": "fɑiːː", "unit_number": 997}, {"unit": "Whāi", "unit_norm": "whāi", "ipa": "fɑːːiː", "unit_number": 996}, {"unit": "Whāē", "unit_norm": "whāē", "ipa": "fɑːːɛː", "unit_number": 995}, {"unit": "Whāe", "unit_norm": "whāe", "ipa": "fɑːːɛh", "unit_number": 994}, {"unit": "Whāā", "unit_norm": "whāā", "ipa": "fɑːːɑːː", "unit_number": 993}, {"unit": "Whaā", "unit_norm": "whaā", "ipa": "fɑɑːː", "unit_number": 992}, {"unit": "Whāa", "unit_norm": "whāa", "ipa": "fɑːːɑ", "unit_number": 991}, {"unit": "Whuu", "unit_norm": "whuu", "ipa": "fʊːʊː", "unit_number": 990}, {"unit": "Whuo", "unit_norm": "whuo", "ipa": "fʊːɔː", "unit_number": 989}, {"unit": "Whui", "unit_norm": "whui", "ipa": "fʊːiː", "unit_number": 988}, {"unit": "Whue", "unit_norm": "whue", "ipa": "fʊːɛh", "unit_number": 987}, {"unit": "Whua", "unit_norm": "whua", "ipa": "fʊːɑ", "unit_number": 986}, {"unit": "Whou", "unit_norm": "whou", "ipa": "fɔːʊː", "unit_number": 985}, {"unit": "Whoo", "unit_norm": "whoo", "ipa": "fɔːɔː", "unit_number": 984}, {"unit": "Whoi", "unit_norm": "whoi", "ipa": "fɔːiː", "unit_number": 983}, {"unit": "Whoe", "unit_norm": "whoe", "ipa": "fɔːɛh", "unit_number": 982}, {"unit": "Whoa", "unit_norm": "whoa", "ipa": "fɔːɑ", "unit_number": 981}, {"unit": "Whiu", "unit_norm": "whiu", "ipa": "fiːʊː", "unit_number": 980}, {"unit": "Whio", "unit_norm": "whio", "ipa": "fiːɔː", "unit_number": 979}, {"unit": "Whii", "unit_norm": "whii", "ipa": "fiːiː", "unit_number": 978}, {"unit": "Whie", "unit_norm": "whie", "ipa": "fiːɛh", "unit_number": 977}, {"unit": "Whia", "unit_norm": "whia", "ipa": "fiːɑ", "unit_number": 976}, {"unit": "Wheu", "unit_norm": "wheu", "ipa": "fɛhʊː", "unit_number": 975}, {"unit": "Wheo", "unit_norm": "wheo", "ipa": "fɛhɔː", "unit_number": 974}, {"unit": "Whei", "unit_norm": "whei", "ipa": "fɛhiː", "unit_number": 973}, {"unit": "Whee", "unit_norm": "whee", "ipa": "fɛhɛh", "unit_number": 972}, {"unit": "Whea", "unit_norm": "whea", "ipa": "fɛhɑ", "unit_number": 971}, {"unit": "Whau", "unit_norm": "whau", "ipa": "fɑʊː", "unit_number": 970}, {"unit": "Whao", "unit_norm": "whao", "ipa": "fɑɔː", "unit_number": 969}, {"unit": "Whai", "unit_norm": "whai", "ipa": "fɑiː", "unit_number": 968}, {"unit": "Whae", "unit_norm": "whae", "ipa": "fɑɛh", "unit_number": 967}, {"unit": "Whaa", "unit_norm": "whaa", "ipa": "fɑɑ", "unit_number": 966}, {"unit": "Whū", "unit_norm": "whū", "ipa": "fuː", "unit_number": 965}, {"unit": "Whō", "unit_norm": "whō", "ipa": "fɔːr", "unit_number": 964}, {"unit": "Whī", "unit_norm": "whī", "ipa": "fiːː", "unit_number": 963}, {"unit": "Whē", "unit_norm": "whē", "ipa": "fɛː", "unit_number": 962}, {"unit": "Whā", "unit_norm": "whā", "ipa": "fɑːː", "unit_number": 961}, {"unit": "Whu", "unit_norm": "whu", "ipa": "fʊː", "unit_number": 960}, {"unit": "Who", "unit_norm": "who", "ipa": "fɔː", "unit_number": 959}, {"unit": "Whi", "unit_norm": "whi", "ipa": "fiː", "unit_number": 958}, {"unit": "Whe", "unit_norm": "whe", "ipa": "fɛh", "unit_number": 957}, {"unit": "Wha", "unit_norm": "wha", "ipa": "fɑ", "unit_number": 956}, {"unit": "Wūū", "unit_norm": "wūū", "ipa": "wuːuː", "unit_number": 955}, {"unit": "Wuū", "unit_norm": "wuū", "ipa": "wʊːuː", "unit_number": 954}, {"unit": "Wūu", "unit_norm": "wūu", "ipa": "wuːʊː", "unit_number": 953}, {"unit": "Wūō", "unit_norm": "wūō", "ipa": "wuːɔːr", "unit_number": 952}, {"unit": "Waō", "unit_norm": "waō", "ipa": "wɑɔːr", "unit_number": 951}, {"unit": "Wūo", "unit_norm": "wūo", "ipa": "wuːɔː", "unit_number": 950}, {"unit": "Wūī", "unit_norm": "wūī", "ipa": "wuːiːː", "unit_number": 949}, {"unit": "Wuī", "unit_norm": "wuī", "ipa": "wʊːiːː", "unit_number": 948}, {"unit": "Wūi", "unit_norm": "wūi", "ipa": "wuːiː", "unit_number": 947}, {"unit": "Wūē", "unit_norm": "wūē", "ipa": "wuːɛː", "unit_number": 946}, {"unit": "Wūe", "unit_norm": "wūe", "ipa": "wuːɛh", "unit_number": 945}, {"unit": "Wūā", "unit_norm": "wūā", "ipa": "wuːɑːː", "unit_number": 944}, {"unit": "Wuā", "unit_norm": "wuā", "ipa": "wʊːɑːː", "unit_number": 943}, {"unit": "Wūa", "unit_norm": "wūa", "ipa": "wuːɑ", "unit_number": 942}, {"unit": "Wōū", "unit_norm": "wōū", "ipa": "wɔːruː", "unit_number": 941}, {"unit": "Woū", "unit_norm": "woū", "ipa": "wɔːuː", "unit_number": 940}, {"unit": "Wōu", "unit_norm": "wōu", "ipa": "wɔːrʊː", "unit_number": 939}, {"unit": "Wōō", "unit_norm": "wōō", "ipa": "wɔːrɔːr", "unit_number": 938}, {"unit": "Woō", "unit_norm": "woō", "ipa": "wɔːɔːr", "unit_number": 937}, {"unit": "Wōo", "unit_norm": "wōo", "ipa": "wɔːrɔː", "unit_number": 936}, {"unit": "Wōī", "unit_norm": "wōī", "ipa": "wɔːriːː", "unit_number": 935}, {"unit": "Woī", "unit_norm": "woī", "ipa": "wɔːiːː", "unit_number": 934}, {"unit": "Wōi", "unit_norm": "wōi", "ipa": "wɔːriː", "unit_number": 933}, {"unit": "Wōē", "unit_norm": "wōē", "ipa": "wɔːrɛː", "unit_number": 932}, {"unit": "Wōe", "unit_norm": "wōe", "ipa": "wɔːrɛh", "unit_number": 931}, {"unit": "Wōā", "unit_norm": "wōā", "ipa": "wɔːrɑːː", "unit_number": 930}, {"unit": "Woā", "unit_norm": "woā", "ipa": "wɔːɑːː", "unit_number": 929}, {"unit": "Wōa", "unit_norm": "wōa", "ipa": "wɔːrɑ", "unit_number": 928}, {"unit": "Wīū", "unit_norm": "wīū", "ipa": "wiːːuː", "unit_number": 927}, {"unit": "Wiū", "unit_norm": "wiū", "ipa": "wiːuː", "unit_number": 926}, {"unit": "Wīu", "unit_norm": "wīu", "ipa": "wiːːʊː", "unit_number": 925}, {"unit": "Wīō", "unit_norm": "wīō", "ipa": "wiːːɔːr", "unit_number": 924}, {"unit": "Wiō", "unit_norm": "wiō", "ipa": "wiːɔːr", "unit_number": 923}, {"unit": "Wīo", "unit_norm": "wīo", "ipa": "wiːːɔː", "unit_number": 922}, {"unit": "Wīī", "unit_norm": "wīī", "ipa": "wiːːiːː", "unit_number": 921}, {"unit": "Wiī", "unit_norm": "wiī", "ipa": "wiːiːː", "unit_number": 920}, {"unit": "Wīi", "unit_norm": "wīi", "ipa": "wiːːiː", "unit_number": 919}, {"unit": "Wīē", "unit_norm": "wīē", "ipa": "wiːːɛː", "unit_number": 918}, {"unit": "Wīe", "unit_norm": "wīe", "ipa": "wiːːɛh", "unit_number": 917}, {"unit": "Wīā", "unit_norm": "wīā", "ipa": "wiːːɑːː", "unit_number": 916}, {"unit": "Wiā", "unit_norm": "wiā", "ipa": "wiːɑːː", "unit_number": 915}, {"unit": "Wīa", "unit_norm": "wīa", "ipa": "wiːːɑ", "unit_number": 914}, {"unit": "Wēū", "unit_norm": "wēū", "ipa": "wɛːuː", "unit_number": 913}, {"unit": "Weū", "unit_norm": "weū", "ipa": "wɛhuː", "unit_number": 912}, {"unit": "Wēu", "unit_norm": "wēu", "ipa": "wɛːʊː", "unit_number": 911}, {"unit": "Wēō", "unit_norm": "wēō", "ipa": "wɛːɔːr", "unit_number": 910}, {"unit": "Weō", "unit_norm": "weō", "ipa": "wɛhɔːr", "unit_number": 909}, {"unit": "Wēo", "unit_norm": "wēo", "ipa": "wɛːɔː", "unit_number": 908}, {"unit": "Wēī", "unit_norm": "wēī", "ipa": "wɛːiːː", "unit_number": 907}, {"unit": "Weī", "unit_norm": "weī", "ipa": "wɛhiːː", "unit_number": 906}, {"unit": "Wēi", "unit_norm": "wēi", "ipa": "wɛːiː", "unit_number": 905}, {"unit": "Wēē", "unit_norm": "wēē", "ipa": "wɛːɛː", "unit_number": 904}, {"unit": "Wēe", "unit_norm": "wēe", "ipa": "wɛːɛh", "unit_number": 903}, {"unit": "Wēā", "unit_norm": "wēā", "ipa": "wɛːɑːː", "unit_number": 902}, {"unit": "Weā", "unit_norm": "weā", "ipa": "wɛhɑːː", "unit_number": 901}, {"unit": "Wēa", "unit_norm": "wēa", "ipa": "wɛːɑ", "unit_number": 900}, {"unit": "Wāū", "unit_norm": "wāū", "ipa": "wɑːːuː", "unit_number": 899}, {"unit": "Waū", "unit_norm": "waū", "ipa": "wɑuː", "unit_number": 898}, {"unit": "Wāu", "unit_norm": "wāu", "ipa": "wɑːːʊː", "unit_number": 897}, {"unit": "Wāō", "unit_norm": "wāō", "ipa": "wɑːːɔːr", "unit_number": 896}, {"unit": "Waō", "unit_norm": "waō", "ipa": "wɑɔːr", "unit_number": 895}, {"unit": "Wāo", "unit_norm": "wāo", "ipa": "wɑːːɔː", "unit_number": 894}, {"unit": "Wāī", "unit_norm": "wāī", "ipa": "wɑːːiːː", "unit_number": 893}, {"unit": "Waī", "unit_norm": "waī", "ipa": "wɑiːː", "unit_number": 892}, {"unit": "Wāi", "unit_norm": "wāi", "ipa": "wɑːːiː", "unit_number": 891}, {"unit": "Wāē", "unit_norm": "wāē", "ipa": "wɑːːɛː", "unit_number": 890}, {"unit": "Wāe", "unit_norm": "wāe", "ipa": "wɑːːɛh", "unit_number": 889}, {"unit": "Wāā", "unit_norm": "wāā", "ipa": "wɑːːɑːː", "unit_number": 888}, {"unit": "Waā", "unit_norm": "waā", "ipa": "wɑɑːː", "unit_number": 887}, {"unit": "Wāa", "unit_norm": "wāa", "ipa": "wɑːːɑ", "unit_number": 886}, {"unit": "Wuu", "unit_norm": "wuu", "ipa": "wʊːʊː", "unit_number": 885}, {"unit": "Wuo", "unit_norm": "wuo", "ipa": "wʊːɔː", "unit_number": 884}, {"unit": "Wui", "unit_norm": "wui", "ipa": "wʊːiː", "unit_number": 883}, {"unit": "Wue", "unit_norm": "wue", "ipa": "wʊːɛh", "unit_number": 882}, {"unit": "Wua", "unit_norm": "wua", "ipa": "wʊːɑ", "unit_number": 881}, {"unit": "Wou", "unit_norm": "wou", "ipa": "wɔːʊː", "unit_number": 880}, {"unit": "Woo", "unit_norm": "woo", "ipa": "wɔːɔː", "unit_number": 879}, {"unit": "Woi", "unit_norm": "woi", "ipa": "wɔːiː", "unit_number": 878}, {"unit": "Woe", "unit_norm": "woe", "ipa": "wɔːɛh", "unit_number": 877}, {"unit": "Woa", "unit_norm": "woa", "ipa": "wɔːɑ", "unit_number": 876}, {"unit": "Wiu", "unit_norm": "wiu", "ipa": "wiːʊː", "unit_number": 875}, {"unit": "Wio", "unit_norm": "wio", "ipa": "wiːɔː", "unit_number": 874}, {"unit": "Wii", "unit_norm": "wii", "ipa": "wiːiː", "unit_number": 873}, {"unit": "Wie", "unit_norm": "wie", "ipa": "wiːɛh", "unit_number": 872}, {"unit": "Wia", "unit_norm": "wia", "ipa": "wiːɑ", "unit_number": 871}, {"unit": "Weu", "unit_norm": "weu", "ipa": "wɛhʊː", "unit_number": 870}, {"unit": "Weo", "unit_norm": "weo", "ipa": "wɛhɔː", "unit_number": 869}, {"unit": "Wei", "unit_norm": "wei", "ipa": "wɛhiː", "unit_number": 868}, {"unit": "Wee", "unit_norm": "wee", "ipa": "wɛhɛh", "unit_number": 867}, {"unit": "Wea", "unit_norm": "wea", "ipa": "wɛhɑ", "unit_number": 866}, {"unit": "Wau", "unit_norm": "wau", "ipa": "wɑʊː", "unit_number": 865}, {"unit": "Wao", "unit_norm": "wao", "ipa": "wɑɔː", "unit_number": 864}, {"unit": "Wai", "unit_norm": "wai", "ipa": "wɑiː", "unit_number": 863}, {"unit": "Wae", "unit_norm": "wae", "ipa": "wɑɛh", "unit_number": 862}, {"unit": "Waa", "unit_norm": "waa", "ipa": "wɑɑ", "unit_number": 861}, {"unit": "Wū", "unit_norm": "wū", "ipa": "wuː", "unit_number": 860}, {"unit": "Wō", "unit_norm": "wō", "ipa": "wɔːr", "unit_number": 859}, {"unit": "Wī", "unit_norm": "wī", "ipa": "wiːː", "unit_number": 858}, {"unit": "Wē", "unit_norm": "wē", "ipa": "wɛː", "unit_number": 857}, {"unit": "Wā", "unit_norm": "wā", "ipa": "wɑːː", "unit_number": 856}, {"unit": "Wu", "unit_norm": "wu", "ipa": "wʊː", "unit_number": 855}, {"unit": "Wo", "unit_norm": "wo", "ipa": "wɔː", "unit_number": 854}, {"unit": "Wi", "unit_norm": "wi", "ipa": "wiː", "unit_number": 853}, {"unit": "We", "unit_norm": "we", "ipa": "wɛh", "unit_number": 852}, {"unit": "Wa", "unit_norm": "wa", "ipa": "wɑ", "unit_number": 851}, {"unit": "Tūū", "unit_norm": "tūū", "ipa": "tuːuː", "unit_number": 850}, {"unit": "Tuū", "unit_norm": "tuū", "ipa": "tʊːuː", "unit_number": 849}, {"unit": "Tūu", "unit_norm": "tūu", "ipa": "tuːʊː", "unit_number": 848}, {"unit": "Tūō", "unit_norm": "tūō", "ipa": "tuːɔːr", "unit_number": 847}, {"unit": "Taō", "unit_norm": "taō", "ipa": "tɑɔːr", "unit_number": 846}, {"unit": "Tūo", "unit_norm": "tūo", "ipa": "tuːɔː", "unit_number": 845}, {"unit": "Tūī", "unit_norm": "tūī", "ipa": "tuːiːː", "unit_number": 844}, {"unit": "Tuī", "unit_norm": "tuī", "ipa": "tʊːiːː", "unit_number": 843}, {"unit": "Tūi", "unit_norm": "tūi", "ipa": "tuːiː", "unit_number": 842}, {"unit": "Tūē", "unit_norm": "tūē", "ipa": "tuːɛː", "unit_number": 841}, {"unit": "Tūe", "unit_norm": "tūe", "ipa": "tuːɛh", "unit_number": 840}, {"unit": "Tūā", "unit_norm": "tūā", "ipa": "tuːɑːː", "unit_number": 839}, {"unit": "Tuā", "unit_norm": "tuā", "ipa": "tʊːɑːː", "unit_number": 838}, {"unit": "Tūa", "unit_norm": "tūa", "ipa": "tuːɑ", "unit_number": 837}, {"unit": "Tōū", "unit_norm": "tōū", "ipa": "tɔːruː", "unit_number": 836}, {"unit": "Toū", "unit_norm": "toū", "ipa": "tɔːuː", "unit_number": 835}, {"unit": "Tōu", "unit_norm": "tōu", "ipa": "tɔːrʊː", "unit_number": 834}, {"unit": "Tōō", "unit_norm": "tōō", "ipa": "tɔːrɔːr", "unit_number": 833}, {"unit": "Toō", "unit_norm": "toō", "ipa": "tɔːɔːr", "unit_number": 832}, {"unit": "Tōo", "unit_norm": "tōo", "ipa": "tɔːrɔː", "unit_number": 831}, {"unit": "Tōī", "unit_norm": "tōī", "ipa": "tɔːriːː", "unit_number": 830}, {"unit": "Toī", "unit_norm": "toī", "ipa": "tɔːiːː", "unit_number": 829}, {"unit": "Tōi", "unit_norm": "tōi", "ipa": "tɔːriː", "unit_number": 828}, {"unit": "Tōē", "unit_norm": "tōē", "ipa": "tɔːrɛː", "unit_number": 827}, {"unit": "Tōe", "unit_norm": "tōe", "ipa": "tɔːrɛh", "unit_number": 826}, {"unit": "Tōā", "unit_norm": "tōā", "ipa": "tɔːrɑːː", "unit_number": 825}, {"unit": "Toā", "unit_norm": "toā", "ipa": "tɔːɑːː", "unit_number": 824}, {"unit": "Tōa", "unit_norm": "tōa", "ipa": "tɔːrɑ", "unit_number": 823}, {"unit": "Tīū", "unit_norm": "tīū", "ipa": "tiːːuː", "unit_number": 822}, {"unit": "Tiū", "unit_norm": "tiū", "ipa": "tiːuː", "unit_number": 821}, {"unit": "Tīu", "unit_norm": "tīu", "ipa": "tiːːʊː", "unit_number": 820}, {"unit": "Tīō", "unit_norm": "tīō", "ipa": "tiːːɔːr", "unit_number": 819}, {"unit": "Tiō", "unit_norm": "tiō", "ipa": "tiːɔːr", "unit_number": 818}, {"unit": "Tīo", "unit_norm": "tīo", "ipa": "tiːːɔː", "unit_number": 817}, {"unit": "Tīī", "unit_norm": "tīī", "ipa": "tiːːiːː", "unit_number": 816}, {"unit": "Tiī", "unit_norm": "tiī", "ipa": "tiːiːː", "unit_number": 815}, {"unit": "Tīi", "unit_norm": "tīi", "ipa": "tiːːiː", "unit_number": 814}, {"unit": "Tīē", "unit_norm": "tīē", "ipa": "tiːːɛː", "unit_number": 813}, {"unit": "Tīe", "unit_norm": "tīe", "ipa": "tiːːɛh", "unit_number": 812}, {"unit": "Tīā", "unit_norm": "tīā", "ipa": "tiːːɑːː", "unit_number": 811}, {"unit": "Tiā", "unit_norm": "tiā", "ipa": "tiːɑːː", "unit_number": 810}, {"unit": "Tīa", "unit_norm": "tīa", "ipa": "tiːːɑ", "unit_number": 809}, {"unit": "Tēū", "unit_norm": "tēū", "ipa": "tɛːuː", "unit_number": 808}, {"unit": "Teū", "unit_norm": "teū", "ipa": "tɛhuː", "unit_number": 807}, {"unit": "Tēu", "unit_norm": "tēu", "ipa": "tɛːʊː", "unit_number": 806}, {"unit": "Tēō", "unit_norm": "tēō", "ipa": "tɛːɔːr", "unit_number": 805}, {"unit": "Teō", "unit_norm": "teō", "ipa": "tɛhɔːr", "unit_number": 804}, {"unit": "Tēo", "unit_norm": "tēo", "ipa": "tɛːɔː", "unit_number": 803}, {"unit": "Tēī", "unit_norm": "tēī", "ipa": "tɛːiːː", "unit_number": 802}, {"unit": "Teī", "unit_norm": "teī", "ipa": "tɛhiːː", "unit_number": 801}, {"unit": "Tēi", "unit_norm": "tēi", "ipa": "tɛːiː", "unit_number": 800}, {"unit": "Tēē", "unit_norm": "tēē", "ipa": "tɛːɛː", "unit_number": 799}, {"unit": "Tēe", "unit_norm": "tēe", "ipa": "tɛːɛh", "unit_number": 798}, {"unit": "Tēā", "unit_norm": "tēā", "ipa": "tɛːɑːː", "unit_number": 797}, {"unit": "Teā", "unit_norm": "teā", "ipa": "tɛhɑːː", "unit_number": 796}, {"unit": "Tēa", "unit_norm": "tēa", "ipa": "tɛːɑ", "unit_number": 795}, {"unit": "Tāū", "unit_norm": "tāū", "ipa": "tɑːːuː", "unit_number": 794}, {"unit": "Taū", "unit_norm": "taū", "ipa": "tɑuː", "unit_number": 793}, {"unit": "Tāu", "unit_norm": "tāu", "ipa": "tɑːːʊː", "unit_number": 792}, {"unit": "Tāō", "unit_norm": "tāō", "ipa": "tɑːːɔːr", "unit_number": 791}, {"unit": "Taō", "unit_norm": "taō", "ipa": "tɑɔːr", "unit_number": 790}, {"unit": "Tāo", "unit_norm": "tāo", "ipa": "tɑːːɔː", "unit_number": 789}, {"unit": "Tāī", "unit_norm": "tāī", "ipa": "tɑːːiːː", "unit_number": 788}, {"unit": "Taī", "unit_norm": "taī", "ipa": "tɑiːː", "unit_number": 787}, {"unit": "Tāi", "unit_norm": "tāi", "ipa": "tɑːːiː", "unit_number": 786}, {"unit": "Tāē", "unit_norm": "tāē", "ipa": "tɑːːɛː", "unit_number": 785}, {"unit": "Tāe", "unit_norm": "tāe", "ipa": "tɑːːɛh", "unit_number": 784}, {"unit": "Tāā", "unit_norm": "tāā", "ipa": "tɑːːɑːː", "unit_number": 783}, {"unit": "Taā", "unit_norm": "taā", "ipa": "tɑɑːː", "unit_number": 782}, {"unit": "Tāa", "unit_norm": "tāa", "ipa": "tɑːːɑ", "unit_number": 781}, {"unit": "Tuu", "unit_norm": "tuu", "ipa": "tʊːʊː", "unit_number": 780}, {"unit": "Tuo", "unit_norm": "tuo", "ipa": "tʊːɔː", "unit_number": 779}, {"unit": "Tui", "unit_norm": "tui", "ipa": "tʊːiː", "unit_number": 778}, {"unit": "Tue", "unit_norm": "tue", "ipa": "tʊːɛh", "unit_number": 777}, {"unit": "Tua", "unit_norm": "tua", "ipa": "tʊːɑ", "unit_number": 776}, {"unit": "Tou", "unit_norm": "tou", "ipa": "tɔːʊː", "unit_number": 775}, {"unit": "Too", "unit_norm": "too", "ipa": "tɔːɔː", "unit_number": 774}, {"unit": "Toi", "unit_norm": "toi", "ipa": "tɔːiː", "unit_number": 773}, {"unit": "Toe", "unit_norm": "toe", "ipa": "tɔːɛh", "unit_number": 772}, {"unit": "Toa", "unit_norm": "toa", "ipa": "tɔːɑ", "unit_number": 771}, {"unit": "Tiu", "unit_norm": "tiu", "ipa": "tiːʊː", "unit_number": 770}, {"unit": "Tio", "unit_norm": "tio", "ipa": "tiːɔː", "unit_number": 769}, {"unit": "Tii", "unit_norm": "tii", "ipa": "tiːiː", "unit_number": 768}, {"unit": "Tie", "unit_norm": "tie", "ipa": "tiːɛh", "unit_number": 767}, {"unit": "Tia", "unit_norm": "tia", "ipa": "tiːɑ", "unit_number": 766}, {"unit": "Teu", "unit_norm": "teu", "ipa": "tɛhʊː", "unit_number": 765}, {"unit": "Teo", "unit_norm": "teo", "ipa": "tɛhɔː", "unit_number": 764}, {"unit": "Tei", "unit_norm": "tei", "ipa": "tɛhiː", "unit_number": 763}, {"unit": "Tee", "unit_norm": "tee", "ipa": "tɛhɛh", "unit_number": 762}, {"unit": "Tea", "unit_norm": "tea", "ipa": "tɛhɑ", "unit_number": 761}, {"unit": "Tau", "unit_norm": "tau", "ipa": "tɑʊː", "unit_number": 760}, {"unit": "Tao", "unit_norm": "tao", "ipa": "tɑɔː", "unit_number": 759}, {"unit": "Tai", "unit_norm": "tai", "ipa": "tɑiː", "unit_number": 758}, {"unit": "Tae", "unit_norm": "tae", "ipa": "tɑɛh", "unit_number": 757}, {"unit": "Taa", "unit_norm": "taa", "ipa": "tɑɑ", "unit_number": 756}, {"unit": "Tū", "unit_norm": "tū", "ipa": "tuː", "unit_number": 755}, {"unit": "Tō", "unit_norm": "tō", "ipa": "tɔːr", "unit_number": 754}, {"unit": "Tī", "unit_norm": "tī", "ipa": "tiːː", "unit_number": 753}, {"unit": "Tē", "unit_norm": "tē", "ipa": "tɛː", "unit_number": 752}, {"unit": "Tā", "unit_norm": "tā", "ipa": "tɑːː", "unit_number": 751}, {"unit": "Tu", "unit_norm": "tu", "ipa": "tʊː", "unit_number": 750}, {"unit": "To", "unit_norm": "to", "ipa": "tɔː", "unit_number": 749}, {"unit": "Ti", "unit_norm": "ti", "ipa": "tiː", "unit_number": 748}, {"unit": "Te", "unit_norm": "te", "ipa": "tɛh", "unit_number": 747}, {"unit": "Ta", "unit_norm": "ta", "ipa": "tɑ", "unit_number": 746}, {"unit": "Rūū", "unit_norm": "rūū", "ipa": ".ɾ͡du̞ːu̞ː", "unit_number": 745}, {"unit": "Ruū", "unit_norm": "ruū", "ipa": ".ɾ͡dʊ̞ːu̞ː", "unit_number": 744}, {"unit": "Rūu", "unit_norm": "rūu", "ipa": ".ɾ͡du̞ːʊ̞ː", "unit_number": 743}, {"unit": "Rūō", "unit_norm": "rūō", "ipa": ".ɾ͡du̞ːɔ̞ːr", "unit_number": 742}, {"unit": "Raō", "unit_norm": "raō", "ipa": ".ɾ͡dɑ̞ɔ̞ːr", "unit_number": 741}, {"unit": "Rūo", "unit_norm": "rūo", "ipa": ".ɾ͡du̞ːɔ̞ː", "unit_number": 740}, {"unit": "Rūī", "unit_norm": "rūī", "ipa": ".ɾ͡du̞ːi̞ːː", "unit_number": 739}, {"unit": "Ruī", "unit_norm": "ruī", "ipa": ".ɾ͡dʊ̞ːi̞ːː", "unit_number": 738}, {"unit": "Rūi", "unit_norm": "rūi", "ipa": ".ɾ͡du̞ːi̞ː", "unit_number": 737}, {"unit": "Rūē", "unit_norm": "rūē", "ipa": ".ɾ͡du̞ːɛ̞ː", "unit_number": 736}, {"unit": "Rūe", "unit_norm": "rūe", "ipa": ".ɾ͡du̞ːɛ̞h", "unit_number": 735}, {"unit": "Rūā", "unit_norm": "rūā", "ipa": ".ɾ͡du̞ːɑːː", "unit_number": 734}, {"unit": "Ruā", "unit_norm": "ruā", "ipa": ".ɾ͡dʊ̞ːɑːː", "unit_number": 733}, {"unit": "Rūa", "unit_norm": "rūa", "ipa": ".ɾ͡du̞ːɑ̞", "unit_number": 732}, {"unit": "Rōū", "unit_norm": "rōū", "ipa": ".ɾ͡dɔ̞ːru̞ː", "unit_number": 731}, {"unit": "Roū", "unit_norm": "roū", "ipa": ".ɾ͡dɔ̞ːu̞ː", "unit_number": 730}, {"unit": "Rōu", "unit_norm": "rōu", "ipa": ".ɾ͡dɔ̞ːrʊ̞ː", "unit_number": 729}, {"unit": "Rōō", "unit_norm": "rōō", "ipa": ".ɾ͡dɔ̞ːrɔ̞ːr", "unit_number": 728}, {"unit": "Roō", "unit_norm": "roō", "ipa": ".ɾ͡dɔ̞ːɔ̞ːr", "unit_number": 727}, {"unit": "Rōo", "unit_norm": "rōo", "ipa": ".ɾ͡dɔ̞ːrɔ̞ː", "unit_number": 726}, {"unit": "Rōī", "unit_norm": "rōī", "ipa": ".ɾ͡dɔ̞ːri̞ːː", "unit_number": 725}, {"unit": "Roī", "unit_norm": "roī", "ipa": ".ɾ͡dɔ̞ːi̞ːː", "unit_number": 724}, {"unit": "Rōi", "unit_norm": "rōi", "ipa": ".ɾ͡dɔ̞ːri̞ː", "unit_number": 723}, {"unit": "Rōē", "unit_norm": "rōē", "ipa": ".ɾ͡dɔ̞ːrɛ̞ː", "unit_number": 722}, {"unit": "Rōe", "unit_norm": "rōe", "ipa": ".ɾ͡dɔ̞ːrɛ̞h", "unit_number": 721}, {"unit": "Rōā", "unit_norm": "rōā", "ipa": ".ɾ͡dɔ̞ːrɑːː", "unit_number": 720}, {"unit": "Roā", "unit_norm": "roā", "ipa": ".ɾ͡dɔ̞ːɑːː", "unit_number": 719}, {"unit": "Rōa", "unit_norm": "rōa", "ipa": ".ɾ͡dɔ̞ːrɑ̞", "unit_number": 718}, {"unit": "Rīū", "unit_norm": "rīū", "ipa": ".ɾ͡di̞ːːu̞ː", "unit_number": 717}, {"unit": "Riū", "unit_norm": "riū", "ipa": ".ɾ͡di̞ːu̞ː", "unit_number": 716}, {"unit": "Rīu", "unit_norm": "rīu", "ipa": ".ɾ͡di̞ːːʊ̞ː", "unit_number": 715}, {"unit": "Rīō", "unit_norm": "rīō", "ipa": ".ɾ͡di̞ːːɔ̞ːr", "unit_number": 714}, {"unit": "Riō", "unit_norm": "riō", "ipa": ".ɾ͡di̞ːɔ̞ːr", "unit_number": 713}, {"unit": "Rīo", "unit_norm": "rīo", "ipa": ".ɾ͡di̞ːːɔ̞ː", "unit_number": 712}, {"unit": "Rīī", "unit_norm": "rīī", "ipa": ".ɾ͡di̞ːːi̞ːː", "unit_number": 711}, {"unit": "Riī", "unit_norm": "riī", "ipa": ".ɾ͡di̞ːi̞ːː", "unit_number": 710}, {"unit": "Rīi", "unit_norm": "rīi", "ipa": ".ɾ͡di̞ːːi̞ː", "unit_number": 709}, {"unit": "Rīē", "unit_norm": "rīē", "ipa": ".ɾ͡di̞ːːɛ̞ː", "unit_number": 708}, {"unit": "Rīe", "unit_norm": "rīe", "ipa": ".ɾ͡di̞ːːɛ̞h", "unit_number": 707}, {"unit": "Rīā", "unit_norm": "rīā", "ipa": ".ɾ͡di̞ːːɑːː", "unit_number": 706}, {"unit": "Riā", "unit_norm": "riā", "ipa": ".ɾ͡di̞ːɑːː", "unit_number": 705}, {"unit": "Rīa", "unit_norm": "rīa", "ipa": ".ɾ͡di̞ːːɑ̞", "unit_number": 704}, {"unit": "Rēū", "unit_norm": "rēū", "ipa": ".ɾ͡dɛ̞ːu̞ː", "unit_number": 703}, {"unit": "Reū", "unit_norm": "reū", "ipa": ".ɾ͡dɛ̞hu̞ː", "unit_number": 702}, {"unit": "Rēu", "unit_norm": "rēu", "ipa": ".ɾ͡dɛ̞ːʊ̞ː", "unit_number": 701}, {"unit": "Rēō", "unit_norm": "rēō", "ipa": ".ɾ͡dɛ̞ːɔ̞ːr", "unit_number": 700}, {"unit": "Reō", "unit_norm": "reō", "ipa": ".ɾ͡dɛ̞hɔ̞ːr", "unit_number": 699}, {"unit": "Rēo", "unit_norm": "rēo", "ipa": ".ɾ͡dɛ̞ːɔ̞ː", "unit_number": 698}, {"unit": "Rēī", "unit_norm": "rēī", "ipa": ".ɾ͡dɛ̞ːi̞ːː", "unit_number": 697}, {"unit": "Reī", "unit_norm": "reī", "ipa": ".ɾ͡dɛ̞hi̞ːː", "unit_number": 696}, {"unit": "Rēi", "unit_norm": "rēi", "ipa": ".ɾ͡dɛ̞ːi̞ː", "unit_number": 695}, {"unit": "Rēē", "unit_norm": "rēē", "ipa": ".ɾ͡dɛ̞ːɛ̞ː", "unit_number": 694}, {"unit": "Rēe", "unit_norm": "rēe", "ipa": ".ɾ͡dɛ̞ːɛ̞h", "unit_number": 693}, {"unit": "Rēā", "unit_norm": "rēā", "ipa": ".ɾ͡dɛ̞ːɑːː", "unit_number": 692}, {"unit": "Reā", "unit_norm": "reā", "ipa": ".ɾ͡dɛ̞hɑːː", "unit_number": 691}, {"unit": "Rēa", "unit_norm": "rēa", "ipa": ".ɾ͡dɛ̞ːɑ̞", "unit_number": 690}, {"unit": "Rāū", "unit_norm": "rāū", "ipa": ".ɾ͡dɑːːu̞ː", "unit_number": 689}, {"unit": "Raū", "unit_norm": "raū", "ipa": ".ɾ͡dɑ̞u̞ː", "unit_number": 688}, {"unit": "Rāu", "unit_norm": "rāu", "ipa": ".ɾ͡dɑːːʊ̞ː", "unit_number": 687}, {"unit": "Rāō", "unit_norm": "rāō", "ipa": ".ɾ͡dɑːːɔ̞ːr", "unit_number": 686}, {"unit": "Raō", "unit_norm": "raō", "ipa": ".ɾ͡dɑ̞ɔ̞ːr", "unit_number": 685}, {"unit": "Rāo", "unit_norm": "rāo", "ipa": ".ɾ͡dɑːːɔ̞ː", "unit_number": 684}, {"unit": "Rāī", "unit_norm": "rāī", "ipa": ".ɾ͡dɑːːi̞ːː", "unit_number": 683}, {"unit": "Raī", "unit_norm": "raī", "ipa": ".ɾ͡dɑ̞i̞ːː", "unit_number": 682}, {"unit": "Rāi", "unit_norm": "rāi", "ipa": ".ɾ͡dɑːːi̞ː", "unit_number": 681}, {"unit": "Rāē", "unit_norm": "rāē", "ipa": ".ɾ͡dɑːːɛ̞ː", "unit_number": 680}, {"unit": "Rāe", "unit_norm": "rāe", "ipa": ".ɾ͡dɑːːɛ̞h", "unit_number": 679}, {"unit": "Rāā", "unit_norm": "rāā", "ipa": ".ɾ͡dɑːːɑːː", "unit_number": 678}, {"unit": "Raā", "unit_norm": "raā", "ipa": ".ɾ͡dɑ̞ɑːː", "unit_number": 677}, {"unit": "Rāa", "unit_norm": "rāa", "ipa": ".ɾ͡dɑːːɑ̞", "unit_number": 676}, {"unit": "Ruu", "unit_norm": "ruu", "ipa": ".ɾ͡dʊ̞ːʊ̞ː", "unit_number": 675}, {"unit": "Ruo", "unit_norm": "ruo", "ipa": ".ɾ͡dʊ̞ːɔ̞ː", "unit_number": 674}, {"unit": "Rui", "unit_norm": "rui", "ipa": ".ɾ͡dʊ̞ːi̞ː", "unit_number": 673}, {"unit": "Rue", "unit_norm": "rue", "ipa": ".ɾ͡dʊ̞ːɛ̞h", "unit_number": 672}, {"unit": "Rua", "unit_norm": "rua", "ipa": ".ɾ͡dʊ̞ːɑ̞", "unit_number": 671}, {"unit": "Rou", "unit_norm": "rou", "ipa": ".ɾ͡dɔ̞ːʊ̞ː", "unit_number": 670}, {"unit": "Roo", "unit_norm": "roo", "ipa": ".ɾ͡dɔ̞ːɔ̞ː", "unit_number": 669}, {"unit": "Roi", "unit_norm": "roi", "ipa": ".ɾ͡dɔ̞ːi̞ː", "unit_number": 668}, {"unit": "Roe", "unit_norm": "roe", "ipa": ".ɾ͡dɔ̞ːɛ̞h", "unit_number": 667}, {"unit": "Roa", "unit_norm": "roa", "ipa": ".ɾ͡dɔ̞ːɑ̞", "unit_number": 666}, {"unit": "Riu", "unit_norm": "riu", "ipa": ".ɾ͡di̞ːʊ̞ː", "unit_number": 665}, {"unit": "Rio", "unit_norm": "rio", "ipa": ".ɾ͡di̞ːɔ̞ː", "unit_number": 664}, {"unit": "Rii", "unit_norm": "rii", "ipa": ".ɾ͡di̞ːi̞ː", "unit_number": 663}, {"unit": "Rie", "unit_norm": "rie", "ipa": ".ɾ͡di̞ːɛ̞h", "unit_number": 662}, {"unit": "Ria", "unit_norm": "ria", "ipa": ".ɾ͡di̞ːɑ̞", "unit_number": 661}, {"unit": "Reu", "unit_norm": "reu", "ipa": ".ɾ͡dɛ̞hʊ̞ː", "unit_number": 660}, {"unit": "Reo", "unit_norm": "reo", "ipa": ".ɾ͡dɛ̞hɔ̞ː", "unit_number": 659}, {"unit": "Rei", "unit_norm": "rei", "ipa": ".ɾ͡dɛ̞hi̞ː", "unit_number": 658}, {"unit": "Ree", "unit_norm": "ree", "ipa": ".ɾ͡dɛ̞hɛ̞h", "unit_number": 657}, {"unit": "Rea", "unit_norm": "rea", "ipa": ".ɾ͡dɛ̞hɑ̞", "unit_number": 656}, {"unit": "Rau", "unit_norm": "rau", "ipa": ".ɾ͡dɑ̞ʊ̞ː", "unit_number": 655}, {"unit": "Rao", "unit_norm": "rao", "ipa": ".ɾ͡dɑ̞ɔ̞ː", "unit_number": 654}, {"unit": "Rai", "unit_norm": "rai", "ipa": ".ɾ͡dɑ̞i̞ː", "unit_number": 653}, {"unit": "Rae", "unit_norm": "rae", "ipa": ".ɾ͡dɑ̞ɛ̞h", "unit_number": 652}, {"unit": "Raa", "unit_norm": "raa", "ipa": ".ɾ͡dɑ̞ɑ̞", "unit_number": 651}, {"unit": "Rū", "unit_norm": "rū", "ipa": ".ɾ͡du̞ː", "unit_number": 650}, {"unit": "Rō", "unit_norm": "rō", "ipa": ".ɾ͡dɔ̞ːr", "unit_number": 649}, {"unit": "Rī", "unit_norm": "rī", "ipa": ".ɾ͡di̞ːː", "unit_number": 648}, {"unit": "Rē", "unit_norm": "rē", "ipa": ".ɾ͡dɛ̞ː", "unit_number": 647}, {"unit": "Rā", "unit_norm": "rā", "ipa": ".ɾ͡dɑːː", "unit_number": 646}, {"unit": "Ru", "unit_norm": "ru", "ipa": ".ɾ͡dʊ̞ː", "unit_number": 645}, {"unit": "Ro", "unit_norm": "ro", "ipa": ".ɾ͡dɔ̞ː", "unit_number": 644}, {"unit": "Ri", "unit_norm": "ri", "ipa": ".ɾ͡di̞ː", "unit_number": 643}, {"unit": "Re", "unit_norm": "re", "ipa": ".ɾ͡dɛ̞h", "unit_number": 642}, {"unit": "Ra", "unit_norm": "ra", "ipa": ".ɾ͡dɑ̞", "unit_number": 641}, {"unit": "Pūū", "unit_norm": "pūū", "ipa": "puːuː", "unit_number": 640}, {"unit": "Puū", "unit_norm": "puū", "ipa": "pʊːuː", "unit_number": 639}, {"unit": "Pūu", "unit_norm": "pūu", "ipa": "puːʊː", "unit_number": 638}, {"unit": "Pūō", "unit_norm": "pūō", "ipa": "puːɔːr", "unit_number": 637}, {"unit": "Paō", "unit_norm": "paō", "ipa": "pɑɔːr", "unit_number": 636}, {"unit": "Pūo", "unit_norm": "pūo", "ipa": "puːɔː", "unit_number": 635}, {"unit": "Pūī", "unit_norm": "pūī", "ipa": "puːiːː", "unit_number": 634}, {"unit": "Puī", "unit_norm": "puī", "ipa": "pʊːiːː", "unit_number": 633}, {"unit": "Pūi", "unit_norm": "pūi", "ipa": "puːiː", "unit_number": 632}, {"unit": "Pūē", "unit_norm": "pūē", "ipa": "puːɛː", "unit_number": 631}, {"unit": "Pūe", "unit_norm": "pūe", "ipa": "puːɛh", "unit_number": 630}, {"unit": "Pūā", "unit_norm": "pūā", "ipa": "puːɑːː", "unit_number": 629}, {"unit": "Puā", "unit_norm": "puā", "ipa": "pʊːɑːː", "unit_number": 628}, {"unit": "Pūa", "unit_norm": "pūa", "ipa": "puːɑ", "unit_number": 627}, {"unit": "Pōū", "unit_norm": "pōū", "ipa": "pɔːruː", "unit_number": 626}, {"unit": "Poū", "unit_norm": "poū", "ipa": "pɔːuː", "unit_number": 625}, {"unit": "Pōu", "unit_norm": "pōu", "ipa": "pɔːrʊː", "unit_number": 624}, {"unit": "Pōō", "unit_norm": "pōō", "ipa": "pɔːrɔːr", "unit_number": 623}, {"unit": "Poō", "unit_norm": "poō", "ipa": "pɔːɔːr", "unit_number": 622}, {"unit": "Pōo", "unit_norm": "pōo", "ipa": "pɔːrɔː", "unit_number": 621}, {"unit": "Pōī", "unit_norm": "pōī", "ipa": "pɔːriːː", "unit_number": 620}, {"unit": "Poī", "unit_norm": "poī", "ipa": "pɔːiːː", "unit_number": 619}, {"unit": "Pōi", "unit_norm": "pōi", "ipa": "pɔːriː", "unit_number": 618}, {"unit": "Pōē", "unit_norm": "pōē", "ipa": "pɔːrɛː", "unit_number": 617}, {"unit": "Pōe", "unit_norm": "pōe", "ipa": "pɔːrɛh", "unit_number": 616}, {"unit": "Pōā", "unit_norm": "pōā", "ipa": "pɔːrɑːː", "unit_number": 615}, {"unit": "Poā", "unit_norm": "poā", "ipa": "pɔːɑːː", "unit_number": 614}, {"unit": "Pōa", "unit_norm": "pōa", "ipa": "pɔːrɑ", "unit_number": 613}, {"unit": "Pīū", "unit_norm": "pīū", "ipa": "piːːuː", "unit_number": 612}, {"unit": "Piū", "unit_norm": "piū", "ipa": "piːuː", "unit_number": 611}, {"unit": "Pīu", "unit_norm": "pīu", "ipa": "piːːʊː", "unit_number": 610}, {"unit": "Pīō", "unit_norm": "pīō", "ipa": "piːːɔːr", "unit_number": 609}, {"unit": "Piō", "unit_norm": "piō", "ipa": "piːɔːr", "unit_number": 608}, {"unit": "Pīo", "unit_norm": "pīo", "ipa": "piːːɔː", "unit_number": 607}, {"unit": "Pīī", "unit_norm": "pīī", "ipa": "piːːiːː", "unit_number": 606}, {"unit": "Piī", "unit_norm": "piī", "ipa": "piːiːː", "unit_number": 605}, {"unit": "Pīi", "unit_norm": "pīi", "ipa": "piːːiː", "unit_number": 604}, {"unit": "Pīē", "unit_norm": "pīē", "ipa": "piːːɛː", "unit_number": 603}, {"unit": "Pīe", "unit_norm": "pīe", "ipa": "piːːɛh", "unit_number": 602}, {"unit": "Pīā", "unit_norm": "pīā", "ipa": "piːːɑːː", "unit_number": 601}, {"unit": "Piā", "unit_norm": "piā", "ipa": "piːɑːː", "unit_number": 600}, {"unit": "Pīa", "unit_norm": "pīa", "ipa": "piːːɑ", "unit_number": 599}, {"unit": "Pēū", "unit_norm": "pēū", "ipa": "pɛːuː", "unit_number": 598}, {"unit": "Peū", "unit_norm": "peū", "ipa": "pɛhuː", "unit_number": 597}, {"unit": "Pēu", "unit_norm": "pēu", "ipa": "pɛːʊː", "unit_number": 596}, {"unit": "Pēō", "unit_norm": "pēō", "ipa": "pɛːɔːr", "unit_number": 595}, {"unit": "Peō", "unit_norm": "peō", "ipa": "pɛhɔːr", "unit_number": 594}, {"unit": "Pēo", "unit_norm": "pēo", "ipa": "pɛːɔː", "unit_number": 593}, {"unit": "Pēī", "unit_norm": "pēī", "ipa": "pɛːiːː", "unit_number": 592}, {"unit": "Peī", "unit_norm": "peī", "ipa": "pɛhiːː", "unit_number": 591}, {"unit": "Pēi", "unit_norm": "pēi", "ipa": "pɛːiː", "unit_number": 590}, {"unit": "Pēē", "unit_norm": "pēē", "ipa": "pɛːɛː", "unit_number": 589}, {"unit": "Pēe", "unit_norm": "pēe", "ipa": "pɛːɛh", "unit_number": 588}, {"unit": "Pēā", "unit_norm": "pēā", "ipa": "pɛːɑːː", "unit_number": 587}, {"unit": "Peā", "unit_norm": "peā", "ipa": "pɛhɑːː", "unit_number": 586}, {"unit": "Pēa", "unit_norm": "pēa", "ipa": "pɛːɑ", "unit_number": 585}, {"unit": "Pāū", "unit_norm": "pāū", "ipa": "pɑːːuː", "unit_number": 584}, {"unit": "Paū", "unit_norm": "paū", "ipa": "pɑuː", "unit_number": 583}, {"unit": "Pāu", "unit_norm": "pāu", "ipa": "pɑːːʊː", "unit_number": 582}, {"unit": "Pāō", "unit_norm": "pāō", "ipa": "pɑːːɔːr", "unit_number": 581}, {"unit": "Paō", "unit_norm": "paō", "ipa": "pɑɔːr", "unit_number": 580}, {"unit": "Pāo", "unit_norm": "pāo", "ipa": "pɑːːɔː", "unit_number": 579}, {"unit": "Pāī", "unit_norm": "pāī", "ipa": "pɑːːiːː", "unit_number": 578}, {"unit": "Paī", "unit_norm": "paī", "ipa": "pɑiːː", "unit_number": 577}, {"unit": "Pāi", "unit_norm": "pāi", "ipa": "pɑːːiː", "unit_number": 576}, {"unit": "Pāē", "unit_norm": "pāē", "ipa": "pɑːːɛː", "unit_number": 575}, {"unit": "Pāe", "unit_norm": "pāe", "ipa": "pɑːːɛh", "unit_number": 574}, {"unit": "Pāā", "unit_norm": "pāā", "ipa": "pɑːːɑːː", "unit_number": 573}, {"unit": "Paā", "unit_norm": "paā", "ipa": "pɑɑːː", "unit_number": 572}, {"unit": "Pāa", "unit_norm": "pāa", "ipa": "pɑːːɑ", "unit_number": 571}, {"unit": "Puu", "unit_norm": "puu", "ipa": "pʊːʊː", "unit_number": 570}, {"unit": "Puo", "unit_norm": "puo", "ipa": "pʊːɔː", "unit_number": 569}, {"unit": "Pui", "unit_norm": "pui", "ipa": "pʊːiː", "unit_number": 568}, {"unit": "Pue", "unit_norm": "pue", "ipa": "pʊːɛh", "unit_number": 567}, {"unit": "Pua", "unit_norm": "pua", "ipa": "pʊːɑ", "unit_number": 566}, {"unit": "Pou", "unit_norm": "pou", "ipa": "pɔːʊː", "unit_number": 565}, {"unit": "Poo", "unit_norm": "poo", "ipa": "pɔːɔː", "unit_number": 564}, {"unit": "Poi", "unit_norm": "poi", "ipa": "pɔːiː", "unit_number": 563}, {"unit": "Poe", "unit_norm": "poe", "ipa": "pɔːɛh", "unit_number": 562}, {"unit": "Poa", "unit_norm": "poa", "ipa": "pɔːɑ", "unit_number": 561}, {"unit": "Piu", "unit_norm": "piu", "ipa": "piːʊː", "unit_number": 560}, {"unit": "Pio", "unit_norm": "pio", "ipa": "piːɔː", "unit_number": 559}, {"unit": "Pii", "unit_norm": "pii", "ipa": "piːiː", "unit_number": 558}, {"unit": "Pie", "unit_norm": "pie", "ipa": "piːɛh", "unit_number": 557}, {"unit": "Pia", "unit_norm": "pia", "ipa": "piːɑ", "unit_number": 556}, {"unit": "Peu", "unit_norm": "peu", "ipa": "pɛhʊː", "unit_number": 555}, {"unit": "Peo", "unit_norm": "peo", "ipa": "pɛhɔː", "unit_number": 554}, {"unit": "Pei", "unit_norm": "pei", "ipa": "pɛhiː", "unit_number": 553}, {"unit": "Pee", "unit_norm": "pee", "ipa": "pɛhɛh", "unit_number": 552}, {"unit": "Pea", "unit_norm": "pea", "ipa": "pɛhɑ", "unit_number": 551}, {"unit": "Pau", "unit_norm": "pau", "ipa": "pɑʊː", "unit_number": 550}, {"unit": "Pao", "unit_norm": "pao", "ipa": "pɑɔː", "unit_number": 549}, {"unit": "Pai", "unit_norm": "pai", "ipa": "pɑiː", "unit_number": 548}, {"unit": "Pae", "unit_norm": "pae", "ipa": "pɑɛh", "unit_number": 547}, {"unit": "Paa", "unit_norm": "paa", "ipa": "pɑɑ", "unit_number": 546}, {"unit": "Pū", "unit_norm": "pū", "ipa": "puː", "unit_number": 545}, {"unit": "Pō", "unit_norm": "pō", "ipa": "pɔːr", "unit_number": 544}, {"unit": "Pī", "unit_norm": "pī", "ipa": "piːː", "unit_number": 543}, {"unit": "Pē", "unit_norm": "pē", "ipa": "pɛː", "unit_number": 542}, {"unit": "Pā", "unit_norm": "pā", "ipa": "pɑːː", "unit_number": 541}, {"unit": "Pu", "unit_norm": "pu", "ipa": "pʊː", "unit_number": 540}, {"unit": "Po", "unit_norm": "po", "ipa": "pɔː", "unit_number": 539}, {"unit": "Pi", "unit_norm": "pi", "ipa": "piː", "unit_number": 538}, {"unit": "Pe", "unit_norm": "pe", "ipa": "pɛh", "unit_number": 537}, {"unit": "Pa", "unit_norm": "pa", "ipa": "pɑ", "unit_number": 536}, {"unit": "Nūū", "unit_norm": "nūū", "ipa": "nuːuː", "unit_number": 535}, {"unit": "Nuū", "unit_norm": "nuū", "ipa": "nʊːuː", "unit_number": 534}, {"unit": "Nūu", "unit_norm": "nūu", "ipa": "nuːʊː", "unit_number": 533}, {"unit": "Nūō", "unit_norm": "nūō", "ipa": "nuːɔːr", "unit_number": 532}, {"unit": "Naō", "unit_norm": "naō", "ipa": "nɑɔːr", "unit_number": 531}, {"unit": "Nūo", "unit_norm": "nūo", "ipa": "nuːɔː", "unit_number": 530}, {"unit": "Nūī", "unit_norm": "nūī", "ipa": "nuːiːː", "unit_number": 529}, {"unit": "Nuī", "unit_norm": "nuī", "ipa": "nʊːiːː", "unit_number": 528}, {"unit": "Nūi", "unit_norm": "nūi", "ipa": "nuːiː", "unit_number": 527}, {"unit": "Nūē", "unit_norm": "nūē", "ipa": "nuːɛː", "unit_number": 526}, {"unit": "Nūe", "unit_norm": "nūe", "ipa": "nuːɛh", "unit_number": 525}, {"unit": "Nūā", "unit_norm": "nūā", "ipa": "nuːɑːː", "unit_number": 524}, {"unit": "Nuā", "unit_norm": "nuā", "ipa": "nʊːɑːː", "unit_number": 523}, {"unit": "Nūa", "unit_norm": "nūa", "ipa": "nuːɑ", "unit_number": 522}, {"unit": "Nōū", "unit_norm": "nōū", "ipa": "nɔːruː", "unit_number": 521}, {"unit": "Noū", "unit_norm": "noū", "ipa": "nɔːuː", "unit_number": 520}, {"unit": "Nōu", "unit_norm": "nōu", "ipa": "nɔːrʊː", "unit_number": 519}, {"unit": "Nōō", "unit_norm": "nōō", "ipa": "nɔːrɔːr", "unit_number": 518}, {"unit": "Noō", "unit_norm": "noō", "ipa": "nɔːɔːr", "unit_number": 517}, {"unit": "Nōo", "unit_norm": "nōo", "ipa": "nɔːrɔː", "unit_number": 516}, {"unit": "Nōī", "unit_norm": "nōī", "ipa": "nɔːriːː", "unit_number": 515}, {"unit": "Noī", "unit_norm": "noī", "ipa": "nɔːiːː", "unit_number": 514}, {"unit": "Nōi", "unit_norm": "nōi", "ipa": "nɔːriː", "unit_number": 513}, {"unit": "Nōē", "unit_norm": "nōē", "ipa": "nɔːrɛː", "unit_number": 512}, {"unit": "Nōe", "unit_norm": "nōe", "ipa": "nɔːrɛh", "unit_number": 511}, {"unit": "Nōā", "unit_norm": "nōā", "ipa": "nɔːrɑːː", "unit_number": 510}, {"unit": "Noā", "unit_norm": "noā", "ipa": "nɔːɑːː", "unit_number": 509}, {"unit": "Nōa", "unit_norm": "nōa", "ipa": "nɔːrɑ", "unit_number": 508}, {"unit": "Nīū", "unit_norm": "nīū", "ipa": "niːːuː", "unit_number": 507}, {"unit": "Niū", "unit_norm": "niū", "ipa": "niːuː", "unit_number": 506}, {"unit": "Nīu", "unit_norm": "nīu", "ipa": "niːːʊː", "unit_number": 505}, {"unit": "Nīō", "unit_norm": "nīō", "ipa": "niːːɔːr", "unit_number": 504}, {"unit": "Niō", "unit_norm": "niō", "ipa": "niːɔːr", "unit_number": 503}, {"unit": "Nīo", "unit_norm": "nīo", "ipa": "niːːɔː", "unit_number": 502}, {"unit": "Nīī", "unit_norm": "nīī", "ipa": "niːːiːː", "unit_number": 501}, {"unit": "Niī", "unit_norm": "niī", "ipa": "niːiːː", "unit_number": 500}, {"unit": "Nīi", "unit_norm": "nīi", "ipa": "niːːiː", "unit_number": 499}, {"unit": "Nīē", "unit_norm": "nīē", "ipa": "niːːɛː", "unit_number": 498}, {"unit": "Nīe", "unit_norm": "nīe", "ipa": "niːːɛh", "unit_number": 497}, {"unit": "Nīā", "unit_norm": "nīā", "ipa": "niːːɑːː", "unit_number": 496}, {"unit": "Niā", "unit_norm": "niā", "ipa": "niːɑːː", "unit_number": 495}, {"unit": "Nīa", "unit_norm": "nīa", "ipa": "niːːɑ", "unit_number": 494}, {"unit": "Nēū", "unit_norm": "nēū", "ipa": "nɛːuː", "unit_number": 493}, {"unit": "Neū", "unit_norm": "neū", "ipa": "nɛhuː", "unit_number": 492}, {"unit": "Nēu", "unit_norm": "nēu", "ipa": "nɛːʊː", "unit_number": 491}, {"unit": "Nēō", "unit_norm": "nēō", "ipa": "nɛːɔːr", "unit_number": 490}, {"unit": "Neō", "unit_norm": "neō", "ipa": "nɛhɔːr", "unit_number": 489}, {"unit": "Nēo", "unit_norm": "nēo", "ipa": "nɛːɔː", "unit_number": 488}, {"unit": "Nēī", "unit_norm": "nēī", "ipa": "nɛːiːː", "unit_number": 487}, {"unit": "Neī", "unit_norm": "neī", "ipa": "nɛhiːː", "unit_number": 486}, {"unit": "Nēi", "unit_norm": "nēi", "ipa": "nɛːiː", "unit_number": 485}, {"unit": "Nēē", "unit_norm": "nēē", "ipa": "nɛːɛː", "unit_number": 484}, {"unit": "Nēe", "unit_norm": "nēe", "ipa": "nɛːɛh", "unit_number": 483}, {"unit": "Nēā", "unit_norm": "nēā", "ipa": "nɛːɑːː", "unit_number": 482}, {"unit": "Neā", "unit_norm": "neā", "ipa": "nɛhɑːː", "unit_number": 481}, {"unit": "Nēa", "unit_norm": "nēa", "ipa": "nɛːɑ", "unit_number": 480}, {"unit": "Nāū", "unit_norm": "nāū", "ipa": "nɑːːuː", "unit_number": 479}, {"unit": "Naū", "unit_norm": "naū", "ipa": "nɑuː", "unit_number": 478}, {"unit": "Nāu", "unit_norm": "nāu", "ipa": "nɑːːʊː", "unit_number": 477}, {"unit": "Nāō", "unit_norm": "nāō", "ipa": "nɑːːɔːr", "unit_number": 476}, {"unit": "Naō", "unit_norm": "naō", "ipa": "nɑɔːr", "unit_number": 475}, {"unit": "Nāo", "unit_norm": "nāo", "ipa": "nɑːːɔː", "unit_number": 474}, {"unit": "Nāī", "unit_norm": "nāī", "ipa": "nɑːːiːː", "unit_number": 473}, {"unit": "Naī", "unit_norm": "naī", "ipa": "nɑiːː", "unit_number": 472}, {"unit": "Nāi", "unit_norm": "nāi", "ipa": "nɑːːiː", "unit_number": 471}, {"unit": "Nāē", "unit_norm": "nāē", "ipa": "nɑːːɛː", "unit_number": 470}, {"unit": "Nāe", "unit_norm": "nāe", "ipa": "nɑːːɛh", "unit_number": 469}, {"unit": "Nāā", "unit_norm": "nāā", "ipa": "nɑːːɑːː", "unit_number": 468}, {"unit": "Naā", "unit_norm": "naā", "ipa": "nɑɑːː", "unit_number": 467}, {"unit": "Nāa", "unit_norm": "nāa", "ipa": "nɑːːɑ", "unit_number": 466}, {"unit": "Nuu", "unit_norm": "nuu", "ipa": "nʊːʊː", "unit_number": 465}, {"unit": "Nuo", "unit_norm": "nuo", "ipa": "nʊːɔː", "unit_number": 464}, {"unit": "Nui", "unit_norm": "nui", "ipa": "nʊːiː", "unit_number": 463}, {"unit": "Nue", "unit_norm": "nue", "ipa": "nʊːɛh", "unit_number": 462}, {"unit": "Nua", "unit_norm": "nua", "ipa": "nʊːɑ", "unit_number": 461}, {"unit": "Nou", "unit_norm": "nou", "ipa": "nɔːʊː", "unit_number": 460}, {"unit": "Noo", "unit_norm": "noo", "ipa": "nɔːɔː", "unit_number": 459}, {"unit": "Noi", "unit_norm": "noi", "ipa": "nɔːiː", "unit_number": 458}, {"unit": "Noe", "unit_norm": "noe", "ipa": "nɔːɛh", "unit_number": 457}, {"unit": "Noa", "unit_norm": "noa", "ipa": "nɔːɑ", "unit_number": 456}, {"unit": "Niu", "unit_norm": "niu", "ipa": "niːʊː", "unit_number": 455}, {"unit": "Nio", "unit_norm": "nio", "ipa": "niːɔː", "unit_number": 454}, {"unit": "Nii", "unit_norm": "nii", "ipa": "niːiː", "unit_number": 453}, {"unit": "Nie", "unit_norm": "nie", "ipa": "niːɛh", "unit_number": 452}, {"unit": "Nia", "unit_norm": "nia", "ipa": "niːɑ", "unit_number": 451}, {"unit": "Neu", "unit_norm": "neu", "ipa": "nɛhʊː", "unit_number": 450}, {"unit": "Neo", "unit_norm": "neo", "ipa": "nɛhɔː", "unit_number": 449}, {"unit": "Nei", "unit_norm": "nei", "ipa": "nɛhiː", "unit_number": 448}, {"unit": "Nee", "unit_norm": "nee", "ipa": "nɛhɛh", "unit_number": 447}, {"unit": "Nea", "unit_norm": "nea", "ipa": "nɛhɑ", "unit_number": 446}, {"unit": "Nau", "unit_norm": "nau", "ipa": "nɑʊː", "unit_number": 445}, {"unit": "Nao", "unit_norm": "nao", "ipa": "nɑɔː", "unit_number": 444}, {"unit": "Nai", "unit_norm": "nai", "ipa": "nɑiː", "unit_number": 443}, {"unit": "Nae", "unit_norm": "nae", "ipa": "nɑɛh", "unit_number": 442}, {"unit": "Naa", "unit_norm": "naa", "ipa": "nɑɑ", "unit_number": 441}, {"unit": "Nū", "unit_norm": "nū", "ipa": "nuː", "unit_number": 440}, {"unit": "Nō", "unit_norm": "nō", "ipa": "nɔːr", "unit_number": 439}, {"unit": "Nī", "unit_norm": "nī", "ipa": "niːː", "unit_number": 438}, {"unit": "Nē", "unit_norm": "nē", "ipa": "nɛː", "unit_number": 437}, {"unit": "Nā", "unit_norm": "nā", "ipa": "nɑːː", "unit_number": 436}, {"unit": "Nu", "unit_norm": "nu", "ipa": "nʊː", "unit_number": 435}, {"unit": "No", "unit_norm": "no", "ipa": "nɔː", "unit_number": 434}, {"unit": "Ni", "unit_norm": "ni", "ipa": "niː", "unit_number": 433}, {"unit": "Ne", "unit_norm": "ne", "ipa": "nɛh", "unit_number": 432}, {"unit": "Na", "unit_norm": "na", "ipa": "nɑ", "unit_number": 431}, {"unit": "Mūū", "unit_norm": "mūū", "ipa": "muːuː", "unit_number": 430}, {"unit": "Muū", "unit_norm": "muū", "ipa": "mʊːuː", "unit_number": 429}, {"unit": "Mūu", "unit_norm": "mūu", "ipa": "muːʊː", "unit_number": 428}, {"unit": "Mūō", "unit_norm": "mūō", "ipa": "muːɔːr", "unit_number": 427}, {"unit": "Maō", "unit_norm": "maō", "ipa": "mɑɔːr", "unit_number": 426}, {"unit": "Mūo", "unit_norm": "mūo", "ipa": "muːɔː", "unit_number": 425}, {"unit": "Mūī", "unit_norm": "mūī", "ipa": "muːiːː", "unit_number": 424}, {"unit": "Muī", "unit_norm": "muī", "ipa": "mʊːiːː", "unit_number": 423}, {"unit": "Mūi", "unit_norm": "mūi", "ipa": "muːiː", "unit_number": 422}, {"unit": "Mūē", "unit_norm": "mūē", "ipa": "muːɛː", "unit_number": 421}, {"unit": "Mūe", "unit_norm": "mūe", "ipa": "muːɛh", "unit_number": 420}, {"unit": "Mūā", "unit_norm": "mūā", "ipa": "muːɑːː", "unit_number": 419}, {"unit": "Muā", "unit_norm": "muā", "ipa": "mʊːɑːː", "unit_number": 418}, {"unit": "Mūa", "unit_norm": "mūa", "ipa": "muːɑ", "unit_number": 417}, {"unit": "Mōū", "unit_norm": "mōū", "ipa": "mɔːruː", "unit_number": 416}, {"unit": "Moū", "unit_norm": "moū", "ipa": "mɔːuː", "unit_number": 415}, {"unit": "Mōu", "unit_norm": "mōu", "ipa": "mɔːrʊː", "unit_number": 414}, {"unit": "Mōō", "unit_norm": "mōō", "ipa": "mɔːrɔːr", "unit_number": 413}, {"unit": "Moō", "unit_norm": "moō", "ipa": "mɔːɔːr", "unit_number": 412}, {"unit": "Mōo", "unit_norm": "mōo", "ipa": "mɔːrɔː", "unit_number": 411}, {"unit": "Mōī", "unit_norm": "mōī", "ipa": "mɔːriːː", "unit_number": 410}, {"unit": "Moī", "unit_norm": "moī", "ipa": "mɔːiːː", "unit_number": 409}, {"unit": "Mōi", "unit_norm": "mōi", "ipa": "mɔːriː", "unit_number": 408}, {"unit": "Mōē", "unit_norm": "mōē", "ipa": "mɔːrɛː", "unit_number": 407}, {"unit": "Mōe", "unit_norm": "mōe", "ipa": "mɔːrɛh", "unit_number": 406}, {"unit": "Mōā", "unit_norm": "mōā", "ipa": "mɔːrɑːː", "unit_number": 405}, {"unit": "Moā", "unit_norm": "moā", "ipa": "mɔːɑːː", "unit_number": 404}, {"unit": "Mōa", "unit_norm": "mōa", "ipa": "mɔːrɑ", "unit_number": 403}, {"unit": "Mīū", "unit_norm": "mīū", "ipa": "miːːuː", "unit_number": 402}, {"unit": "Miū", "unit_norm": "miū", "ipa": "miːuː", "unit_number": 401}, {"unit": "Mīu", "unit_norm": "mīu", "ipa": "miːːʊː", "unit_number": 400}, {"unit": "Mīō", "unit_norm": "mīō", "ipa": "miːːɔːr", "unit_number": 399}, {"unit": "Miō", "unit_norm": "miō", "ipa": "miːɔːr", "unit_number": 398}, {"unit": "Mīo", "unit_norm": "mīo", "ipa": "miːːɔː", "unit_number": 397}, {"unit": "Mīī", "unit_norm": "mīī", "ipa": "miːːiːː", "unit_number": 396}, {"unit": "Miī", "unit_norm": "miī", "ipa": "miːiːː", "unit_number": 395}, {"unit": "Mīi", "unit_norm": "mīi", "ipa": "miːːiː", "unit_number": 394}, {"unit": "Mīē", "unit_norm": "mīē", "ipa": "miːːɛː", "unit_number": 393}, {"unit": "Mīe", "unit_norm": "mīe", "ipa": "miːːɛh", "unit_number": 392}, {"unit": "Mīā", "unit_norm": "mīā", "ipa": "miːːɑːː", "unit_number": 391}, {"unit": "Miā", "unit_norm": "miā", "ipa": "miːɑːː", "unit_number": 390}, {"unit": "Mīa", "unit_norm": "mīa", "ipa": "miːːɑ", "unit_number": 389}, {"unit": "Mēū", "unit_norm": "mēū", "ipa": "mɛːuː", "unit_number": 388}, {"unit": "Meū", "unit_norm": "meū", "ipa": "mɛhuː", "unit_number": 387}, {"unit": "Mēu", "unit_norm": "mēu", "ipa": "mɛːʊː", "unit_number": 386}, {"unit": "Mēō", "unit_norm": "mēō", "ipa": "mɛːɔːr", "unit_number": 385}, {"unit": "Meō", "unit_norm": "meō", "ipa": "mɛhɔːr", "unit_number": 384}, {"unit": "Mēo", "unit_norm": "mēo", "ipa": "mɛːɔː", "unit_number": 383}, {"unit": "Mēī", "unit_norm": "mēī", "ipa": "mɛːiːː", "unit_number": 382}, {"unit": "Meī", "unit_norm": "meī", "ipa": "mɛhiːː", "unit_number": 381}, {"unit": "Mēi", "unit_norm": "mēi", "ipa": "mɛːiː", "unit_number": 380}, {"unit": "Mēē", "unit_norm": "mēē", "ipa": "mɛːɛː", "unit_number": 379}, {"unit": "Mēe", "unit_norm": "mēe", "ipa": "mɛːɛh", "unit_number": 378}, {"unit": "Mēā", "unit_norm": "mēā", "ipa": "mɛːɑːː", "unit_number": 377}, {"unit": "Meā", "unit_norm": "meā", "ipa": "mɛhɑːː", "unit_number": 376}, {"unit": "Mēa", "unit_norm": "mēa", "ipa": "mɛːɑ", "unit_number": 375}, {"unit": "Māū", "unit_norm": "māū", "ipa": "mɑːːuː", "unit_number": 374}, {"unit": "Maū", "unit_norm": "maū", "ipa": "mɑuː", "unit_number": 373}, {"unit": "Māu", "unit_norm": "māu", "ipa": "mɑːːʊː", "unit_number": 372}, {"unit": "Māō", "unit_norm": "māō", "ipa": "mɑːːɔːr", "unit_number": 371}, {"unit": "Maō", "unit_norm": "maō", "ipa": "mɑɔːr", "unit_number": 370}, {"unit": "Māo", "unit_norm": "māo", "ipa": "mɑːːɔː", "unit_number": 369}, {"unit": "Māī", "unit_norm": "māī", "ipa": "mɑːːiːː", "unit_number": 368}, {"unit": "Maī", "unit_norm": "maī", "ipa": "mɑiːː", "unit_number": 367}, {"unit": "Māi", "unit_norm": "māi", "ipa": "mɑːːiː", "unit_number": 366}, {"unit": "Māē", "unit_norm": "māē", "ipa": "mɑːːɛː", "unit_number": 365}, {"unit": "Māe", "unit_norm": "māe", "ipa": "mɑːːɛh", "unit_number": 364}, {"unit": "Māā", "unit_norm": "māā", "ipa": "mɑːːɑːː", "unit_number": 363}, {"unit": "Maā", "unit_norm": "maā", "ipa": "mɑɑːː", "unit_number": 362}, {"unit": "Māa", "unit_norm": "māa", "ipa": "mɑːːɑ", "unit_number": 361}, {"unit": "Muu", "unit_norm": "muu", "ipa": "mʊːʊː", "unit_number": 360}, {"unit": "Muo", "unit_norm": "muo", "ipa": "mʊːɔː", "unit_number": 359}, {"unit": "Mui", "unit_norm": "mui", "ipa": "mʊːiː", "unit_number": 358}, {"unit": "Mue", "unit_norm": "mue", "ipa": "mʊːɛh", "unit_number": 357}, {"unit": "Mua", "unit_norm": "mua", "ipa": "mʊːɑ", "unit_number": 356}, {"unit": "Mou", "unit_norm": "mou", "ipa": "mɔːʊː", "unit_number": 355}, {"unit": "Moo", "unit_norm": "moo", "ipa": "mɔːɔː", "unit_number": 354}, {"unit": "Moi", "unit_norm": "moi", "ipa": "mɔːiː", "unit_number": 353}, {"unit": "Moe", "unit_norm": "moe", "ipa": "mɔːɛh", "unit_number": 352}, {"unit": "Moa", "unit_norm": "moa", "ipa": "mɔːɑ", "unit_number": 351}, {"unit": "Miu", "unit_norm": "miu", "ipa": "miːʊː", "unit_number": 350}, {"unit": "Mio", "unit_norm": "mio", "ipa": "miːɔː", "unit_number": 349}, {"unit": "Mii", "unit_norm": "mii", "ipa": "miːiː", "unit_number": 348}, {"unit": "Mie", "unit_norm": "mie", "ipa": "miːɛh", "unit_number": 347}, {"unit": "Mia", "unit_norm": "mia", "ipa": "miːɑ", "unit_number": 346}, {"unit": "Meu", "unit_norm": "meu", "ipa": "mɛhʊː", "unit_number": 345}, {"unit": "Meo", "unit_norm": "meo", "ipa": "mɛhɔː", "unit_number": 344}, {"unit": "Mei", "unit_norm": "mei", "ipa": "mɛhiː", "unit_number": 343}, {"unit": "Mee", "unit_norm": "mee", "ipa": "mɛhɛh", "unit_number": 342}, {"unit": "Mea", "unit_norm": "mea", "ipa": "mɛhɑ", "unit_number": 341}, {"unit": "Mau", "unit_norm": "mau", "ipa": "mɑʊː", "unit_number": 340}, {"unit": "Mao", "unit_norm": "mao", "ipa": "mɑɔː", "unit_number": 339}, {"unit": "Mai", "unit_norm": "mai", "ipa": "mɑiː", "unit_number": 338}, {"unit": "Mae", "unit_norm": "mae", "ipa": "mɑɛh", "unit_number": 337}, {"unit": "Maa", "unit_norm": "maa", "ipa": "mɑɑ", "unit_number": 336}, {"unit": "Mū", "unit_norm": "mū", "ipa": "muː", "unit_number": 335}, {"unit": "Mō", "unit_norm": "mō", "ipa": "mɔːr", "unit_number": 334}, {"unit": "Mī", "unit_norm": "mī", "ipa": "miːː", "unit_number": 333}, {"unit": "Mē", "unit_norm": "mē", "ipa": "mɛː", "unit_number": 332}, {"unit": "Mā", "unit_norm": "mā", "ipa": "mɑːː", "unit_number": 331}, {"unit": "Mu", "unit_norm": "mu", "ipa": "mʊː", "unit_number": 330}, {"unit": "Mo", "unit_norm": "mo", "ipa": "mɔː", "unit_number": 329}, {"unit": "Mi", "unit_norm": "mi", "ipa": "miː", "unit_number": 328}, {"unit": "Me", "unit_norm": "me", "ipa": "mɛh", "unit_number": 327}, {"unit": "Ma", "unit_norm": "ma", "ipa": "mɑ", "unit_number": 326}, {"unit": "Kūū", "unit_norm": "kūū", "ipa": "kuːuː", "unit_number": 325}, {"unit": "Kuū", "unit_norm": "kuū", "ipa": "kʊːuː", "unit_number": 324}, {"unit": "Kūu", "unit_norm": "kūu", "ipa": "kuːʊː", "unit_number": 323}, {"unit": "Kūō", "unit_norm": "kūō", "ipa": "kuːɔːr", "unit_number": 322}, {"unit": "Kaō", "unit_norm": "kaō", "ipa": "kɑɔːr", "unit_number": 321}, {"unit": "Kūo", "unit_norm": "kūo", "ipa": "kuːɔː", "unit_number": 320}, {"unit": "Kūī", "unit_norm": "kūī", "ipa": "kuːiːː", "unit_number": 319}, {"unit": "Kuī", "unit_norm": "kuī", "ipa": "kʊːiːː", "unit_number": 318}, {"unit": "Kūi", "unit_norm": "kūi", "ipa": "kuːiː", "unit_number": 317}, {"unit": "Kūē", "unit_norm": "kūē", "ipa": "kuːɛː", "unit_number": 316}, {"unit": "Kūe", "unit_norm": "kūe", "ipa": "kuːɛh", "unit_number": 315}, {"unit": "Kūā", "unit_norm": "kūā", "ipa": "kuːɑːː", "unit_number": 314}, {"unit": "Kuā", "unit_norm": "kuā", "ipa": "kʊːɑːː", "unit_number": 313}, {"unit": "Kūa", "unit_norm": "kūa", "ipa": "kuːɑ", "unit_number": 312}, {"unit": "Kōū", "unit_norm": "kōū", "ipa": "kɔːruː", "unit_number": 311}, {"unit": "Koū", "unit_norm": "koū", "ipa": "kɔːuː", "unit_number": 310}, {"unit": "Kōu", "unit_norm": "kōu", "ipa": "kɔːrʊː", "unit_number": 309}, {"unit": "Kōō", "unit_norm": "kōō", "ipa": "kɔːrɔːr", "unit_number": 308}, {"unit": "Koō", "unit_norm": "koō", "ipa": "kɔːɔːr", "unit_number": 307}, {"unit": "Kōo", "unit_norm": "kōo", "ipa": "kɔːrɔː", "unit_number": 306}, {"unit": "Kōī", "unit_norm": "kōī", "ipa": "kɔːriːː", "unit_number": 305}, {"unit": "Koī", "unit_norm": "koī", "ipa": "kɔːiːː", "unit_number": 304}, {"unit": "Kōi", "unit_norm": "kōi", "ipa": "kɔːriː", "unit_number": 303}, {"unit": "Kōē", "unit_norm": "kōē", "ipa": "kɔːrɛː", "unit_number": 302}, {"unit": "Kōe", "unit_norm": "kōe", "ipa": "kɔːrɛh", "unit_number": 301}, {"unit": "Kōā", "unit_norm": "kōā", "ipa": "kɔːrɑːː", "unit_number": 300}, {"unit": "Koā", "unit_norm": "koā", "ipa": "kɔːɑːː", "unit_number": 299}, {"unit": "Kōa", "unit_norm": "kōa", "ipa": "kɔːrɑ", "unit_number": 298}, {"unit": "Kīū", "unit_norm": "kīū", "ipa": "kiːːuː", "unit_number": 297}, {"unit": "Kiū", "unit_norm": "kiū", "ipa": "kiːuː", "unit_number": 296}, {"unit": "Kīu", "unit_norm": "kīu", "ipa": "kiːːʊː", "unit_number": 295}, {"unit": "Kīō", "unit_norm": "kīō", "ipa": "kiːːɔːr", "unit_number": 294}, {"unit": "Kiō", "unit_norm": "kiō", "ipa": "kiːɔːr", "unit_number": 293}, {"unit": "Kīo", "unit_norm": "kīo", "ipa": "kiːːɔː", "unit_number": 292}, {"unit": "Kīī", "unit_norm": "kīī", "ipa": "kiːːiːː", "unit_number": 291}, {"unit": "Kiī", "unit_norm": "kiī", "ipa": "kiːiːː", "unit_number": 290}, {"unit": "Kīi", "unit_norm": "kīi", "ipa": "kiːːiː", "unit_number": 289}, {"unit": "Kīē", "unit_norm": "kīē", "ipa": "kiːːɛː", "unit_number": 288}, {"unit": "Kīe", "unit_norm": "kīe", "ipa": "kiːːɛh", "unit_number": 287}, {"unit": "Kīā", "unit_norm": "kīā", "ipa": "kiːːɑːː", "unit_number": 286}, {"unit": "Kiā", "unit_norm": "kiā", "ipa": "kiːɑːː", "unit_number": 285}, {"unit": "Kīa", "unit_norm": "kīa", "ipa": "kiːːɑ", "unit_number": 284}, {"unit": "Kēū", "unit_norm": "kēū", "ipa": "kɛːuː", "unit_number": 283}, {"unit": "Keū", "unit_norm": "keū", "ipa": "kɛhuː", "unit_number": 282}, {"unit": "Kēu", "unit_norm": "kēu", "ipa": "kɛːʊː", "unit_number": 281}, {"unit": "Kēō", "unit_norm": "kēō", "ipa": "kɛːɔːr", "unit_number": 280}, {"unit": "Keō", "unit_norm": "keō", "ipa": "kɛhɔːr", "unit_number": 279}, {"unit": "Kēo", "unit_norm": "kēo", "ipa": "kɛːɔː", "unit_number": 278}, {"unit": "Kēī", "unit_norm": "kēī", "ipa": "kɛːiːː", "unit_number": 277}, {"unit": "Keī", "unit_norm": "keī", "ipa": "kɛhiːː", "unit_number": 276}, {"unit": "Kēi", "unit_norm": "kēi", "ipa": "kɛːiː", "unit_number": 275}, {"unit": "Kēē", "unit_norm": "kēē", "ipa": "kɛːɛː", "unit_number": 274}, {"unit": "Kēe", "unit_norm": "kēe", "ipa": "kɛːɛh", "unit_number": 273}, {"unit": "Kēā", "unit_norm": "kēā", "ipa": "kɛːɑːː", "unit_number": 272}, {"unit": "Keā", "unit_norm": "keā", "ipa": "kɛhɑːː", "unit_number": 271}, {"unit": "Kēa", "unit_norm": "kēa", "ipa": "kɛːɑ", "unit_number": 270}, {"unit": "Kāū", "unit_norm": "kāū", "ipa": "kɑːːuː", "unit_number": 269}, {"unit": "Kaū", "unit_norm": "kaū", "ipa": "kɑuː", "unit_number": 268}, {"unit": "Kāu", "unit_norm": "kāu", "ipa": "kɑːːʊː", "unit_number": 267}, {"unit": "Kāō", "unit_norm": "kāō", "ipa": "kɑːːɔːr", "unit_number": 266}, {"unit": "Kaō", "unit_norm": "kaō", "ipa": "kɑɔːr", "unit_number": 265}, {"unit": "Kāo", "unit_norm": "kāo", "ipa": "kɑːːɔː", "unit_number": 264}, {"unit": "Kāī", "unit_norm": "kāī", "ipa": "kɑːːiːː", "unit_number": 263}, {"unit": "Kaī", "unit_norm": "kaī", "ipa": "kɑiːː", "unit_number": 262}, {"unit": "Kāi", "unit_norm": "kāi", "ipa": "kɑːːiː", "unit_number": 261}, {"unit": "Kāē", "unit_norm": "kāē", "ipa": "kɑːːɛː", "unit_number": 260}, {"unit": "Kāe", "unit_norm": "kāe", "ipa": "kɑːːɛh", "unit_number": 259}, {"unit": "Kāā", "unit_norm": "kāā", "ipa": "kɑːːɑːː", "unit_number": 258}, {"unit": "Kaā", "unit_norm": "kaā", "ipa": "kɑɑːː", "unit_number": 257}, {"unit": "Kāa", "unit_norm": "kāa", "ipa": "kɑːːɑ", "unit_number": 256}, {"unit": "Kuu", "unit_norm": "kuu", "ipa": "kʊːʊː", "unit_number": 255}, {"unit": "Kuo", "unit_norm": "kuo", "ipa": "kʊːɔː", "unit_number": 254}, {"unit": "Kui", "unit_norm": "kui", "ipa": "kʊːiː", "unit_number": 253}, {"unit": "Kue", "unit_norm": "kue", "ipa": "kʊːɛh", "unit_number": 252}, {"unit": "Kua", "unit_norm": "kua", "ipa": "kʊːɑ", "unit_number": 251}, {"unit": "Kou", "unit_norm": "kou", "ipa": "kɔːʊː", "unit_number": 250}, {"unit": "Koo", "unit_norm": "koo", "ipa": "kɔːɔː", "unit_number": 249}, {"unit": "Koi", "unit_norm": "koi", "ipa": "kɔːiː", "unit_number": 248}, {"unit": "Koe", "unit_norm": "koe", "ipa": "kɔːɛh", "unit_number": 247}, {"unit": "Koa", "unit_norm": "koa", "ipa": "kɔːɑ", "unit_number": 246}, {"unit": "Kiu", "unit_norm": "kiu", "ipa": "kiːʊː", "unit_number": 245}, {"unit": "Kio", "unit_norm": "kio", "ipa": "kiːɔː", "unit_number": 244}, {"unit": "Kii", "unit_norm": "kii", "ipa": "kiːiː", "unit_number": 243}, {"unit": "Kie", "unit_norm": "kie", "ipa": "kiːɛh", "unit_number": 242}, {"unit": "Kia", "unit_norm": "kia", "ipa": "kiːɑ", "unit_number": 241}, {"unit": "Keu", "unit_norm": "keu", "ipa": "kɛhʊː", "unit_number": 240}, {"unit": "Keo", "unit_norm": "keo", "ipa": "kɛhɔː", "unit_number": 239}, {"unit": "Kei", "unit_norm": "kei", "ipa": "kɛhiː", "unit_number": 238}, {"unit": "Kee", "unit_norm": "kee", "ipa": "kɛhɛh", "unit_number": 237}, {"unit": "Kea", "unit_norm": "kea", "ipa": "kɛhɑ", "unit_number": 236}, {"unit": "Kau", "unit_norm": "kau", "ipa": "kɑʊː", "unit_number": 235}, {"unit": "Kao", "unit_norm": "kao", "ipa": "kɑɔː", "unit_number": 234}, {"unit": "Kai", "unit_norm": "kai", "ipa": "kɑiː", "unit_number": 233}, {"unit": "Kae", "unit_norm": "kae", "ipa": "kɑɛh", "unit_number": 232}, {"unit": "Kaa", "unit_norm": "kaa", "ipa": "kɑɑ", "unit_number": 231}, {"unit": "Kū", "unit_norm": "kū", "ipa": "kuː", "unit_number": 230}, {"unit": "Kō", "unit_norm": "kō", "ipa": "kɔːr", "unit_number": 229}, {"unit": "Kī", "unit_norm": "kī", "ipa": "kiːː", "unit_number": 228}, {"unit": "Kē", "unit_norm": "kē", "ipa": "kɛː", "unit_number": 227}, {"unit": "Kā", "unit_norm": "kā", "ipa": "kɑːː", "unit_number": 226}, {"unit": "Ku", "unit_norm": "ku", "ipa": "kʊː", "unit_number": 225}, {"unit": "Ko", "unit_norm": "ko", "ipa": "kɔː", "unit_number": 224}, {"unit": "Ki", "unit_norm": "ki", "ipa": "kiː", "unit_number": 223}, {"unit": "Ke", "unit_norm": "ke", "ipa": "kɛh", "unit_number": 222}, {"unit": "Ka", "unit_norm": "ka", "ipa": "kɑ", "unit_number": 221}, {"unit": "Hūū", "unit_norm": "hūū", "ipa": "huːuː", "unit_number": 220}, {"unit": "Huū", "unit_norm": "huū", "ipa": "hʊːuː", "unit_number": 219}, {"unit": "Hūu", "unit_norm": "hūu", "ipa": "huːʊː", "unit_number": 218}, {"unit": "Hūō", "unit_norm": "hūō", "ipa": "huːɔːr", "unit_number": 217}, {"unit": "Haō", "unit_norm": "haō", "ipa": "hɑɔːr", "unit_number": 216}, {"unit": "Hūo", "unit_norm": "hūo", "ipa": "huːɔː", "unit_number": 215}, {"unit": "Hūī", "unit_norm": "hūī", "ipa": "huːiːː", "unit_number": 214}, {"unit": "Huī", "unit_norm": "huī", "ipa": "hʊːiːː", "unit_number": 213}, {"unit": "Hūi", "unit_norm": "hūi", "ipa": "huːiː", "unit_number": 212}, {"unit": "Hūē", "unit_norm": "hūē", "ipa": "huːɛː", "unit_number": 211}, {"unit": "Hūe", "unit_norm": "hūe", "ipa": "huːɛh", "unit_number": 210}, {"unit": "Hūā", "unit_norm": "hūā", "ipa": "huːɑːː", "unit_number": 209}, {"unit": "Huā", "unit_norm": "huā", "ipa": "hʊːɑːː", "unit_number": 208}, {"unit": "Hūa", "unit_norm": "hūa", "ipa": "huːɑ", "unit_number": 207}, {"unit": "Hōū", "unit_norm": "hōū", "ipa": "hɔːruː", "unit_number": 206}, {"unit": "Hoū", "unit_norm": "hoū", "ipa": "hɔːuː", "unit_number": 205}, {"unit": "Hōu", "unit_norm": "hōu", "ipa": "hɔːrʊː", "unit_number": 204}, {"unit": "Hōō", "unit_norm": "hōō", "ipa": "hɔːrɔːr", "unit_number": 203}, {"unit": "Hoō", "unit_norm": "hoō", "ipa": "hɔːɔːr", "unit_number": 202}, {"unit": "Hōo", "unit_norm": "hōo", "ipa": "hɔːrɔː", "unit_number": 201}, {"unit": "Hōī", "unit_norm": "hōī", "ipa": "hɔːriːː", "unit_number": 200}, {"unit": "Hoī", "unit_norm": "hoī", "ipa": "hɔːiːː", "unit_number": 199}, {"unit": "Hōi", "unit_norm": "hōi", "ipa": "hɔːriː", "unit_number": 198}, {"unit": "Hōē", "unit_norm": "hōē", "ipa": "hɔːrɛː", "unit_number": 197}, {"unit": "Hōe", "unit_norm": "hōe", "ipa": "hɔːrɛh", "unit_number": 196}, {"unit": "Hōā", "unit_norm": "hōā", "ipa": "hɔːrɑːː", "unit_number": 195}, {"unit": "Hoā", "unit_norm": "hoā", "ipa": "hɔːɑːː", "unit_number": 194}, {"unit": "Hōa", "unit_norm": "hōa", "ipa": "hɔːrɑ", "unit_number": 193}, {"unit": "Hīū", "unit_norm": "hīū", "ipa": "hiːːuː", "unit_number": 192}, {"unit": "Hiū", "unit_norm": "hiū", "ipa": "hiːuː", "unit_number": 191}, {"unit": "Hīu", "unit_norm": "hīu", "ipa": "hiːːʊː", "unit_number": 190}, {"unit": "Hīō", "unit_norm": "hīō", "ipa": "hiːːɔːr", "unit_number": 189}, {"unit": "Hiō", "unit_norm": "hiō", "ipa": "hiːɔːr", "unit_number": 188}, {"unit": "Hīo", "unit_norm": "hīo", "ipa": "hiːːɔː", "unit_number": 187}, {"unit": "Hīī", "unit_norm": "hīī", "ipa": "hiːːiːː", "unit_number": 186}, {"unit": "Hiī", "unit_norm": "hiī", "ipa": "hiːiːː", "unit_number": 185}, {"unit": "Hīi", "unit_norm": "hīi", "ipa": "hiːːiː", "unit_number": 184}, {"unit": "Hīē", "unit_norm": "hīē", "ipa": "hiːːɛː", "unit_number": 183}, {"unit": "Hīe", "unit_norm": "hīe", "ipa": "hiːːɛh", "unit_number": 182}, {"unit": "Hīā", "unit_norm": "hīā", "ipa": "hiːːɑːː", "unit_number": 181}, {"unit": "Hiā", "unit_norm": "hiā", "ipa": "hiːɑːː", "unit_number": 180}, {"unit": "Hīa", "unit_norm": "hīa", "ipa": "hiːːɑ", "unit_number": 179}, {"unit": "Hēū", "unit_norm": "hēū", "ipa": "hɛːuː", "unit_number": 178}, {"unit": "Heū", "unit_norm": "heū", "ipa": "hɛhuː", "unit_number": 177}, {"unit": "Hēu", "unit_norm": "hēu", "ipa": "hɛːʊː", "unit_number": 176}, {"unit": "Hēō", "unit_norm": "hēō", "ipa": "hɛːɔːr", "unit_number": 175}, {"unit": "Heō", "unit_norm": "heō", "ipa": "hɛhɔːr", "unit_number": 174}, {"unit": "Hēo", "unit_norm": "hēo", "ipa": "hɛːɔː", "unit_number": 173}, {"unit": "Hēī", "unit_norm": "hēī", "ipa": "hɛːiːː", "unit_number": 172}, {"unit": "Heī", "unit_norm": "heī", "ipa": "hɛhiːː", "unit_number": 171}, {"unit": "Hēi", "unit_norm": "hēi", "ipa": "hɛːiː", "unit_number": 170}, {"unit": "Hēē", "unit_norm": "hēē", "ipa": "hɛːɛː", "unit_number": 169}, {"unit": "Hēe", "unit_norm": "hēe", "ipa": "hɛːɛh", "unit_number": 168}, {"unit": "Hēā", "unit_norm": "hēā", "ipa": "hɛːɑːː", "unit_number": 167}, {"unit": "Heā", "unit_norm": "heā", "ipa": "hɛhɑːː", "unit_number": 166}, {"unit": "Hēa", "unit_norm": "hēa", "ipa": "hɛːɑ", "unit_number": 165}, {"unit": "Hāū", "unit_norm": "hāū", "ipa": "hɑːːuː", "unit_number": 164}, {"unit": "Haū", "unit_norm": "haū", "ipa": "hɑuː", "unit_number": 163}, {"unit": "Hāu", "unit_norm": "hāu", "ipa": "hɑːːʊː", "unit_number": 162}, {"unit": "Hāō", "unit_norm": "hāō", "ipa": "hɑːːɔːr", "unit_number": 161}, {"unit": "Haō", "unit_norm": "haō", "ipa": "hɑɔːr", "unit_number": 160}, {"unit": "Hāo", "unit_norm": "hāo", "ipa": "hɑːːɔː", "unit_number": 159}, {"unit": "Hāī", "unit_norm": "hāī", "ipa": "hɑːːiːː", "unit_number": 158}, {"unit": "Haī", "unit_norm": "haī", "ipa": "hɑiːː", "unit_number": 157}, {"unit": "Hāi", "unit_norm": "hāi", "ipa": "hɑːːiː", "unit_number": 156}, {"unit": "Hāē", "unit_norm": "hāē", "ipa": "hɑːːɛː", "unit_number": 155}, {"unit": "Hāe", "unit_norm": "hāe", "ipa": "hɑːːɛh", "unit_number": 154}, {"unit": "Hāā", "unit_norm": "hāā", "ipa": "hɑːːɑːː", "unit_number": 153}, {"unit": "Haā", "unit_norm": "haā", "ipa": "hɑɑːː", "unit_number": 152}, {"unit": "Hāa", "unit_norm": "hāa", "ipa": "hɑːːɑ", "unit_number": 151}, {"unit": "Huu", "unit_norm": "huu", "ipa": "hʊːʊː", "unit_number": 150}, {"unit": "Huo", "unit_norm": "huo", "ipa": "hʊːɔː", "unit_number": 149}, {"unit": "Hui", "unit_norm": "hui", "ipa": "hʊːiː", "unit_number": 148}, {"unit": "Hue", "unit_norm": "hue", "ipa": "hʊːɛh", "unit_number": 147}, {"unit": "Hua", "unit_norm": "hua", "ipa": "hʊːɑ", "unit_number": 146}, {"unit": "Hou", "unit_norm": "hou", "ipa": "hɔːʊː", "unit_number": 145}, {"unit": "Hoo", "unit_norm": "hoo", "ipa": "hɔːɔː", "unit_number": 144}, {"unit": "Hoi", "unit_norm": "hoi", "ipa": "hɔːiː", "unit_number": 143}, {"unit": "Hoe", "unit_norm": "hoe", "ipa": "hɔːɛh", "unit_number": 142}, {"unit": "Hoa", "unit_norm": "hoa", "ipa": "hɔːɑ", "unit_number": 141}, {"unit": "Hiu", "unit_norm": "hiu", "ipa": "hiːʊː", "unit_number": 140}, {"unit": "Hio", "unit_norm": "hio", "ipa": "hiːɔː", "unit_number": 139}, {"unit": "Hii", "unit_norm": "hii", "ipa": "hiːiː", "unit_number": 138}, {"unit": "Hie", "unit_norm": "hie", "ipa": "hiːɛh", "unit_number": 137}, {"unit": "Hia", "unit_norm": "hia", "ipa": "hiːɑ", "unit_number": 136}, {"unit": "Heu", "unit_norm": "heu", "ipa": "hɛhʊː", "unit_number": 135}, {"unit": "Heo", "unit_norm": "heo", "ipa": "hɛhɔː", "unit_number": 134}, {"unit": "Hei", "unit_norm": "hei", "ipa": "hɛhiː", "unit_number": 133}, {"unit": "Hee", "unit_norm": "hee", "ipa": "hɛhɛh", "unit_number": 132}, {"unit": "Hea", "unit_norm": "hea", "ipa": "hɛhɑ", "unit_number": 131}, {"unit": "Hau", "unit_norm": "hau", "ipa": "hɑʊː", "unit_number": 130}, {"unit": "Hao", "unit_norm": "hao", "ipa": "hɑɔː", "unit_number": 129}, {"unit": "Hai", "unit_norm": "hai", "ipa": "hɑiː", "unit_number": 128}, {"unit": "Hae", "unit_norm": "hae", "ipa": "hɑɛh", "unit_number": 127}, {"unit": "Haa", "unit_norm": "haa", "ipa": "hɑɑ", "unit_number": 126}, {"unit": "Hū", "unit_norm": "hū", "ipa": "huː", "unit_number": 125}, {"unit": "Hō", "unit_norm": "hō", "ipa": "hɔːr", "unit_number": 124}, {"unit": "Hī", "unit_norm": "hī", "ipa": "hiːː", "unit_number": 123}, {"unit": "Hē", "unit_norm": "hē", "ipa": "hɛː", "unit_number": 122}, {"unit": "Hā", "unit_norm": "hā", "ipa": "hɑːː", "unit_number": 121}, {"unit": "Hu", "unit_norm": "hu", "ipa": "hʊː", "unit_number": 120}, {"unit": "Ho", "unit_norm": "ho", "ipa": "hɔː", "unit_number": 119}, {"unit": "Hi", "unit_norm": "hi", "ipa": "hiː", "unit_number": 118}, {"unit": "He", "unit_norm": "he", "ipa": "hɛh", "unit_number": 117}, {"unit": "Ha", "unit_norm": "ha", "ipa": "hɑ", "unit_number": 116}, {"unit": "ūū", "unit_norm": "ūū", "ipa": "uːuː", "unit_number": 115}, {"unit": "uū", "unit_norm": "uū", "ipa": "ʊːuː", "unit_number": 114}, {"unit": "ūu", "unit_norm": "ūu", "ipa": "uːʊː", "unit_number": 113}, {"unit": "ūō", "unit_norm": "ūō", "ipa": "uːɔːr", "unit_number": 112}, {"unit": "aō", "unit_norm": "aō", "ipa": "ɑɔːr", "unit_number": 111}, {"unit": "ūo", "unit_norm": "ūo", "ipa": "uːɔː", "unit_number": 110}, {"unit": "ūī", "unit_norm": "ūī", "ipa": "uːiːː", "unit_number": 109}, {"unit": "uī", "unit_norm": "uī", "ipa": "ʊːiːː", "unit_number": 108}, {"unit": "ūi", "unit_norm": "ūi", "ipa": "uːiː", "unit_number": 107}, {"unit": "ūē", "unit_norm": "ūē", "ipa": "uːɛː", "unit_number": 106}, {"unit": "ūe", "unit_norm": "ūe", "ipa": "uːɛh", "unit_number": 105}, {"unit": "ūā", "unit_norm": "ūā", "ipa": "uːɑːː", "unit_number": 104}, {"unit": "uā", "unit_norm": "uā", "ipa": "ʊːɑːː", "unit_number": 103}, {"unit": "ūa", "unit_norm": "ūa", "ipa": "uːɑ", "unit_number": 102}, {"unit": "ōū", "unit_norm": "ōū", "ipa": "ɔːruː", "unit_number": 101}, {"unit": "oū", "unit_norm": "oū", "ipa": "ɔːuː", "unit_number": 100}, {"unit": "ōu", "unit_norm": "ōu", "ipa": "ɔːrʊː", "unit_number": 99}, {"unit": "ōō", "unit_norm": "ōō", "ipa": "ɔːrɔːr", "unit_number": 98}, {"unit": "oō", "unit_norm": "oō", "ipa": "ɔːɔːr", "unit_number": 97}, {"unit": "ōo", "unit_norm": "ōo", "ipa": "ɔːrɔː", "unit_number": 96}, {"unit": "ōī", "unit_norm": "ōī", "ipa": "ɔːriːː", "unit_number": 95}, {"unit": "oī", "unit_norm": "oī", "ipa": "ɔːiːː", "unit_number": 94}, {"unit": "ōi", "unit_norm": "ōi", "ipa": "ɔːriː", "unit_number": 93}, {"unit": "ōē", "unit_norm": "ōē", "ipa": "ɔːrɛː", "unit_number": 92}, {"unit": "ōe", "unit_norm": "ōe", "ipa": "ɔːrɛh", "unit_number": 91}, {"unit": "ōā", "unit_norm": "ōā", "ipa": "ɔːrɑːː", "unit_number": 90}, {"unit": "oā", "unit_norm": "oā", "ipa": "ɔːɑːː", "unit_number": 89}, {"unit": "ōa", "unit_norm": "ōa", "ipa": "ɔːrɑ", "unit_number": 88}, {"unit": "īū", "unit_norm": "īū", "ipa": "iːːuː", "unit_number": 87}, {"unit": "iū", "unit_norm": "iū", "ipa": "iːuː", "unit_number": 86}, {"unit": "īu", "unit_norm": "īu", "ipa": "iːːʊː", "unit_number": 85}, {"unit": "īō", "unit_norm": "īō", "ipa": "iːːɔːr", "unit_number": 84}, {"unit": "iō", "unit_norm": "iō", "ipa": "iːɔːr", "unit_number": 83}, {"unit": "īo", "unit_norm": "īo", "ipa": "iːːɔː", "unit_number": 82}, {"unit": "īī", "unit_norm": "īī", "ipa": "iːːiːː", "unit_number": 81}, {"unit": "iī", "unit_norm": "iī", "ipa": "iːiːː", "unit_number": 80}, {"unit": "īi", "unit_norm": "īi", "ipa": "iːːiː", "unit_number": 79}, {"unit": "īē", "unit_norm": "īē", "ipa": "iːːɛː", "unit_number": 78}, {"unit": "īe", "unit_norm": "īe", "ipa": "iːːɛh", "unit_number": 77}, {"unit": "īā", "unit_norm": "īā", "ipa": "iːːɑːː", "unit_number": 76}, {"unit": "iā", "unit_norm": "iā", "ipa": "iːɑːː", "unit_number": 75}, {"unit": "īa", "unit_norm": "īa", "ipa": "iːːɑ", "unit_number": 74}, {"unit": "ēū", "unit_norm": "ēū", "ipa": "ɛːuː", "unit_number": 73}, {"unit": "eū", "unit_norm": "eū", "ipa": "ɛhuː", "unit_number": 72}, {"unit": "ēu", "unit_norm": "ēu", "ipa": "ɛːʊː", "unit_number": 71}, {"unit": "ēō", "unit_norm": "ēō", "ipa": "ɛːɔːr", "unit_number": 70}, {"unit": "eō", "unit_norm": "eō", "ipa": "ɛhɔːr", "unit_number": 69}, {"unit": "ēo", "unit_norm": "ēo", "ipa": "ɛːɔː", "unit_number": 68}, {"unit": "ēī", "unit_norm": "ēī", "ipa": "ɛːiːː", "unit_number": 67}, {"unit": "eī", "unit_norm": "eī", "ipa": "ɛhiːː", "unit_number": 66}, {"unit": "ēi", "unit_norm": "ēi", "ipa": "ɛːiː", "unit_number": 65}, {"unit": "ēē", "unit_norm": "ēē", "ipa": "ɛːɛː", "unit_number": 64}, {"unit": "ēe", "unit_norm": "ēe", "ipa": "ɛːɛh", "unit_number": 63}, {"unit": "ēā", "unit_norm": "ēā", "ipa": "ɛːɑːː", "unit_number": 62}, {"unit": "eā", "unit_norm": "eā", "ipa": "ɛhɑːː", "unit_number": 61}, {"unit": "ēa", "unit_norm": "ēa", "ipa": "ɛːɑ", "unit_number": 60}, {"unit": "āū", "unit_norm": "āū", "ipa": "ɑːːuː", "unit_number": 59}, {"unit": "aū", "unit_norm": "aū", "ipa": "ɑuː", "unit_number": 58}, {"unit": "āu", "unit_norm": "āu", "ipa": "ɑːːʊː", "unit_number": 57}, {"unit": "āō", "unit_norm": "āō", "ipa": "ɑːːɔːr", "unit_number": 56}, {"unit": "aō", "unit_norm": "aō", "ipa": "ɑɔːr", "unit_number": 55}, {"unit": "āo", "unit_norm": "āo", "ipa": "ɑːːɔː", "unit_number": 54}, {"unit": "āī", "unit_norm": "āī", "ipa": "ɑːːiːː", "unit_number": 53}, {"unit": "aī", "unit_norm": "aī", "ipa": "ɑiːː", "unit_number": 52}, {"unit": "āi", "unit_norm": "āi", "ipa": "ɑːːiː", "unit_number": 51}, {"unit": "āē", "unit_norm": "āē", "ipa": "ɑːːɛː", "unit_number": 50}, {"unit": "āe", "unit_norm": "āe", "ipa": "ɑːːɛh", "unit_number": 49}, {"unit": "āā", "unit_norm": "āā", "ipa": "ɑːːɑːː", "unit_number": 48}, {"unit": "aā", "unit_norm": "aā", "ipa": "ɑɑːː", "unit_number": 47}, {"unit": "āa", "unit_norm": "āa", "ipa": "ɑːːɑ", "unit_number": 46}, {"unit": "uu", "unit_norm": "uu", "ipa": "ʊːʊː", "unit_number": 45}, {"unit": "uo", "unit_norm": "uo", "ipa": "ʊːɔː", "unit_number": 44}, {"unit": "ui", "unit_norm": "ui", "ipa": "ʊːiː", "unit_number": 43}, {"unit": "ue", "unit_norm": "ue", "ipa": "ʊːɛh", "unit_number": 42}, {"unit": "ua", "unit_norm": "ua", "ipa": "ʊːɑ", "unit_number": 41}, {"unit": "ou", "unit_norm": "ou", "ipa": "ɔːʊː", "unit_number": 40}, {"unit": "oo", "unit_norm": "oo", "ipa": "ɔːɔː", "unit_number": 39}, {"unit": "oi", "unit_norm": "oi", "ipa": "ɔːiː", "unit_number": 38}, {"unit": "oe", "unit_norm": "oe", "ipa": "ɔːɛh", "unit_number": 37}, {"unit": "oa", "unit_norm": "oa", "ipa": "ɔːɑ", "unit_number": 36}, {"unit": "iu", "unit_norm": "iu", "ipa": "iːʊː", "unit_number": 35}, {"unit": "io", "unit_norm": "io", "ipa": "iːɔː", "unit_number": 34}, {"unit": "ii", "unit_norm": "ii", "ipa": "iːiː", "unit_number": 33}, {"unit": "ie", "unit_norm": "ie", "ipa": "iːɛh", "unit_number": 32}, {"unit": "ia", "unit_norm": "ia", "ipa": "iːɑ", "unit_number": 31}, {"unit": "eu", "unit_norm": "eu", "ipa": "ɛhʊː", "unit_number": 30}, {"unit": "eo", "unit_norm": "eo", "ipa": "ɛhɔː", "unit_number": 29}, {"unit": "ei", "unit_norm": "ei", "ipa": "ɛhiː", "unit_number": 28}, {"unit": "ee", "unit_norm": "ee", "ipa": "ɛhɛh", "unit_number": 27}, {"unit": "ea", "unit_norm": "ea", "ipa": "ɛhɑ", "unit_number": 26}, {"unit": "au", "unit_norm": "au", "ipa": "ɑʊː", "unit_number": 25}, {"unit": "ao", "unit_norm": "ao", "ipa": "ɑɔː", "unit_number": 24}, {"unit": "ai", "unit_norm": "ai", "ipa": "ɑiː", "unit_number": 23}, {"unit": "ae", "unit_norm": "ae", "ipa": "ɑɛh", "unit_number": 22}, {"unit": "aa", "unit_norm": "aa", "ipa": "ɑɑ", "unit_number": 21}, {"unit": "ū", "unit_norm": "ū", "ipa": "uː", "unit_number": 20}, {"unit": "ō", "unit_norm": "ō", "ipa": "ɔːr", "unit_number": 19}, {"unit": "ī", "unit_norm": "ī", "ipa": "iːː", "unit_number": 18}, {"unit": "ē", "unit_norm": "ē", "ipa": "ɛː", "unit_number": 17}, {"unit": "ā", "unit_norm": "ā", "ipa": "ɑːː", "unit_number": 16}, {"unit": "u", "unit_norm": "u", "ipa": "ʊː", "unit_number": 15}, {"unit": "o", "unit_norm": "o", "ipa": "ɔː", "unit_number": 14}, {"unit": "i", "unit_norm": "i", "ipa": "iː", "unit_number": 13}, {"unit": "e", "unit_norm": "e", "ipa": "ɛh", "unit_number": 12}, {"unit": "a", "unit_norm": "a", "ipa": "ɑ", "unit_number": 11}, {"unit": "wh", "unit_norm": "wh", "ipa": "f", "unit_number": 10}, {"unit": "ng", "unit_norm": "ng", "ipa": "ŋˤŋ", "unit_number": 9}, {"unit": "w", "unit_norm": "w", "ipa": "w", "unit_number": 8}, {"unit": "t", "unit_norm": "t", "ipa": "t", "unit_number": 7}, {"unit": "r", "unit_norm": "r", "ipa": ".ɾ͡d", "unit_number": 6}, {"unit": "p", "unit_norm": "p", "ipa": "p", "unit_number": 5}, {"unit": "n", "unit_norm": "n", "ipa": "n", "unit_number": 4}, {"unit": "m", "unit_norm": "m", "ipa": "m", "unit_number": 3}, {"unit": "k", "unit_norm": "k", "ipa": "k", "unit_number": 2}, {"unit": "h", "unit_norm": "h", "ipa": "h", "unit_number": 1}];

  function buildLexiconIndex(rows){
    const byUnit = new Map();
    for(const r of (rows||[])){
      const key = (r.unit_norm || String(r.unit||'').trim().toLowerCase());
      if(!key) continue;
      if(!byUnit.has(key)) byUnit.set(key, []);
      byUnit.get(key).push(r);
    }
    // Sort each bucket by unit_number descending (prefer higher Unit Number)
    for(const [k, arr] of byUnit.entries()){
      arr.sort((a,b)=> (b.unit_number ?? -1e12) - (a.unit_number ?? -1e12));
    }
    return byUnit;
  }

  const LEXICON_BY_UNIT = buildLexiconIndex(LEXICON_ROWS);

  function getLexiconMatches(unit){
    const key = String(unit||'').trim().toLowerCase();
    return LEXICON_BY_UNIT.get(key) || [];
  }

  function chooseDefaultMatch(matches){
    if(!matches || !matches.length) return null;
    return matches[0];
  }

  function joinIpa(parts, mode){
    const segs = (parts||[]).map(x=>String(x||'')).filter(Boolean);
    if(!segs.length) return '';
    if(mode === 'none') return segs.join('');
    if(mode === 'dot') return segs.join('.');
    return segs.join(' '); // default: space
  }

  // Regression baseline tests
  const BASELINE_TESTS = [
    { name: 'pou + a + ka + roa', expected: ['pou','a','ka','roa'] },
    { name: 'a + whi + na', expected: ['a','whi','na'] },
    { name: 'ma + nga + tai + o + re', expected: ['ma','nga','tai','o','re'] },
    { name: 'wha + nga + tau + a + tia', expected: ['wha','nga','tau','a','tia'] },
    { name: 'pi + pi + wha + rau + roa', expected: ['pi','pi','wha','rau','roa'] },
    { name: 'hai + ti + tai + ma + ra + ngai', expected: ['hai','ti','tai','ma','ra','ngai'] },
    { name: 'ho + ro + mai + te + meu + ka + re + nga + whei', expected: ['ho','ro','mai','te','meu','ka','re','nga','whei'] },
    { name: 'tu + po + rou + ngae + wha + ka', expected: ['tu','po','rou','ngae','wha','ka'] },
    { name: 'tu + po + rou + wha + ka + ngae', expected: ['tu','po','rou','wha','ka','ngae'] },
    { name: 'wha + ka + ua + ua', expected: ['wha','ka','ua','ua'] },
    { name: 'mo + rou + mo + ngai + te', expected: ['mo','rou','mo','ngai','te'] },
    { name: 'ta + hio + na', expected: ['ta','hio','na'] },
    { name: 'o + ta + nga + rei', expected: ['o','ta','nga','rei'] },
    { name: 'o + po + ti + ki', expected: ['o','po','ti','ki'] },
    { name: 'nga + rua + wa + hia', expected: ['nga','rua','wa','hia'] },
    { name: 'pa + ma + pu + ria', expected: ['pa','ma','pu','ria'] },
    { name: 'nga + tae + a', expected: ['nga','tae','a'] },
    { name: 'wha + rea + na', expected: ['wha','rea','na'] },
    { name: 'o + ria + tou', expected: ['o','ria','tou'] },
    { name: 'ma + ta + whe + ro + hia', expected: ['ma','ta','whe','ro','hia'] },
    { name: 'wai + pou + a', expected: ['wai','pou','a'] },
    { name: 'o + hae + a + wai', expected: ['o','hae','a','wai'] }
  ];

  // UI State
  const state = {
    page: 'regression',
    results: null,
    selected: null,
    query: '',
    showTrace: true,
    showOnlyFails: false,
    selectedRuleId: 'V8-R04'
  };

  function makeDefaultTestsPayload(){
    return BASELINE_TESTS.map(t => ({
      name: t.name,
      word: deriveWordFromExpected(t.expected),
      expected: t.expected
    }));
  }

  function setActiveTab(tab){
    state.page = tab;
    document.getElementById('tabRegression').classList.toggle('active', tab === 'regression');
    document.getElementById('tabDemo').classList.toggle('active', tab === 'demo');
    document.getElementById('tabG2P').classList.toggle('active', tab === 'g2p');
    document.getElementById('tabG2PAwsTts').classList.toggle('active', tab === 'g2pAwsTts');
    document.getElementById('tabIpaLookupKeyboard').classList.toggle('active', tab === 'ipaLookupKeyboard');
    document.getElementById('tabSTT').classList.toggle('active', tab === 'stt');
    document.getElementById('tabDetect').classList.toggle('active', tab === 'detect');
    document.getElementById('tabDetectBlock').classList.toggle('active', tab === 'detectBlock');
    document.getElementById('tabRules').classList.toggle('active', tab === 'rules');

    document.getElementById('pageRegression').classList.toggle('hidden', tab !== 'regression');
    document.getElementById('pageDemo').classList.toggle('hidden', tab !== 'demo');

    document.getElementById('pageG2P').classList.toggle('hidden', tab !== 'g2p');

    document.getElementById('pageG2PAwsTts').classList.toggle('hidden', tab !== 'g2pAwsTts');

    document.getElementById('pageIpaLookupKeyboard').classList.toggle('hidden', tab !== 'ipaLookupKeyboard');
    document.getElementById('pageSTT').classList.toggle('hidden', tab !== 'stt');

    document.getElementById('pageDetect').classList.toggle('hidden', tab !== 'detect');
    document.getElementById('pageDetectBlock').classList.toggle('hidden', tab !== 'detectBlock');
    document.getElementById('pageRules').classList.toggle('hidden', tab !== 'rules');
  }

  function openRule(ruleId){
    if(ruleId && RULE_BY_ID.has(ruleId)){
      state.selectedRuleId = ruleId;
      renderRules();
      setActiveTab('rules');
      return;
    }
    // If unknown, still show rules tab
    state.selectedRuleId = ruleId || state.selectedRuleId;
    renderRules();
    setActiveTab('rules');
  }

  function runTestsFromTextarea(textareaEl, summaryEl){
    const raw = textareaEl.value.trim();
    const parsed = safeJsonParse(raw);
    if(!parsed.ok){
      summaryEl.innerHTML = `<span class="tag bad">Invalid JSON</span> <span class="muted">${escapeHtml(parsed.error)}</span>`;
      state.results = null;
      state.selected = null;
      return;
    }

    const tests = Array.isArray(parsed.value) ? parsed.value : [];
    const t0 = performance.now();

    const results = {
      ranAtIso: new Date().toISOString(),
      runtimeMs: 0,
      tests: []
    };

    for(const test of tests){
      const expectedRaw = test.expected ?? test.expectedSegments ?? test.segments ?? [];
      const expected = normalizeSegments(Array.isArray(expectedRaw) ? expectedRaw : String(expectedRaw).split('+'));
      const word = normalizeWord(test.word || deriveWordFromExpected(expected));
      const name = test.name || word;

      const out = segmentWordCore(word, { trace: true });
      const actual = normalizeSegments(out.segments);
      const pass = expected.length === actual.length && expected.every((v, i) => v === actual[i]);

      results.tests.push({
        name,
        word,
        expected,
        actual,
        pass,
        diff: pass ? '' : buildDiff(expected, actual),
        prefix: out.prefix,
        middle: out.middle,
        suffix: out.suffix,
        ruleIds: out.ruleIds,
        trace: out.trace
      });
    }

    results.runtimeMs = Math.round(performance.now() - t0);
    state.results = results;
    state.selected = results.tests[0] || null;

    return results;
  }

  function renderRegression(){
    const root = document.getElementById('pageRegression');
    root.innerHTML = '';

    const testsText = loadFromStorage(STORAGE_KEYS.tests);
    const initialTests = testsText ? testsText : JSON.stringify(makeDefaultTestsPayload(), null, 2);

    const header = el('div', {class:'card'});
    header.appendChild(el('h2', {}, ['Regression (V12 Run)']));
    header.appendChild(el('p', {}, ['Edit tests, run them against the live v12 segmenter, then inspect failures with trace. Rule pills show what fired for the selected result.']));

    const tagsRow = el('div', {class:'row'});
    tagsRow.appendChild(el('span', {class:'tag'}, ['segmenter: v12']));
    tagsRow.appendChild(el('span', {class:'tag'}, ['trace: enabled']));
    tagsRow.appendChild(el('span', {class:'tag'}, ['history: demo + regression']));
    header.appendChild(tagsRow);

    root.appendChild(header);

    const quickRulesCard = el('div', {class:'card'});
    quickRulesCard.appendChild(el('h3', {}, ['Rules Quick View']));
    quickRulesCard.appendChild(el('p', {}, ['All rules are available in the Rules tab. Click any pill here to open its explanation.']));

    const quickPills = el('div', {class:'pillGrid'});
    for(const r of RULES){
      const b = el('button', {type:'button', class:'tag', title: `${r.title}`, onclick: ()=> openRule(r.id) }, [r.id]);
      quickPills.appendChild(b);
    }
    quickRulesCard.appendChild(quickPills);
    root.appendChild(quickRulesCard);

    const testsCard = el('div', {class:'card'});
    testsCard.appendChild(el('h3', {}, ['Tests JSON']));

    const testsArea = el('textarea', {id:'testsJson', spellcheck:'false'});
    testsArea.value = initialTests;

    const summary = el('div', {class:'row', id:'runSummary'});

    const btnLoad = el('button', {class:'btn', type:'button', onclick:()=>{
      testsArea.value = JSON.stringify(makeDefaultTestsPayload(), null, 2);
      saveToStorage(STORAGE_KEYS.tests, testsArea.value);
      summary.innerHTML = `<span class="tag">Baseline Loaded</span> <span class="muted">Ready to run tests</span>`;
      state.results = null;
      state.selected = null;
      drawListAndDetails();
      if(window.__drawTestsList) window.__drawTestsList();
    }}, ['Load Baseline']);

    const btnSave = el('button', {class:'btn', type:'button', onclick:()=>{
      const ok = saveToStorage(STORAGE_KEYS.tests, testsArea.value);
      summary.innerHTML = ok
        ? `<span class="tag good">Saved</span> <span class="muted">Saved tests to localStorage</span>`
        : `<span class="tag bad">Not Saved</span> <span class="muted">Could not access localStorage</span>`;
    }}, ['Save Tests']);

    const btnRun = el('button', {class:'btn primary', type:'button', onclick:()=>{
      saveToStorage(STORAGE_KEYS.tests, testsArea.value);
      const res = runTestsFromTextarea(testsArea, summary);
      if(res){
        const total = res.tests.length;
        const pass = res.tests.filter(t=>t.pass).length;
        const fail = total - pass;
        summary.innerHTML = `${fail ? '<span class="tag bad">Fail</span>' : '<span class="tag good">Pass</span>'} ` +
          `<span class="tag">${pass} passed</span> <span class="tag ${fail ? 'bad' : 'good'}">${fail} failed</span> ` +
          `<span class="tag">${total} total</span> <span class="tag">${res.runtimeMs} ms</span>`;
        // Record run history (manual runs only)
        try{
          const testsSig = simpleHash(String(testsArea.value || ''));
          const failures = res.tests.filter(t=>!t.pass).map(t=>({
            word: t.word,
            name: t.name,
            expectedStr: segmentsToString(t.expected || []),
            actualStr: segmentsToString(t.actual || []),
            diff: t.diff || ''
          }));
          addRegressionRunHistoryEntry({
            tsIso: new Date().toISOString(),
            total: total,
            passCount: pass,
            failCount: fail,
            runtimeMs: res.runtimeMs,
            testsSig: testsSig,
            failures: failures.slice(0, 200)
          });
          if(window.__drawRegressionRunHistory) window.__drawRegressionRunHistory();
        }catch(_){ /* ignore */ }

        drawListAndDetails();
      if(window.__drawTestsList) window.__drawTestsList();
      }
    }}, ['Run Tests']);

    const btnDownload = el('button', {class:'btn', type:'button', onclick:()=>{
      const data = state.results || { error: 'No results yet. Run tests first.' };
      downloadText('segmenter_v12_regression_results.json', JSON.stringify(data, null, 2), 'application/json');
    }}, ['Download Results']);

    const btnImport = el('button', {class:'btn', type:'button', onclick:()=>{ fileInput.click(); }}, ['Import Results']);

    const fileInput = el('input', {type:'file', accept:'application/json', class:'hidden'});
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const txt = await f.text();
      const parsed = safeJsonParse(txt);
      if(!parsed.ok){
        summary.innerHTML = `<span class="tag bad">Invalid JSON</span> <span class="muted">${escapeHtml(parsed.error)}</span>`;
        return;
      }
      state.results = parsed.value;
      state.selected = (state.results && state.results.tests && state.results.tests[0]) ? state.results.tests[0] : null;
      const total = (state.results.tests || []).length;
      const pass = (state.results.tests || []).filter(t=>t.pass).length;
      const fail = total - pass;
      summary.innerHTML = `<span class="tag">Imported</span> <span class="tag">${pass} passed</span> <span class="tag ${fail ? 'bad' : 'good'}">${fail} failed</span> <span class="tag">${total} total</span>`;
      drawListAndDetails();
      if(window.__drawTestsList) window.__drawTestsList();
      fileInput.value = '';
    });

    const traceToggle = el('button', {class:'btn', type:'button', onclick:()=>{
      state.showTrace = !state.showTrace;
      traceToggle.textContent = state.showTrace ? 'Trace On' : 'Trace Off';
      drawDetails();
    }}, ['Trace On']);

    const onlyFailsToggle = el('button', {class:'btn', type:'button', onclick:()=>{
      state.showOnlyFails = !state.showOnlyFails;
      onlyFailsToggle.textContent = state.showOnlyFails ? 'Fails Only' : 'All Tests';
      drawList();
    }}, ['All Tests']);

    const search = el('input', {type:'search', placeholder:'Search word or name...', value: state.query});
    search.addEventListener('input', (e)=>{ state.query = e.target.value; drawList(); });

    const check = el('label', {class:'checkbox'});
    const checkInput = el('input', {type:'checkbox'});
    checkInput.checked = true;
    checkInput.addEventListener('change', ()=>{
      state.showTrace = checkInput.checked;
      traceToggle.textContent = state.showTrace ? 'Trace On' : 'Trace Off';
      drawDetails();
    });
    check.appendChild(checkInput);
    check.appendChild(document.createTextNode('Show Trace'));

    const controls = el('div', {class:'controls'});
    controls.appendChild(search);
    controls.appendChild(btnLoad);
    controls.appendChild(btnSave);
    controls.appendChild(btnRun);
    controls.appendChild(btnDownload);

    const controls2 = el('div', {class:'row', style:'margin-top:10px; gap:8px;'});
    controls2.appendChild(btnImport);
    controls2.appendChild(traceToggle);
    controls2.appendChild(onlyFailsToggle);
    controls2.appendChild(check);
    controls2.appendChild(fileInput);

    testsCard.appendChild(controls);
    testsCard.appendChild(controls2);
    testsCard.appendChild(el('div', {style:'margin-top:10px;'}));
    testsCard.appendChild(testsArea);
    testsCard.appendChild(el('div', {style:'margin-top:10px;'}));
    testsCard.appendChild(summary);

    root.appendChild(testsCard);

    // Regression run history
    const runHistCard = el('div', {class:'card'});
    runHistCard.appendChild(el('h3', {}, ['Regression Run History']));
    runHistCard.appendChild(el('p', {}, ['Tracks manual test runs (not auto-runs). Click a row to view details.']));

    const runHistControls = el('div', {class:'row', style:'gap:8px; flex-wrap:wrap;'});

    const btnRunHistClear = el('button', {class:'btn', type:'button', onclick:()=>{
      saveRegressionRunHistory([]);
      drawRegressionRunHistory();
    }}, ['Clear Run History']);

    const btnRunHistExport = el('button', {class:'btn', type:'button', onclick:()=>{
      const items = loadRegressionRunHistory();
      downloadText('segmenter_v12_regression_run_history.json', JSON.stringify(items, null, 2), 'application/json');
    }}, ['Export Run History']);

    const runHistFile = el('input', {type:'file', accept:'application/json', class:'hidden'});

    const btnRunHistImport = el('button', {class:'btn', type:'button', onclick:()=> runHistFile.click() }, ['Import Run History']);

    runHistFile.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const txt = await f.text();
      const parsed = safeJsonParse(txt);
      if(!parsed.ok || !Array.isArray(parsed.value)) return;
      saveRegressionRunHistory(parsed.value);
      drawRegressionRunHistory();
      runHistFile.value = '';
    });

    runHistControls.appendChild(btnRunHistClear);
    runHistControls.appendChild(btnRunHistExport);
    runHistControls.appendChild(btnRunHistImport);
    runHistControls.appendChild(runHistFile);

    const runHistWrap = el('div', {style:'margin-top:10px;'});
    const runHistDetail = el('div', {style:'margin-top:10px;'});

    function drawRegressionRunHistory(){
      runHistWrap.innerHTML = '';
      runHistDetail.innerHTML = '';
      const items = loadRegressionRunHistory();
      if(!items.length){
        runHistWrap.appendChild(el('p', {}, ['No run history yet. Click Run Tests to record a run.']));
        return;
      }

      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['When']),
        el('th', {}, ['Status']),
        el('th', {}, ['Pass']),
        el('th', {}, ['Fail']),
        el('th', {}, ['Ms']),
        el('th', {}, ['Suite'])
      ]));
      tbl.appendChild(thead);

      const tbody = el('tbody');
      for(const it of items){
        const tr = el('tr');
        tr.addEventListener('click', ()=>{
          // Render details
          const failList = Array.isArray(it.failures) ? it.failures : [];
          let html = '';
          html += `<div class="card">`;
          html += `<div class="row">` +
            `${it.failCount ? '<span class="tag bad">Fail</span>' : '<span class="tag good">Pass</span>'}` +
            `<span class="tag">${escapeHtml(it.tsIso || '')}</span>` +
            `<span class="tag">total: ${escapeHtml(String(it.total ?? ''))}</span>` +
            `<span class="tag good">pass: ${escapeHtml(String(it.passCount ?? ''))}</span>` +
            `<span class="tag ${it.failCount ? 'bad' : 'good'}">fail: ${escapeHtml(String(it.failCount ?? ''))}</span>` +
            `<span class="tag">${escapeHtml(String(it.runtimeMs ?? ''))} ms</span>` +
            `<span class="tag">suite: ${escapeHtml(it.testsSig || '')}</span>` +
          `</div>`;

          if(it.note){
            html += `<p class="muted">${escapeHtml(it.note)}</p>`;
          }

          if(!failList.length){
            html += `<p>No failures recorded for this run.</p>`;
          } else {
            html += `<h3>Failures</h3>`;
            html += `<table><thead><tr><th>Word</th><th>Name</th><th>Expected</th><th>Actual</th></tr></thead><tbody>`;
            for(const f of failList.slice(0, 100)){
              html += `<tr>` +
                `<td class="mono">${escapeHtml(f.word || '')}</td>` +
                `<td>${escapeHtml(f.name || '')}</td>` +
                `<td class="mono">${escapeHtml(f.expectedStr || '')}</td>` +
                `<td class="mono">${escapeHtml(f.actualStr || '')}</td>` +
              `</tr>`;
            }
            html += `</tbody></table>`;
          }

          html += `</div>`;
          runHistDetail.innerHTML = html;
        });

        const when = (it.tsIso || '').replace('T',' ').replace('Z','');
        tr.appendChild(el('td', {class:'mono'}, [when]));
        tr.appendChild(el('td', {}, [it.failCount ? 'fail' : 'pass']));
        tr.appendChild(el('td', {}, [String(it.passCount ?? '')]));
        tr.appendChild(el('td', {}, [String(it.failCount ?? '')]));
        tr.appendChild(el('td', {}, [String(it.runtimeMs ?? '')]));
        tr.appendChild(el('td', {class:'mono'}, [it.testsSig || '']));
        tbody.appendChild(tr);
      }

      tbl.appendChild(tbody);
      runHistWrap.appendChild(tbl);
    }

    // Expose and init
    window.__drawRegressionRunHistory = drawRegressionRunHistory;

    runHistCard.appendChild(runHistControls);
    runHistCard.appendChild(runHistWrap);
    runHistCard.appendChild(runHistDetail);

    root.appendChild(runHistCard);

    // initial draw
    drawRegressionRunHistory();

    // Add tests + history
    // Add tests + history
    const addCard = el('div', {class:'card'});
    addCard.appendChild(el('h3', {}, ['Add Test Word']));
    addCard.appendChild(el('p', {}, ['Add or update a single test entry without manually editing JSON. You can auto-fill expected segments from the live segmenter, then lock them into the suite.']));

    const addRow1 = el('div', {class:'controls'});
    const addWord = el('input', {type:'text', placeholder:'Word (e.g., mangataiore)', value:''});
    const addName = el('input', {type:'text', placeholder:'Name (optional)', value:''});
    addRow1.appendChild(addWord);
    addRow1.appendChild(addName);

    const addRow2 = el('div', {class:'controls', style:'margin-top:10px;'});
    const addExpected = el('input', {type:'text', placeholder:'Expected segments (use +). Example: ma + nga + tai + o + re', value:''});
    addRow2.appendChild(addExpected);

    const addSummary = el('div', {class:'row', style:'margin-top:10px;'});
    addSummary.innerHTML = '<span class="tag">Tip</span> <span class="muted">Use “Fill From Segmenter” to capture the current v12 output as the expected baseline.</span>';

    let lastFillWasAuto = false;

    const addBtns = el('div', {class:'row', style:'margin-top:10px; gap:8px; flex-wrap:wrap;'});

    const btnFillExpected = el('button', {class:'btn', type:'button', onclick:()=>{
      const w = normalizeWord(addWord.value || '');
      if(!w){
        addSummary.innerHTML = '<span class="tag bad">Missing Word</span> <span class="muted">Enter a word to segment.</span>';
        return;
      }
      const out = segmentWordCore(w, { trace:false });
      addExpected.value = segmentsToString(out.segments || []);
      lastFillWasAuto = true;
      addSummary.innerHTML = '<span class="tag good">Filled</span> <span class="muted">Expected segments set from v12 output.</span>';
    }}, ['Fill From Segmenter']);

    const btnAddTest = el('button', {class:'btn primary', type:'button', onclick:()=>{
      const w = normalizeWord(addWord.value || '');
      if(!w){
        addSummary.innerHTML = '<span class="tag bad">Missing Word</span> <span class="muted">Enter a word.</span>';
        return;
      }
      const expStr = String(addExpected.value || '').trim();
      if(!expStr){
        addSummary.innerHTML = '<span class="tag bad">Missing Expected</span> <span class="muted">Fill or type expected segments.</span>';
        return;
      }
      const expected = normalizeSegments(expStr.split('+'));
      const name = String(addName.value || '').trim() || w;

      const parsed = safeJsonParse(testsArea.value.trim() || '[]');
      if(!parsed.ok){
        addSummary.innerHTML = '<span class="tag bad">Invalid Tests JSON</span> <span class="muted">Fix the Tests JSON area before adding.</span>';
        return;
      }
      const arr = Array.isArray(parsed.value) ? parsed.value : [];
      const idx = arr.findIndex(t => normalizeWord(t.word || '') === w);
      const entry = { name, word: w, expected };
      const action = idx >= 0 ? 'update' : 'add';
      if(idx >= 0) arr[idx] = entry; else arr.push(entry);

      testsArea.value = JSON.stringify(arr, null, 2);
      saveToStorage(STORAGE_KEYS.tests, testsArea.value);

      // Save history
      const actualNow = segmentWordCore(w, { trace:false }).segments || [];
      addRegressionHistoryEntry({
        tsIso: new Date().toISOString(),
        action,
        word: w,
        name,
        expected,
        expectedStr: segmentsToString(expected),
        actualAtAdd: normalizeSegments(actualNow),
        source: lastFillWasAuto ? 'auto-fill' : 'manual'
      });
      lastFillWasAuto = false;

      addSummary.innerHTML = '<span class="tag good">' + (action === 'add' ? 'Added' : 'Updated') + '</span> <span class="muted">Saved to Tests JSON and history.</span>';
      drawRegressionHistory();
      if(window.__drawTestsList) window.__drawTestsList();
    }}, ['Add Or Update Test']);

    const btnClearAdd = el('button', {class:'btn', type:'button', onclick:()=>{
      addWord.value = '';
      addName.value = '';
      addExpected.value = '';
      lastFillWasAuto = false;
      addSummary.innerHTML = '<span class="tag">Tip</span> <span class="muted">Use “Fill From Segmenter” to capture the current v12 output as the expected baseline.</span>';
    }}, ['Clear']);

    addBtns.appendChild(btnFillExpected);
    addBtns.appendChild(btnAddTest);
    addBtns.appendChild(btnClearAdd);

    addCard.appendChild(addRow1);
    addCard.appendChild(addRow2);
    addCard.appendChild(addBtns);
    addCard.appendChild(addSummary);


    // Bulk add tests
    const bulkCard = el('div', {class:'card'});
    bulkCard.appendChild(el('h3', {}, ['Bulk Add Words']));
    bulkCard.appendChild(el('p', {}, ['Paste many words to add tests quickly. Bulk add captures the current v12 segmentation output as the expected baseline for each word.']));

    const bulkArea = el('textarea', {spellcheck:'false', placeholder:'One word per line, or paste a space separated list.\n\nExample:\nwhakapapa\nmangataiore\nwhaungaatia'});
    bulkArea.style.minHeight = '140px';

    const bulkControls = el('div', {class:'row', style:'gap:8px; flex-wrap:wrap; margin-top:10px;'});
    const bulkUpdateLabel = el('label', {class:'checkbox'});
    const bulkUpdateExisting = el('input', {type:'checkbox'});
    bulkUpdateExisting.checked = false;
    bulkUpdateLabel.appendChild(bulkUpdateExisting);
    bulkUpdateLabel.appendChild(document.createTextNode('Update existing tests'));

    const bulkKeepDuplicatesLabel = el('label', {class:'checkbox'});
    const bulkAllowDupInPaste = el('input', {type:'checkbox'});
    bulkAllowDupInPaste.checked = false;
    bulkKeepDuplicatesLabel.appendChild(bulkAllowDupInPaste);
    bulkKeepDuplicatesLabel.appendChild(document.createTextNode('Allow duplicates in paste'));

    const bulkSummary = el('div', {class:'row', style:'margin-top:10px;'});
    bulkSummary.innerHTML = '<span class="tag">Tip</span> <span class="muted">Bulk add uses the segmenter output as expected segments. Use the list editor to refine expected segments later.</span>';

    function extractBulkWords(raw){
      const txt = String(raw || '');
      const tokens = txt
        .split(/[\n\r]+/)
        .flatMap(line => line.split(/[\s,]+/));
      const out = [];
      for(const tok of tokens){
        // Keep letters/macrons and strip leading/trailing punctuation
        const w = normalizeWord(tok).replace(/^[^a-zāēīōū]+|[^a-zāēīōū]+$/g,'');
        if(w) out.push(w);
      }
      return out;
    }

const btnBulkAdd = el('button', {class:'btn primary', type:'button', onclick:()=>{
      const parsed = safeJsonParse(String(testsArea.value || '').trim() || '[]');
      if(!parsed.ok){
        bulkSummary.innerHTML = '<span class="tag bad">Invalid Tests JSON</span> <span class="muted">Fix the Tests JSON area before bulk adding.</span>';
        return;
      }
      const arr = Array.isArray(parsed.value) ? parsed.value : [];

      const wordsRaw = extractBulkWords(bulkArea.value || '');
      if(!wordsRaw.length){
        bulkSummary.innerHTML = '<span class="tag bad">No Words</span> <span class="muted">Paste one or more words first.</span>';
        return;
      }

      const seen = new Set();
      let added = 0;
      let updated = 0;
      let skipped = 0;
      let dupPaste = 0;

      for(const w0 of wordsRaw){
        const w = normalizeWord(w0);
        if(!w) continue;
        if(seen.has(w) && !bulkAllowDupInPaste.checked){
          dupPaste += 1;
          continue;
        }
        seen.add(w);

        const idx = arr.findIndex(t => normalizeWord(t.word || '') === w);
        if(idx >= 0 && !bulkUpdateExisting.checked){
          skipped += 1;
          continue;
        }

        const outSeg = segmentWordCore(w, {trace:false});
        const expected = normalizeSegments(outSeg.segments || []);
        const entry = { name: w, word: w, expected };

        const action = (idx >= 0) ? 'update' : 'add';
        if(idx >= 0) {
          arr[idx] = entry;
          updated += 1;
        } else {
          arr.push(entry);
          added += 1;
        }

        // History
        addRegressionHistoryEntry({
          tsIso: new Date().toISOString(),
          action,
          word: w,
          name: w,
          expected,
          expectedStr: segmentsToString(expected),
          actualAtAdd: normalizeSegments((segmentWordCore(w, {trace:false}).segments || [])),
          source: 'bulk'
        });
      }

      testsArea.value = JSON.stringify(arr, null, 2);
      saveToStorage(STORAGE_KEYS.tests, testsArea.value);

      bulkSummary.innerHTML = '<span class="tag good">Bulk Done</span> ' +
        '<span class="tag">added: ' + added + '</span> ' +
        '<span class="tag">updated: ' + updated + '</span> ' +
        '<span class="tag">skipped: ' + skipped + '</span> ' +
        (dupPaste ? '<span class="tag">dupe-in-paste: ' + dupPaste + '</span> ' : '') +
        '<span class="muted">Saved suite and added history entries.</span>';

      if(window.__drawRegressionHistory) window.__drawRegressionHistory();
      if(window.__drawTestsList) window.__drawTestsList();
    }}, ['Bulk Add From Segmenter']);

    const btnBulkClear = el('button', {class:'btn', type:'button', onclick:()=>{
      bulkArea.value = '';
      bulkSummary.innerHTML = '<span class="tag">Tip</span> <span class="muted">Bulk add uses the segmenter output as expected segments. Use the list editor to refine expected segments later.</span>';
    }}, ['Clear']);

    bulkControls.appendChild(btnBulkAdd);
    bulkControls.appendChild(btnBulkClear);
    bulkControls.appendChild(bulkUpdateLabel);
    bulkControls.appendChild(bulkKeepDuplicatesLabel);

    bulkCard.appendChild(bulkArea);
    bulkCard.appendChild(bulkControls);
    bulkCard.appendChild(bulkSummary);

    // Tests list editor
    const testsListCard = el('div', {class:'card'});
    testsListCard.appendChild(el('h3', {}, ['Edit Tests List']));
    testsListCard.appendChild(el('p', {}, ['Edit and delete test entries without touching JSON. Click a row to load it into the Add Test Word form.']));

    const testsListControls = el('div', {class:'row', style:'gap:8px; flex-wrap:wrap;'});
    const btnRefreshList = el('button', {class:'btn', type:'button', onclick:()=> drawTestsList() }, ['Refresh List']);
    const btnSortList = el('button', {class:'btn', type:'button', onclick:()=>{ state.__testsListSort = state.__testsListSort === 'word' ? 'none' : 'word'; drawTestsList(); }}, ['Sort By Word']);
    testsListControls.appendChild(btnRefreshList);
    testsListControls.appendChild(btnSortList);

    const testsListWrap = el('div', {style:'margin-top:10px;'});

    function drawTestsList(){
      testsListWrap.innerHTML = '';
      const parsed = safeJsonParse(String(testsArea.value || '').trim() || '[]');
      if(!parsed.ok){
        testsListWrap.appendChild(el('p', {}, ['Tests JSON is invalid. Fix the JSON before editing the list.']));
        return;
      }
      const arr = Array.isArray(parsed.value) ? parsed.value : [];
      if(!arr.length){
        testsListWrap.appendChild(el('p', {}, ['No tests found. Load baseline or add a test.']));
        return;
      }

      let list = arr.slice();
      if(state.__testsListSort === 'word'){
        list.sort((a,b)=> String(a.word||'').localeCompare(String(b.word||'')));
      }

      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['Word']),
        el('th', {}, ['Name']),
        el('th', {}, ['Expected']),
        el('th', {}, ['Actions'])
      ]));
      tbl.appendChild(thead);

      const tbody = el('tbody');
      for(const t of list){
        const word = normalizeWord(t.word || '');
        const name = String(t.name || word || '').trim() || word;
        const expectedArr = Array.isArray(t.expected) ? t.expected : (Array.isArray(t.expectedSegments) ? t.expectedSegments : []);
        const expectedStr = segmentsToString(normalizeSegments(expectedArr));

        const tr = el('tr');
        tr.addEventListener('click', ()=>{
          addWord.value = word;
          addName.value = name;
          addExpected.value = expectedStr;
          addSummary.innerHTML = '<span class="tag">Loaded</span> <span class="muted">Loaded from list. Edit fields then click Add Or Update Test.</span>';
        });

        const wordInput = el('input', {type:'text', value: word});
        wordInput.className = 'mono';
        wordInput.addEventListener('click', (e)=> e.stopPropagation());
        const wordCell = el('td');
        wordCell.appendChild(wordInput);
        tr.appendChild(wordCell);

        const nameInput = el('input', {type:'text', value: name});
        nameInput.addEventListener('click', (e)=> e.stopPropagation());
        const nameCell = el('td');
        nameCell.appendChild(nameInput);
        tr.appendChild(nameCell);

        const expInput = el('input', {type:'text', value: expectedStr});
        expInput.addEventListener('click', (e)=> e.stopPropagation());
        const expCell = el('td');
        expCell.appendChild(expInput);
        tr.appendChild(expCell);

        const actions = el('td');
        actions.addEventListener('click', (e)=> e.stopPropagation());

        const btnRowSave = el('button', {class:'btn', type:'button', onclick:()=>{
          // Update this entry by original word key, optionally rename with duplicate protection
          const parsed2 = safeJsonParse(String(testsArea.value || '').trim() || '[]');
          if(!parsed2.ok) return;
          const arr2 = Array.isArray(parsed2.value) ? parsed2.value : [];
          const idx = arr2.findIndex(x => normalizeWord(x.word || '') === word);
          if(idx < 0) return;

          const newWord = normalizeWord(wordInput.value || '');
          if(!newWord){
            addSummary.innerHTML = '<span class="tag bad">Missing Word</span> <span class="muted">Word cannot be empty.</span>';
            return;
          }

          // Duplicate protection (case-normalized)
          const dup = arr2.some((x,i)=> i !== idx && normalizeWord(x.word || '') === newWord);
          if(dup){
            addSummary.innerHTML = '<span class="tag bad">Duplicate Word</span> <span class="muted">A test for "' + escapeHtml(newWord) + '" already exists. Choose a different word.</span>';
            return;
          }

          const newName = String(nameInput.value || '').trim() || newWord;
          const newExpStr = String(expInput.value || '').trim();
          if(!newExpStr){
            addSummary.innerHTML = '<span class="tag bad">Missing Expected</span> <span class="muted">Expected cannot be empty.</span>';
            return;
          }
          const newExpected = normalizeSegments(newExpStr.split('+'));

          const action = (newWord !== word) ? 'rename' : 'update';
          arr2[idx] = { name: newName, word: newWord, expected: newExpected };
          testsArea.value = JSON.stringify(arr2, null, 2);
          saveToStorage(STORAGE_KEYS.tests, testsArea.value);

          addRegressionHistoryEntry({
            tsIso: new Date().toISOString(),
            action,
            word: newWord,
            fromWord: (newWord !== word) ? word : undefined,
            name: newName,
            expected: newExpected,
            expectedStr: segmentsToString(newExpected),
            actualAtAdd: normalizeSegments((segmentWordCore(newWord, {trace:false}).segments || [])),
            source: 'tests-list'
          });
          if(window.__drawRegressionHistory) window.__drawRegressionHistory();

          addSummary.innerHTML = (action === 'rename')
            ? '<span class="tag good">Renamed</span> <span class="muted">Updated word and saved changes.</span>'
            : '<span class="tag good">Updated</span> <span class="muted">Saved changes.</span>';

          drawTestsList();
        }}, ['Save']);

        const btnRowDelete = el('button', {class:'btn', type:'button', onclick:()=>{
          const cur = normalizeWord(wordInput.value || '') || word;
          if(!confirm('Delete test for: ' + cur + ' ?')) return;
          const parsed2 = safeJsonParse(String(testsArea.value || '').trim() || '[]');
          if(!parsed2.ok) return;
          const arr2 = Array.isArray(parsed2.value) ? parsed2.value : [];
          const next = arr2.filter(x => normalizeWord(x.word || '') !== word);
          testsArea.value = JSON.stringify(next, null, 2);
          saveToStorage(STORAGE_KEYS.tests, testsArea.value);

          addRegressionHistoryEntry({
            tsIso: new Date().toISOString(),
            action: 'delete',
            word: word,
            name: String(nameInput.value || '').trim() || name,
            expected: normalizeSegments(String(expInput.value || '').split('+')),
            expectedStr: String(expInput.value || '').trim(),
            actualAtAdd: normalizeSegments((segmentWordCore(word, {trace:false}).segments || [])),
            source: 'tests-list'
          });
          if(window.__drawRegressionHistory) window.__drawRegressionHistory();
          addSummary.innerHTML = '<span class="tag">Deleted</span> <span class="muted">Removed from suite.</span>';
          drawTestsList();
        }}, ['Delete']);

        actions.appendChild(btnRowSave);
        actions.appendChild(btnRowDelete);
        tr.appendChild(actions);

        tbody.appendChild(tr);
      }

      tbl.appendChild(tbody);
      testsListWrap.appendChild(tbl);
    }

    // Keep list in sync
    let __testsListTimer = null;
    testsArea.addEventListener('input', ()=>{
      if(__testsListTimer) clearTimeout(__testsListTimer);
      __testsListTimer = setTimeout(drawTestsList, 250);
    });

    testsListCard.appendChild(testsListControls);
    testsListCard.appendChild(testsListWrap);

    // Expose for handlers
    window.__drawTestsList = drawTestsList;

    root.appendChild(testsListCard);

    // History UI
    const histCard = el('div', {class:'card'});
    histCard.appendChild(el('h3', {}, ['Regression Add History']));
    histCard.appendChild(el('p', {}, ['Tracks additions and updates you make using the Add Test Word form.']));

    const histControls = el('div', {class:'row', style:'gap:8px; flex-wrap:wrap;'});

    const btnHistClear = el('button', {class:'btn', type:'button', onclick:()=>{
      saveRegressionHistory([]);
      drawRegressionHistory();
    }}, ['Clear History']);

    const btnHistExport = el('button', {class:'btn', type:'button', onclick:()=>{
      const items = loadRegressionHistory();
      downloadText('segmenter_v12_regression_add_history.json', JSON.stringify(items, null, 2), 'application/json');
    }}, ['Export History']);

    const histFile = el('input', {type:'file', accept:'application/json', class:'hidden'});

    const btnHistImport = el('button', {class:'btn', type:'button', onclick:()=> histFile.click() }, ['Import History']);

    histFile.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const txt = await f.text();
      const parsed = safeJsonParse(txt);
      if(!parsed.ok || !Array.isArray(parsed.value)){
        addSummary.innerHTML = '<span class="tag bad">Invalid History JSON</span> <span class="muted">Expected an array.</span>';
        return;
      }
      saveRegressionHistory(parsed.value);
      drawRegressionHistory();
      histFile.value = '';
      addSummary.innerHTML = '<span class="tag good">History Imported</span> <span class="muted">Loaded ' + parsed.value.length + ' entries.</span>';
    });

    histControls.appendChild(btnHistClear);
    histControls.appendChild(btnHistExport);
    histControls.appendChild(btnHistImport);
    histControls.appendChild(histFile);

    const histWrap = el('div', {style:'margin-top:10px;'});

    function drawRegressionHistory(){
      histWrap.innerHTML = '';
      const items = loadRegressionHistory();
      if(!items.length){
        histWrap.appendChild(el('p', {}, ['No history yet. Add or update a test to start tracking.']));
        return;
      }
      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['When']),
        el('th', {}, ['Action']),
        el('th', {}, ['Word']),
        el('th', {}, ['Expected'])
      ]));
      tbl.appendChild(thead);

      const tbody = el('tbody');
      for(const it of items){
        const tr = el('tr');
        tr.addEventListener('click', ()=>{
          addWord.value = it.word || '';
          addName.value = it.name || '';
          addExpected.value = it.expectedStr || segmentsToString(it.expected || []);
          addSummary.innerHTML = '<span class="tag">Loaded</span> <span class="muted">Loaded from history. Click Add Or Update Test to write into Tests JSON.</span>';
        });
        const when = (it.tsIso || '').replace('T',' ').replace('Z','');
        tr.appendChild(el('td', {class:'mono'}, [when]));
        tr.appendChild(el('td', {}, [it.action || '']));
        tr.appendChild(el('td', {class:'mono'}, [it.word || '']));
        tr.appendChild(el('td', {class:'mono'}, [it.expectedStr || segmentsToString(it.expected || [])]));
        tbody.appendChild(tr);
      }
      tbl.appendChild(tbody);
      histWrap.appendChild(tbl);
    }

    // Expose for Add handler
    window.__drawRegressionHistory = drawRegressionHistory;

    histCard.appendChild(histControls);
    histCard.appendChild(histWrap);

    root.appendChild(addCard);
    root.appendChild(bulkCard);
    root.appendChild(histCard);

    // initial draw
    drawRegressionHistory();
    if(window.__drawTestsList) window.__drawTestsList();

    const listCard = el('div', {class:'card'});
    listCard.appendChild(el('h3', {}, ['Results']));

    const split = el('div', {class:'split'});
    const listWrap = el('div');
    const detailsWrap = el('div');
    split.appendChild(listWrap);
    split.appendChild(detailsWrap);
    listCard.appendChild(split);
    root.appendChild(listCard);

    function getTests(){
      const tests = (state.results && state.results.tests) ? state.results.tests : [];
      let out = tests;
      const q = (state.query || '').trim().toLowerCase();
      if(q){
        out = out.filter(t => (t.word||'').toLowerCase().includes(q) || (t.name||'').toLowerCase().includes(q));
      }
      if(state.showOnlyFails){
        out = out.filter(t => !t.pass);
      }
      return out;
    }

    function drawList(){
      listWrap.innerHTML = '';

      const tests = getTests();
      if(!tests.length){
        listWrap.appendChild(el('p', {}, ['No results to show. Run tests first, or import results.']));
        detailsWrap.innerHTML = '';
        return;
      }

      if(!state.selected || !tests.includes(state.selected)){
        state.selected = tests[0];
      }

      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['Pass']),
        el('th', {}, ['Word']),
        el('th', {}, ['Name'])
      ]));
      tbl.appendChild(thead);

      const tbody = el('tbody');
      for(const t of tests){
        const ok = !!t.pass;
        const tr = el('tr', {class: (t === state.selected) ? 'selected' : ''});
        tr.addEventListener('click', ()=>{ state.selected = t; drawList(); drawDetails(); });

        tr.appendChild(el('td', {html:`<span class="tag ${ok ? 'good' : 'bad'}">${ok ? 'pass' : 'fail'}</span>`}));
        tr.appendChild(el('td', {class:'mono'}, [t.word || '']));
        tr.appendChild(el('td', {}, [t.name || '']));
        tbody.appendChild(tr);
      }
      tbl.appendChild(tbody);
      listWrap.appendChild(tbl);

      drawDetails();
    }

    function drawDetails(){
      const t = state.selected;
      if(!t){ detailsWrap.innerHTML = ''; return; }

      const ok = !!t.pass;
      const exp = (t.expected || []).map(s=>String(s));
      const act = (t.actual || []).map(s=>String(s));

      const ruleIds = Array.isArray(t.ruleIds) ? t.ruleIds : [];

      let htmlOut = '';
      htmlOut += `<div class="card">`;
      htmlOut += `<div class="row"><span class="tag ${ok ? 'good' : 'bad'}">${ok ? 'pass' : 'fail'}</span>`;
      htmlOut += `<span class="tag">${escapeHtml(t.word || '')}</span>`;
      htmlOut += `<span class="tag">${escapeHtml(t.name || '')}</span></div>`;

      htmlOut += `<div class="twoCol" style="margin-top:10px;">`;
      htmlOut += `<div><h3>Expected</h3><pre>${escapeHtml(segmentsToString(exp))}</pre></div>`;
      htmlOut += `<div><h3>Actual</h3><pre>${escapeHtml(segmentsToString(act))}</pre></div>`;
      htmlOut += `</div>`;

      if(t.diff){
        htmlOut += `<h3>Diff</h3><pre>${escapeHtml(String(t.diff))}</pre>`;
      }

      htmlOut += `<h3>Internal Split</h3>`;
      htmlOut += `<pre>prefix: ${escapeHtml(t.prefix ?? '')}\nmiddle: ${escapeHtml(t.middle ?? '')}\nsuffix: ${escapeHtml(t.suffix ?? '')}</pre>`;

      htmlOut += `<h3>Rules Used</h3>`;
      htmlOut += `<div id="selectedRulePills"></div>`;
      htmlOut += `</div>`;

      if(state.showTrace){
        const trace = t.trace || [];
        htmlOut += `<div class="card"><h3>Trace</h3>`;
        if(!trace.length){
          htmlOut += `<p>No trace recorded.</p>`;
        } else {
          htmlOut += `<table><thead><tr><th>Step</th><th>Fields</th></tr></thead><tbody>`;
          for(const step of trace){
            const fields = Object.entries(step)
              .filter(([k])=>k !== 'step')
              .map(([k,v])=>`${escapeHtml(k)}: ${escapeHtml(typeof v === 'string' ? v : JSON.stringify(v))}`)
              .join('<br>');
            htmlOut += `<tr><td><code>${escapeHtml(step.step || '')}</code></td><td>${fields}</td></tr>`;
          }
          htmlOut += `</tbody></table>`;
        }
        htmlOut += `</div>`;
      }

      if(state.results){
        const total = (state.results.tests || []).length;
        const passCount = (state.results.tests || []).filter(x=>x.pass).length;
        const failCount = total - passCount;
        htmlOut += `<div class="card"><h3>Run Metadata</h3>`;
        htmlOut += `<div class="row">`;
        htmlOut += `<span class="tag">ranAtIso: ${escapeHtml(state.results.ranAtIso || '')}</span>`;
        htmlOut += `<span class="tag">runtimeMs: ${escapeHtml(state.results.runtimeMs || '')}</span>`;
        htmlOut += `<span class="tag good">pass: ${passCount}</span>`;
        htmlOut += `<span class="tag ${failCount ? 'bad' : 'good'}">fail: ${failCount}</span>`;
        htmlOut += `</div></div>`;
      }

      detailsWrap.innerHTML = htmlOut;

      const holder = detailsWrap.querySelector('#selectedRulePills');
      if(holder){
        holder.appendChild(renderRulePills(ruleIds, {max: 16}));
      }
    }

    function drawListAndDetails(){
      drawList();
    }

    window.__drawRegressionList = drawList;
    window.__drawRegressionDetails = drawDetails;
    window.__drawRegressionAll = drawListAndDetails;

    summary.innerHTML = `<span class="tag">Ready</span> <span class="muted">Load baseline or run tests</span>`;

    if(testsText){
      const auto = runTestsFromTextarea(testsArea, summary);
      if(auto){
        const total = auto.tests.length;
        const pass = auto.tests.filter(t=>t.pass).length;
        const fail = total - pass;
        summary.innerHTML = `${fail ? '<span class="tag bad">Fail</span>' : '<span class="tag good">Pass</span>'} ` +
          `<span class="tag">${pass} passed</span> <span class="tag ${fail ? 'bad' : 'good'}">${fail} failed</span> ` +
          `<span class="tag">${total} total</span> <span class="tag">${auto.runtimeMs} ms</span>`;
      }
    }

    drawListAndDetails();
  }

  function drawList(){
    if(window.__drawRegressionList) window.__drawRegressionList();
  }

  function drawDetails(){
    if(window.__drawRegressionDetails) window.__drawRegressionDetails();
  }

  function drawListAndDetails(){
    if(window.__drawRegressionAll) window.__drawRegressionAll();
  }

  function renderDemo(){
    const root = document.getElementById('pageDemo');
    root.innerHTML = '';

    const card = el('div', {class:'card'});
    card.appendChild(el('h2', {}, ['Demo']));
    card.appendChild(el('p', {}, ['Enter a word and see the current v12 split. Segmented words are saved into Word History with rule pills for what fired.']));

    const input = el('input', {type:'text', placeholder:'e.g. haititaimarangai'});
    const runBtn = el('button', {class:'btn primary', type:'button'}, ['Segment']);

    const traceCheck = el('label', {class:'checkbox'});
    const traceInput = el('input', {type:'checkbox'});
    traceInput.checked = false;
    traceCheck.appendChild(traceInput);
    traceCheck.appendChild(document.createTextNode('Include Trace'));

    const outWrap = el('div', {class:'stack', style:'margin-top:12px;'});

    const historyCard = el('div', {class:'card'});
    historyCard.appendChild(el('h2', {}, ['Word History']));
    historyCard.appendChild(el('p', {}, ['Most recent first. Click a word row to load it back into the demo input.']));

    const historyControls = el('div', {class:'row'});
    const btnClear = el('button', {class:'btn', type:'button', onclick:()=>{ saveHistory([]); drawHistory(); }}, ['Clear History']);
    const btnExport = el('button', {class:'btn', type:'button', onclick:()=>{
      const data = loadHistory();
      downloadText('segmenter_v12_word_history.json', JSON.stringify(data, null, 2), 'application/json');
    }}, ['Export History']);

    const btnImport = el('button', {class:'btn', type:'button'}, ['Import History']);
    const fileInput = el('input', {type:'file', accept:'application/json', class:'hidden'});
    btnImport.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const txt = await f.text();
      const parsed = safeJsonParse(txt);
      if(!parsed.ok || !Array.isArray(parsed.value)) return;
      saveHistory(parsed.value);
      drawHistory();
      fileInput.value = '';
    });

    historyControls.appendChild(btnClear);
    historyControls.appendChild(btnExport);
    historyControls.appendChild(btnImport);
    historyControls.appendChild(fileInput);

    const historyWrap = el('div', {id:'historyWrap'});
    historyCard.appendChild(historyControls);
    historyCard.appendChild(el('div', {class:'divider'}));
    historyCard.appendChild(historyWrap);

    function drawHistory(){
      const items = loadHistory();
      historyWrap.innerHTML = '';

      if(!items.length){
        historyWrap.appendChild(el('p', {}, ['No history yet. Segment a word to add it here.']));
        return;
      }

      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['Time']),
        el('th', {}, ['Word']),
        el('th', {}, ['Segments']),
        el('th', {}, ['Rules'])
      ]));
      tbl.appendChild(thead);

      const tbody = el('tbody');
      for(const item of items){
        const tr = el('tr');
        tr.addEventListener('click', ()=>{
          input.value = item.word;
          runBtn.click();
        });

        const dt = item.ts ? new Date(item.ts) : null;
        tr.appendChild(el('td', {}, [dt ? dt.toLocaleString() : '']));
        tr.appendChild(el('td', {class:'mono'}, [item.word || '']));
        tr.appendChild(el('td', {class:'mono'}, [segmentsToString(item.segments || [])]));

        const rulesCell = el('td');
        rulesCell.appendChild(renderRulePills(item.ruleIds || [], {max: 8}));
        tr.appendChild(rulesCell);

        tbody.appendChild(tr);
      }
      tbl.appendChild(tbody);
      historyWrap.appendChild(tbl);
    }

    runBtn.addEventListener('click', ()=>{
      const word = normalizeWord(input.value);
      if(!word){
        outWrap.innerHTML = `<div class="card"><span class="tag bad">Empty</span> <span class="muted">Enter a word</span></div>`;
        return;
      }

      const res = segmentWordCore(word, { trace: traceInput.checked });

      let htmlOut = '';
      htmlOut += `<div class="card">`;
      htmlOut += `<div class="row"><span class="tag">word: ${escapeHtml(res.word)}</span></div>`;
      htmlOut += `<div class="twoCol" style="margin-top:10px;">`;
      htmlOut += `<div><h3>Prefix</h3><pre>${escapeHtml(res.prefix)}</pre></div>`;
      htmlOut += `<div><h3>Segments</h3><pre>${escapeHtml(segmentsToString(res.segments))}</pre></div>`;
      htmlOut += `</div>`;
      htmlOut += `<div class="twoCol" style="margin-top:10px;">`;
      htmlOut += `<div><h3>Middle Segments</h3><pre>${escapeHtml(segmentsToString(res.middleSegments))}</pre></div>`;
      htmlOut += `<div><h3>Suffix Segments</h3><pre>${escapeHtml(segmentsToString(res.suffixSegments))}</pre></div>`;
      htmlOut += `</div>`;
      htmlOut += `<h3>Internal Split</h3><pre>middle: ${escapeHtml(res.middle)}\nsuffix: ${escapeHtml(res.suffix)}</pre>`;
      htmlOut += `<h3>Rules Used</h3><div id="demoRulePills"></div>`;
      htmlOut += `</div>`;

      if(traceInput.checked){
        const trace = res.trace || [];
        htmlOut += `<div class="card"><h3>Trace</h3>`;
        if(!trace.length){ htmlOut += `<p>No trace recorded.</p>`; }
        else {
          htmlOut += `<table><thead><tr><th>Step</th><th>Fields</th></tr></thead><tbody>`;
          for(const step of trace){
            const fields = Object.entries(step)
              .filter(([k])=>k !== 'step')
              .map(([k,v])=>`${escapeHtml(k)}: ${escapeHtml(typeof v === 'string' ? v : JSON.stringify(v))}`)
              .join('<br>');
            htmlOut += `<tr><td><code>${escapeHtml(step.step || '')}</code></td><td>${fields}</td></tr>`;
          }
          htmlOut += `</tbody></table>`;
        }
        htmlOut += `</div>`;
      }

      outWrap.innerHTML = htmlOut;
      const pillHolder = outWrap.querySelector('#demoRulePills');
      if(pillHolder){
        pillHolder.appendChild(renderRulePills(res.ruleIds || [], {max: 16}));
      }

      addHistoryEntry({
        ts: new Date().toISOString(),
        word: res.word,
        segments: res.segments,
        ruleIds: res.ruleIds,
        prefix: res.prefix,
        middle: res.middle,
        suffix: res.suffix
      });

      drawHistory();
    });

    const inputWrap = el('div', {style:'flex:1; min-width:260px;'});
    inputWrap.appendChild(input);

    const btnWrap = el('div', {style:'display:flex; gap:8px; flex-wrap:wrap;'});
    btnWrap.appendChild(runBtn);
    btnWrap.appendChild(traceCheck);

    const controlRow = el('div', {class:'row'});
    controlRow.appendChild(inputWrap);
    controlRow.appendChild(btnWrap);

    card.appendChild(controlRow);
    root.appendChild(card);
    root.appendChild(outWrap);
    root.appendChild(historyCard);

    drawHistory();
  }



  function loadG2pPrefs(){
    const raw = loadFromStorage(STORAGE_KEYS.g2pPrefs);
    const parsed = raw ? safeJsonParse(raw) : {ok:false};
    if(parsed.ok && parsed.value && typeof parsed.value === 'object') return parsed.value;
    return { joinMode: 'space' };
  }

  function saveG2pPrefs(prefs){
    return saveToStorage(STORAGE_KEYS.g2pPrefs, JSON.stringify(prefs || {}, null, 2));
  }

  function loadG2pHistory(){
    const raw = loadFromStorage(STORAGE_KEYS.g2pHistory);
    if(!raw) return [];
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !Array.isArray(parsed.value)) return [];
    return parsed.value;
  }

  function saveG2pHistory(items){
    return saveToStorage(STORAGE_KEYS.g2pHistory, JSON.stringify(items || [], null, 2));
  }

  function addG2pHistoryEntry(entry){
    const items = loadG2pHistory();
    const sig = `${entry.word}::${segmentsToString(entry.segments)}::${entry.ipa || ''}`;
    const filtered = items.filter(x => `${x.word}::${segmentsToString(x.segments)}::${x.ipa || ''}` !== sig);
    filtered.unshift(entry);
    saveG2pHistory(filtered.slice(0, 200));
  }



  function defaultG2pAwsTtsPrefs(){
    return {
      inputMode: 'text',
      joinMode: 'dot',
      outputMode: 'phoneme',
      mixedWrap: {},
wrapSpeak: true,
      emptyPhonemeBody: true,
      preservePunct: true,
      splitHyphen: true,
      trimNonFinalH: false,
      strictMissing: false,
      showTrace: true,
      serviceRegion: 'australiaeast',
      awsRegion: 'ap-southeast-2',
      voiceId: 'Aria',
      engine: 'neural',
      languageCode: 'en-NZ',
      outputFormat: 'mp3'
    };
  }

  function loadG2pAwsTtsPrefs(){
    const base = defaultG2pAwsTtsPrefs();
    const raw = loadFromStorage(STORAGE_KEYS.g2pAwsTtsPrefs);
    const parsed = raw ? safeJsonParse(raw) : {ok:false};
    if(parsed.ok && parsed.value && typeof parsed.value === 'object') return {...base, ...parsed.value};
    return base;
  }

  function saveG2pAwsTtsPrefs(prefs){
    return saveToStorage(STORAGE_KEYS.g2pAwsTtsPrefs, JSON.stringify(prefs || {}, null, 2));
  }

  function loadG2pAwsTtsCreds(){
    const raw = loadFromStorage(STORAGE_KEYS.g2pAwsTtsCreds);
    if(!raw) return {remember:false};
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !parsed.value || typeof parsed.value !== 'object') return {remember:false};
    return parsed.value;
  }

  function saveG2pAwsTtsCreds(creds){
    return saveToStorage(STORAGE_KEYS.g2pAwsTtsCreds, JSON.stringify(creds || {}, null, 2));
  }

  function loadG2pAwsTtsHistory(){
    const raw = loadFromStorage(STORAGE_KEYS.g2pAwsTtsHistory);
    if(!raw) return [];
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !Array.isArray(parsed.value)) return [];
    return parsed.value;
  }

  function saveG2pAwsTtsHistory(items){
    return saveToStorage(STORAGE_KEYS.g2pAwsTtsHistory, JSON.stringify(items || [], null, 2));
  }

  function addG2pAwsTtsHistoryEntry(entry){
    const items = loadG2pAwsTtsHistory();
    const sig = `${entry.inputMode}::${entry.inputText || ''}::${entry.joinMode || ''}::${entry.ssml || ''}`;
    const filtered = items.filter(x => `${x.inputMode}::${x.inputText || ''}::${x.joinMode || ''}::${x.ssml || ''}` !== sig);
    filtered.unshift(entry);
    saveG2pAwsTtsHistory(filtered.slice(0, 200));
  }

  function renderG2P(){
    const root = document.getElementById('pageG2P');
    root.innerHTML = '';

    const prefs = loadG2pPrefs();

    const card = el('div', {class:'card'});
    card.appendChild(el('h2', {}, ['G2P']));
    card.appendChild(el('p', {}, ['Segment a word using v12 then map each segment to IPA using the embedded lexicon (Unit, Proper IPA, Unit Number).']))

    const input = el('input', {type:'text', placeholder:'e.g. haititaimarangai'});
    const runBtn = el('button', {class:'btn primary', type:'button'}, ['Segment And Map']);

    const traceCheck = el('label', {class:'checkbox'});
    const traceInput = el('input', {type:'checkbox'});
    traceInput.checked = false;
    traceCheck.appendChild(traceInput);
    traceCheck.appendChild(document.createTextNode('Include Trace'));

    const joinSelect = el('select', {class:'btn', title:'IPA join style'});
    joinSelect.style.padding = '8px 10px';
    joinSelect.style.borderRadius = '10px';
    joinSelect.style.background = 'rgba(18,22,27,.85)';
    joinSelect.style.border = '1px solid var(--border)';
    joinSelect.style.color = 'var(--text)';

    const joinOptions = [
      {v:'space', t:'IPA Join: space'},
      {v:'dot', t:'IPA Join: dot'},
      {v:'none', t:'IPA Join: none'}
    ];
    for(const opt of joinOptions){
      const o = el('option', {value: opt.v}, [opt.t]);
      if(opt.v === (prefs.joinMode || 'space')) o.selected = true;
      joinSelect.appendChild(o);
    }

    joinSelect.addEventListener('change', ()=>{
      prefs.joinMode = joinSelect.value;
      saveG2pPrefs(prefs);
      // if a mapping view exists, recompute join only
      const ipaOut = root.querySelector('#ipaOutput');
      const partsRaw = root.querySelector('#ipaPartsJson');
      if(ipaOut && partsRaw){
        const parsed = safeJsonParse(partsRaw.value || '[]');
        if(parsed.ok){
          ipaOut.textContent = joinIpa(parsed.value, prefs.joinMode);
        }
      }
    });

    const outWrap = el('div', {class:'stack', style:'margin-top:12px;'});

    const inputWrap = el('div', {style:'flex:1; min-width:260px;'});
    inputWrap.appendChild(input);

    const btnWrap = el('div', {style:'display:flex; gap:8px; flex-wrap:wrap;'});
    btnWrap.appendChild(runBtn);
    btnWrap.appendChild(joinSelect);
    btnWrap.appendChild(traceCheck);

    const controlRow = el('div', {class:'row'});
    controlRow.appendChild(inputWrap);
    controlRow.appendChild(btnWrap);

    card.appendChild(controlRow);
    root.appendChild(card);
    root.appendChild(outWrap);

    // History card
    const historyCard = el('div', {class:'card'});
    historyCard.appendChild(el('h2', {}, ['G2P History']));
    historyCard.appendChild(el('p', {}, ['Most recent first. Click a row to load it back into G2P input.']))

    const historyControls = el('div', {class:'row'});
    const btnClear = el('button', {class:'btn', type:'button', onclick:()=>{ saveG2pHistory([]); drawHistory(); }}, ['Clear History']);
    const btnExport = el('button', {class:'btn', type:'button', onclick:()=>{
      downloadText('segmenter_v12_g2p_history.json', JSON.stringify(loadG2pHistory(), null, 2), 'application/json');
    }}, ['Export History']);

    const btnImport = el('button', {class:'btn', type:'button'}, ['Import History']);
    const fileInput = el('input', {type:'file', accept:'application/json', class:'hidden'});
    btnImport.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const txt = await f.text();
      const parsed = safeJsonParse(txt);
      if(!parsed.ok || !Array.isArray(parsed.value)) return;
      saveG2pHistory(parsed.value);
      drawHistory();
      fileInput.value = '';
    });

    historyControls.appendChild(btnClear);
    historyControls.appendChild(btnExport);
    historyControls.appendChild(btnImport);
    historyControls.appendChild(fileInput);

    const historyWrap = el('div', {id:'g2pHistoryWrap'});
    historyCard.appendChild(historyControls);
    historyCard.appendChild(el('div', {class:'divider'}));
    historyCard.appendChild(historyWrap);

    // Lexicon search card
    const lexCard = el('div', {class:'card'});
    lexCard.appendChild(el('h2', {}, ['Lexicon Search']));
    lexCard.appendChild(el('p', {}, ['Search the embedded lexicon by Unit. Shows matches with Proper IPA and Unit Number.']))

    const lexSearch = el('input', {type:'search', placeholder:'Search unit (e.g. ngai, wha, ūa...)'});
    const lexInfo = el('div', {class:'row'});
    const lexWrap = el('div');

    lexCard.appendChild(lexSearch);
    lexCard.appendChild(el('div', {style:'margin-top:10px;'}));
    lexCard.appendChild(lexInfo);
    lexCard.appendChild(el('div', {style:'margin-top:10px;'}));
    lexCard.appendChild(lexWrap);

    function drawLexicon(q){
      const s = (q || '').trim().toLowerCase();
      let rows = LEXICON_ROWS;
      if(s){
        rows = rows.filter(r => (r.unit_norm || '').includes(s));
      }
      const total = rows.length;
      const shown = rows.slice(0, 80);
      lexInfo.innerHTML = '';
      lexInfo.appendChild(el('span', {class:'tag'}, [`matches: ${total}`]));
      lexInfo.appendChild(el('span', {class:'tag'}, [`shown: ${shown.length}`]));

      lexWrap.innerHTML = '';
      if(!shown.length){
        lexWrap.appendChild(el('p', {}, ['No matches.']));
        return;
      }

      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['Unit']),
        el('th', {}, ['Proper IPA']),
        el('th', {}, ['Unit Number'])
      ]));
      tbl.appendChild(thead);
      const tbody = el('tbody');
      for(const r of shown){
        const tr = el('tr');
        tr.addEventListener('click', ()=>{
          // load unit into input as a quick way to test
          input.value = r.unit;
        });
        tr.appendChild(el('td', {class:'mono'}, [r.unit]));
        tr.appendChild(el('td', {class:'mono'}, [r.ipa]));
        tr.appendChild(el('td', {class:'mono'}, [String(r.unit_number ?? '')]));
        tbody.appendChild(tr);
      }
      tbl.appendChild(tbody);
      lexWrap.appendChild(tbl);
    }

    lexSearch.addEventListener('input', ()=> drawLexicon(lexSearch.value));

    function drawHistory(){
      const items = loadG2pHistory();
      historyWrap.innerHTML = '';

      if(!items.length){
        historyWrap.appendChild(el('p', {}, ['No history yet. Segment and map a word to add it here.']));
        return;
      }

      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['Time']),
        el('th', {}, ['Word']),
        el('th', {}, ['Segments']),
        el('th', {}, ['IPA']),
        el('th', {}, ['Rules'])
      ]));
      tbl.appendChild(thead);

      const tbody = el('tbody');
      for(const item of items){
        const tr = el('tr');
        tr.addEventListener('click', ()=>{
          input.value = item.word;
          runBtn.click();
        });

        const dt = item.ts ? new Date(item.ts) : null;
        tr.appendChild(el('td', {}, [dt ? dt.toLocaleString() : '']));
        tr.appendChild(el('td', {class:'mono'}, [item.word || '']));
        tr.appendChild(el('td', {class:'mono'}, [segmentsToString(item.segments || [])]));
        tr.appendChild(el('td', {class:'mono'}, [String(item.ipa || '')]));

        const rulesCell = el('td');
        rulesCell.appendChild(renderRulePills(item.ruleIds || [], {max: 8}));
        tr.appendChild(rulesCell);

        tbody.appendChild(tr);
      }
      tbl.appendChild(tbody);
      historyWrap.appendChild(tbl);
    }

    runBtn.addEventListener('click', ()=>{
      const word = normalizeWord(input.value);
      if(!word){
        outWrap.innerHTML = `<div class="card"><span class="tag bad">Empty</span> <span class="muted">Enter a word</span></div>`;
        return;
      }

      const res = segmentWordCore(word, { trace: traceInput.checked });
      const segs = res.segments || [];

      // Build per-segment matches
      const ipaParts = [];
      const rows = [];

      for(const seg of segs){
        const matches = getLexiconMatches(seg);
        const chosen = chooseDefaultMatch(matches);
        const ipa = chosen ? chosen.ipa : '';
        if(ipa) ipaParts.push(ipa);

        rows.push({
          segment: seg,
          matches,
          chosenUnit: chosen ? chosen.unit : '',
          chosenIpa: ipa,
          chosenNumber: chosen ? chosen.unit_number : null,
          status: chosen ? (matches.length > 1 ? 'multi' : 'match') : 'missing'
        });
      }

      const ipa = joinIpa(ipaParts, prefs.joinMode);

      // Render
      let htmlOut = '';
      htmlOut += `<div class="card">`;
      htmlOut += `<div class="row"><span class="tag">word: ${escapeHtml(res.word)}</span><span class="tag">segments: ${segs.length}</span></div>`;
      htmlOut += `<div class="twoCol" style="margin-top:10px;">`;
      htmlOut += `<div><h3>Segments</h3><pre>${escapeHtml(segmentsToString(segs))}</pre></div>`;
      htmlOut += `<div><h3>IPA Output</h3><pre id="ipaOutput">${escapeHtml(ipa)}</pre></div>`;
      htmlOut += `</div>`;

      htmlOut += `<input id="ipaPartsJson" class="hidden" value='${escapeHtml(JSON.stringify(ipaParts))}' />`;

      htmlOut += `<div class="row" style="margin-top:10px;">`;
      htmlOut += `<button class="btn" type="button" id="btnCopyIpa">Copy IPA</button>`;
      htmlOut += `<button class="btn" type="button" id="btnDownloadG2p">Download G2P JSON</button>`;
      htmlOut += `</div>`;

      htmlOut += `<h3>Segment To IPA Mapping</h3>`;
      htmlOut += `<table><thead><tr><th>Segment</th><th>Status</th><th>Unit</th><th>Proper IPA</th><th>Unit Number</th><th>Matches</th></tr></thead><tbody>`;
      for(let i=0;i<rows.length;i++){
        const r = rows[i];
        const statusTag = r.status==='match' ? 'good' : (r.status==='multi' ? 'warn' : 'bad');
        const matchCount = r.matches.length;
        htmlOut += `<tr>`;
        htmlOut += `<td class="mono">${escapeHtml(r.segment)}</td>`;
        htmlOut += `<td><span class="tag ${statusTag}">${escapeHtml(r.status)}</span></td>`;
        htmlOut += `<td class="mono">${escapeHtml(r.chosenUnit || '')}</td>`;
        htmlOut += `<td class="mono">${escapeHtml(r.chosenIpa || '')}</td>`;
        htmlOut += `<td class="mono">${escapeHtml(r.chosenNumber == null ? '' : String(r.chosenNumber))}</td>`;
        if(matchCount <= 1){
          htmlOut += `<td class="mono">${matchCount}</td>`;
        } else {
          // Provide a select for multiple matches
          htmlOut += `<td><select data-idx="${i}" class="g2pSelect" style="width:100%; background:rgba(0,0,0,.22); border:1px solid var(--border); color:var(--text); border-radius:10px; padding:8px 8px;">`;
          for(const m of r.matches){
            const label = `${m.unit_number ?? ''}  ${m.ipa}`.trim();
            htmlOut += `<option value="${escapeHtml(String(m.unit_number ?? ''))}">${escapeHtml(label)}</option>`;
          }
          htmlOut += `</select></td>`;
        }
        htmlOut += `</tr>`;
      }
      htmlOut += `</tbody></table>`;

      htmlOut += `<h3>Rules Used</h3><div id="g2pRulePills"></div>`;
      htmlOut += `</div>`;

      if(traceInput.checked){
        const trace = res.trace || [];
        htmlOut += `<div class="card"><h3>Trace</h3>`;
        if(!trace.length){ htmlOut += `<p>No trace recorded.</p>`; }
        else {
          htmlOut += `<table><thead><tr><th>Step</th><th>Fields</th></tr></thead><tbody>`;
          for(const step of trace){
            const fields = Object.entries(step)
              .filter(([k])=>k !== 'step')
              .map(([k,v])=>`${escapeHtml(k)}: ${escapeHtml(typeof v === 'string' ? v : JSON.stringify(v))}`)
              .join('<br>');
            htmlOut += `<tr><td><code>${escapeHtml(step.step || '')}</code></td><td>${fields}</td></tr>`;
          }
          htmlOut += `</tbody></table>`;
        }
        htmlOut += `</div>`;
      }

      outWrap.innerHTML = htmlOut;

      // Fill pills
      const pillHolder = outWrap.querySelector('#g2pRulePills');
      if(pillHolder){
        pillHolder.appendChild(renderRulePills(res.ruleIds || [], {max: 16}));
      }

      // Copy and download handlers
      const btnCopy = outWrap.querySelector('#btnCopyIpa');
      if(btnCopy){
        btnCopy.addEventListener('click', ()=>{
          const ipaText = outWrap.querySelector('#ipaOutput') ? outWrap.querySelector('#ipaOutput').textContent : ipa;
          if(navigator.clipboard && navigator.clipboard.writeText){
            navigator.clipboard.writeText(ipaText || '');
          }
        });
      }

      const btnDl = outWrap.querySelector('#btnDownloadG2p');
      if(btnDl){
        btnDl.addEventListener('click', ()=>{
          const payload = {
            word: res.word,
            segments: segs,
            ipaSegments: ipaParts,
            ipa,
            joinMode: prefs.joinMode,
            mapping: rows.map(r => ({segment:r.segment, unit:r.chosenUnit, ipa:r.chosenIpa, unit_number:r.chosenNumber, match_count:r.matches.length, status:r.status})),
            ruleIds: res.ruleIds
          };
          downloadText('segmenter_v12_g2p_result.json', JSON.stringify(payload, null, 2), 'application/json');
        });
      }

      // Multi match selects update IPA output
      const selects = outWrap.querySelectorAll('.g2pSelect');
      if(selects && selects.length){
        selects.forEach(sel => {
          sel.addEventListener('change', ()=>{
            const idx = parseInt(sel.getAttribute('data-idx')||'0', 10);
            const unitNumStr = sel.value;
            const r = rows[idx];
            if(!r || !r.matches || !r.matches.length) return;
            const chosen = r.matches.find(m => String(m.unit_number ?? '') === unitNumStr) || r.matches[0];
            r.chosenUnit = chosen.unit;
            r.chosenIpa = chosen.ipa;
            r.chosenNumber = chosen.unit_number;
            // recompute IPA
            const newParts = rows.map(rr => rr.chosenIpa).filter(Boolean);
            const newIpa = joinIpa(newParts, prefs.joinMode);
            const ipaEl = outWrap.querySelector('#ipaOutput');
            if(ipaEl) ipaEl.textContent = newIpa;
            const partsRaw = outWrap.querySelector('#ipaPartsJson');
            if(partsRaw) partsRaw.value = JSON.stringify(newParts);
          });
        });
      }

      addG2pHistoryEntry({
        ts: new Date().toISOString(),
        word: res.word,
        segments: segs,
        ipa,
        ipaSegments: ipaParts,
        joinMode: prefs.joinMode,
        mapping: rows.map(r => ({segment:r.segment, unit:r.chosenUnit, ipa:r.chosenIpa, unit_number:r.chosenNumber, match_count:r.matches.length, status:r.status})),
        ruleIds: res.ruleIds
      });

      drawHistory();
    });

    root.appendChild(historyCard);
    root.appendChild(lexCard);

    drawHistory();
    drawLexicon('');
  }


  function renderG2PAwsTts(){
    const root = document.getElementById('pageG2PAwsTts');
    root.innerHTML = '';

    // Export naming (use first two mapped words)
    let lastExportStem = 'g2p_aws_tts';
    let lastAudioBlob = null;

    function _g2pAwsTtsSafeStemPart(s){
      let x = String(s || '').trim();
      x = x.replace(/\s+/g, '_');
      x = x.replace(/[^0-9A-Za-zĀāĒēĪīŌōŪū_-]+/g, '');
      x = x.replace(/_+/g, '_').replace(/^_+|_+$/g, '');
      return x;
    }

    function _g2pAwsTtsExportStemFromWords(words){
      const parts = [];
      for(const w of (words || [])){
        const p = _g2pAwsTtsSafeStemPart(w);
        if(p) parts.push(p);
        if(parts.length >= 2) break;
      }
      if(!parts.length) return 'g2p_aws_tts';
      return parts.join('_').toLowerCase();
    }

    function _g2pAwsTtsExtractFirstWords(mode, text){
      const t = String(text || '').trim();
      if(!t) return [];
      if(mode === 'list'){
        const words = t.split(/[\n\r\t,;]+/g).map(x=>x.trim()).filter(Boolean);
        return words.slice(0, 2);
      }
      if(mode === 'single'){
        return [t];
      }
      // text block
      const reWord = /[A-Za-zĀāĒēĪīŌōŪū]+(?:-[A-Za-zĀāĒēĪīŌōŪū]+)*/g;
      const matches = t.match(reWord) || [];
      return matches.slice(0, 2);
    }

    function _g2pAwsTtsSetStemFromInput(mode, text){
      const words = _g2pAwsTtsExtractFirstWords(mode, text);
      const base = _g2pAwsTtsExportStemFromWords(words);
      lastExportStem = (base === 'g2p_aws_tts') ? 'g2p_aws_tts' : ('g2p_aws_tts_' + base);
      lastExportStem = lastExportStem.replace(/_+/g, '_');
    }


    function _g2pAwsTtsSetStemFromMapped(mapped){
      const words = [];
      for(const r of (mapped || [])){
        const w = (r && r.word != null) ? String(r.word) : '';
        if(w) words.push(w);
        if(words.length >= 2) break;
      }
      const base = _g2pAwsTtsExportStemFromWords(words);
      lastExportStem = (base === 'g2p_aws_tts') ? 'g2p_aws_tts' : ('g2p_aws_tts_' + base);
      lastExportStem = lastExportStem.replace(/_+/g, '_');
    }

    function _g2pAwsTtsDownloadBlob(filename, blob){
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 1200);
    }


    const prefs = loadG2pAwsTtsPrefs();

    const card = el('div', {class:'card'});
    card.appendChild(el('h2', {}, ['G2P - AWS TTS']));
    card.appendChild(el('p', {}, ['Segment words using v12, map segments to IPA using the embedded lexicon, then output an AWS Polly SSML speak block with one phoneme block per word or per part for multi part input.']));

    const modeSelect = el('select', {class:'btn', title:'Input mode'});
    modeSelect.style.padding = '8px 10px';
    modeSelect.style.borderRadius = '10px';
    modeSelect.style.background = 'rgba(18,22,27,.85)';
    modeSelect.style.border = '1px solid var(--border)';
    modeSelect.style.color = 'var(--text)';

    const modeOpts = [
      {v:'text', t:'Input: Text Block'},
      {v:'list', t:'Input: Word List'},
      {v:'single', t:'Input: Single Word'}
    ];
    for(const opt of modeOpts){
      const o = el('option', {value: opt.v}, [opt.t]);
      if(opt.v === (prefs.inputMode || 'text')) o.selected = true;
      modeSelect.appendChild(o);
    }

    const input = el('textarea', {rows:'5', placeholder:'Enter text, words, or a single word. Example: Kohitātea, Huitānguru'});
    input.value = prefs.lastInputText || '';

    // Expose for IPA keyboard tab and inserters
    APP_SHARED.awsTtsInputEl = input;

    const joinSelect = el('select', {class:'btn', title:'IPA join style'});
    joinSelect.style.padding = '8px 10px';
    joinSelect.style.borderRadius = '10px';
    joinSelect.style.background = 'rgba(18,22,27,.85)';
    joinSelect.style.border = '1px solid var(--border)';
    joinSelect.style.color = 'var(--text)';

    const joinOptions = [
      {v:'dot', t:'IPA Join: dot'},
      {v:'space', t:'IPA Join: space'},
      {v:'none', t:'IPA Join: none'}
    ];
    for(const opt of joinOptions){
      const o = el('option', {value: opt.v}, [opt.t]);
      if(opt.v === (prefs.joinMode || 'dot')) o.selected = true;
      joinSelect.appendChild(o);
    }



    const outputModeSelect = el('select', {class:'btn', title:'SSML output mode'});
    outputModeSelect.style.padding = '8px 10px';
    outputModeSelect.style.borderRadius = '10px';
    outputModeSelect.style.background = 'rgba(18,22,27,.85)';
    outputModeSelect.style.border = '1px solid var(--border)';
    outputModeSelect.style.color = 'var(--text)';

    const outModeOptions = [
      {v:'phoneme', t:'Output: Phoneme (Wrap All)'},
      {v:'plain', t:'Output: Plain Speak (No Phoneme)'},
      {v:'mixedAuto', t:'Output: Mixed (Auto Detect Te Reo)'},
      {v:'mixed', t:'Output: Mixed (Select Words)'}
    ];
    for(const opt of outModeOptions){
      const o = el('option', {value: opt.v}, [opt.t]);
      if(opt.v === (prefs.outputMode || 'phoneme')) o.selected = true;
      outputModeSelect.appendChild(o);
    }

    let mixedWrap = Object.assign({}, (prefs.mixedWrap || {}));

    // Auto-detect manual overrides (per-token occurrence, including duplicates)
    const AUTO_DETECT_STATE = {
      lastHash: null,
      overrides: {},   // key -> boolean
      selectedKey: null
    };

    function autoDetectHash(){
      return JSON.stringify({
        inputMode: (modeSelect && modeSelect.value) || '',
        raw: String((input && input.value) || ''),
        splitHyphen: !!(hyphenInput && hyphenInput.checked),
        preservePunct: !!(punctInput && punctInput.checked)
      });
    }

    function autoGetOverride(key){
      if(!key) return null;
      return Object.prototype.hasOwnProperty.call(AUTO_DETECT_STATE.overrides, key)
        ? !!AUTO_DETECT_STATE.overrides[key]
        : null;
    }

    function autoSetOverride(key, val){
      if(!key) return;
      AUTO_DETECT_STATE.overrides[key] = !!val;
    }

    function autoOverrideCount(){
      try { return Object.keys(AUTO_DETECT_STATE.overrides || {}).length; } catch(e){ return 0; }
    }



    const speakCheck = el('label', {class:'checkbox'});
    const speakInput = el('input', {type:'checkbox'});
    speakInput.checked = !!prefs.wrapSpeak;
    speakCheck.appendChild(speakInput);
    speakCheck.appendChild(document.createTextNode('Wrap In <speak>'));

    const emptyBodyCheck = el('label', {class:'checkbox'});
    const emptyBodyInput = el('input', {type:'checkbox'});
    emptyBodyInput.checked = !!prefs.emptyPhonemeBody;
    emptyBodyCheck.appendChild(emptyBodyInput);
    emptyBodyCheck.appendChild(document.createTextNode('Empty Phoneme Body'));

    const punctCheck = el('label', {class:'checkbox'});
    const punctInput = el('input', {type:'checkbox'});
    punctInput.checked = !!prefs.preservePunct;
    punctCheck.appendChild(punctInput);
    punctCheck.appendChild(document.createTextNode('Preserve Punctuation'));

    const hyphenCheck = el('label', {class:'checkbox'});
    const hyphenInput = el('input', {type:'checkbox'});
    hyphenInput.checked = !!prefs.splitHyphen;
    hyphenCheck.appendChild(hyphenInput);
    hyphenCheck.appendChild(document.createTextNode('Split Hyphen Parts'));

    const trimNonFinalHCheck = el('label', {class:'checkbox'});
    const trimNonFinalHInput = el('input', {type:'checkbox'});
    trimNonFinalHInput.checked = !!prefs.trimNonFinalH;
    trimNonFinalHCheck.appendChild(trimNonFinalHInput);
    trimNonFinalHCheck.appendChild(document.createTextNode('Trim Non Final IPA h'));

    const strictCheck = el('label', {class:'checkbox'});
    const strictInput = el('input', {type:'checkbox'});
    strictInput.checked = !!prefs.strictMissing;
    strictCheck.appendChild(strictInput);
    strictCheck.appendChild(document.createTextNode('Strict Missing'));

    const traceCheck = el('label', {class:'checkbox'});
    const traceInput = el('input', {type:'checkbox'});
    traceInput.checked = !!prefs.showTrace;
    traceCheck.appendChild(traceInput);
    traceCheck.appendChild(document.createTextNode('Show Trace'));

    const btnGenerate = el('button', {class:'btn primary', type:'button'}, ['Generate SSML']);

    const controls = el('div', {class:'row'});
    controls.appendChild(modeSelect);
    controls.appendChild(joinSelect);
    controls.appendChild(outputModeSelect);
    controls.appendChild(speakCheck);
    controls.appendChild(emptyBodyCheck);
    controls.appendChild(punctCheck);
    controls.appendChild(hyphenCheck);
    controls.appendChild(trimNonFinalHCheck);
    controls.appendChild(strictCheck);
    controls.appendChild(traceCheck);
    controls.appendChild(btnGenerate);

    card.appendChild(input);


    // Inserters: AWS SSML tags and IPA symbols
    const inserter = el('div', {style:'margin-top:12px; padding:12px; border:1px solid var(--border); border-radius:12px;'});
    inserter.appendChild(el('h3', {}, ['Insert SSML Tags And IPA Symbols']));
    inserter.appendChild(el('p', {style:'margin-top:6px;'}, ['Choose a target then insert AWS Polly compatible SSML tags or IPA symbols at the cursor.']));

    const targetRow = el('div', {class:'row'});
    const targetSelect = el('select', {class:'btn', title:'Insert target'});
    targetSelect.style.padding = '8px 10px';
    targetSelect.style.borderRadius = '10px';
    targetSelect.style.background = 'rgba(18,22,27,.85)';
    targetSelect.style.border = '1px solid var(--border)';
    targetSelect.style.color = 'var(--text)';

    const targetOpts = [
      {v:'active', t:'Target: Active Field'},
      {v:'awsInput', t:'Target: AWS TTS Input'},
      {v:'awsSsml', t:'Target: SSML Output'}
    ];
    for(const opt of targetOpts){
      targetSelect.appendChild(el('option', {value: opt.v}, [opt.t]));
    }
    targetRow.appendChild(targetSelect);

    const activeNote = el('div', {class:'tag', style:'align-self:center; opacity:.9;'}, ['Active Field: none']);
    targetRow.appendChild(activeNote);

    inserter.appendChild(targetRow);

    function getInsertTarget(){
      const v = targetSelect.value;
      if(v === 'awsInput') return APP_SHARED.awsTtsInputEl || null;
      if(v === 'awsSsml') return APP_SHARED.awsTtsSsmlEl || null;
      return APP_SHARED.lastFocused || null;
    }

    function refreshActiveNote(){
      const elx = APP_SHARED.lastFocused;
      if(!elx) { activeNote.textContent = 'Active Field: none'; return; }
      const tag = (elx.tagName || '').toLowerCase();
      const id = elx.id ? `#${elx.id}` : '';
      activeNote.textContent = `Active Field: ${tag}${id}`;
    }
    refreshActiveNote();
    APP_SHARED.onFocus = refreshActiveNote;

    const ssmlRow = el('div', {class:'row', style:'margin-top:10px;'});
    const ssmlSelect = el('select', {class:'btn', title:'SSML tag'});
    ssmlSelect.style.padding = '8px 10px';
    ssmlSelect.style.borderRadius = '10px';
    ssmlSelect.style.background = 'rgba(18,22,27,.85)';
    ssmlSelect.style.border = '1px solid var(--border)';
    ssmlSelect.style.color = 'var(--text)';

    const ssmlTemplates = [
      {t:'<break time="500ms"/>', kind:'insert', label:'Break 500ms'},
      {t:'<break strength="medium"/>', kind:'insert', label:'Break Medium'},
      {before:'<prosody rate="slow">', after:'</prosody>', kind:'wrap', label:'Prosody Rate Slow'},
      {before:'<prosody pitch="+10%">', after:'</prosody>', kind:'wrap', label:'Prosody Pitch +10%'},
      {before:'<emphasis level="strong">', after:'</emphasis>', kind:'wrap', label:'Emphasis Strong'},
      {before:'<amazon:effect name="drc">', after:'</amazon:effect>', kind:'wrap', label:'Amazon Effect DRC'},
      {before:'<say-as interpret-as="characters">', after:'</say-as>', kind:'wrap', label:'Say As Characters'},
      {before:'<lang xml:lang="en-NZ">', after:'</lang>', kind:'wrap', label:'Lang en-NZ'},
      {before:'<phoneme alphabet="ipa" ph="">', after:'</phoneme>', kind:'wrap', label:'Phoneme IPA Tag'}
    ];
    for(const tpl of ssmlTemplates){
      ssmlSelect.appendChild(el('option', {value: tpl.label}, [tpl.label]));
    }
    const btnInsertSsml = el('button', {class:'btn', type:'button'}, ['Insert SSML']);
    btnInsertSsml.onclick = ()=>{
      const target = getInsertTarget();
      const label = ssmlSelect.value;
      const tpl = ssmlTemplates.find(x=>x.label === label);
      if(!tpl) return;
      if(tpl.kind === 'wrap') wrapSelectionText(target, tpl.before, tpl.after);
      else insertAtCursorText(target, tpl.t);
    };
    ssmlRow.appendChild(ssmlSelect);
    ssmlRow.appendChild(btnInsertSsml);
    inserter.appendChild(ssmlRow);

    const symWrap = el('div', {style:'margin-top:10px;'});
    symWrap.appendChild(el('label', {}, ['IPA Symbol Keyboard']));
    const symFilter = el('input', {type:'text', placeholder:'Filter symbols like stress, long, ə, ŋ'});
    symFilter.style.marginTop = '6px';
    symFilter.style.width = '100%';
    symFilter.style.padding = '10px';
    symFilter.style.borderRadius = '12px';
    symFilter.style.border = '1px solid var(--border)';
    symFilter.style.background = 'rgba(18,22,27,.6)';
    symFilter.style.color = 'var(--text)';

    const symSelect = el('select', {size:'8', style:'width:100%; margin-top:8px; max-height:220px; overflow:auto;'});
    symSelect.innerHTML = IPA_SYMBOL_OPTIONS_HTML;

    const btnInsertSym = el('button', {class:'btn', type:'button', style:'margin-top:8px;'}, ['Insert Symbol']);
    btnInsertSym.onclick = ()=>{
      const opt = symSelect.options[symSelect.selectedIndex];
      if(!opt) return;
      const symbol = opt.value || opt.textContent.split(' - ')[0];
      insertAtCursorText(getInsertTarget(), symbol);
    };

    symFilter.addEventListener('input', ()=>{
      const q = (symFilter.value || '').trim().toLowerCase();
      for(const opt of Array.from(symSelect.options)){
        const txt = (opt.textContent || '').toLowerCase();
        opt.hidden = q ? !txt.includes(q) : false;
      }
    });

    symWrap.appendChild(symFilter);
    symWrap.appendChild(symSelect);
    symWrap.appendChild(btnInsertSym);
    inserter.appendChild(symWrap);

    card.appendChild(inserter);

    card.appendChild(el('div', {style:'margin-top:10px;'}));
    card.appendChild(controls);
    root.appendChild(card);



    const mixedPanel = el('div', {style:'margin-top:12px; padding:10px; border:1px solid var(--border); border-radius:12px; display:none;'});
    mixedPanel.appendChild(el('h3', {}, ['Mixed Wrap Selection']));
    mixedPanel.appendChild(el('p', {style:'margin-top:6px;'}, ['Choose which words (or hyphen parts) should be wrapped in <phoneme> tags. Unchecked words are left as plain text inside <speak>.']));

    const mixedBtns = el('div', {class:'row'});
    const btnMixedAll = el('button', {class:'btn', type:'button'}, ['Wrap All']);
    const btnMixedNone = el('button', {class:'btn', type:'button'}, ['Wrap None']);
    const btnMixedInvert = el('button', {class:'btn', type:'button'}, ['Invert']);
    const btnMixedRefresh = el('button', {class:'btn', type:'button'}, ['Refresh List']);
    const mixedFilter = el('input', {type:'text', placeholder:'Filter words...', style:'min-width:220px;'});
    mixedBtns.appendChild(btnMixedAll);
    mixedBtns.appendChild(btnMixedNone);
    mixedBtns.appendChild(btnMixedInvert);
    mixedBtns.appendChild(btnMixedRefresh);
    mixedBtns.appendChild(mixedFilter);

    const mixedList = el('div', {style:'margin-top:10px; max-height:240px; overflow:auto; padding:8px; border:1px solid var(--border); border-radius:10px;'});
    mixedPanel.appendChild(mixedBtns);
    mixedPanel.appendChild(mixedList);

    card.appendChild(mixedPanel);

    // Auto detect Te Reo panel for Mixed Auto mode
    const autoPanel = el('div', {style:'margin-top:12px; padding:12px; border:1px solid var(--border); border-radius:12px; display:none;'});
    autoPanel.appendChild(el('h3', {}, ['Auto Detect Te Reo']));
    autoPanel.appendChild(el('p', {style:'margin-top:6px;'}, ['When Output Mode is set to Mixed (Auto Detect Te Reo), likely te reo Māori tokens are wrapped in <phoneme> tags and other tokens remain plain text inside <speak>.']));

    const autoTopRow = el('div', {class:'row'});
    const autoThrLabel = el('span', {class:'tag'}, ['Token threshold: 75%']);
    const autoThr = el('input', {type:'range', min:'0.50', max:'0.90', step:'0.01', value:String((loadG2pAwsTtsPrefs().autoDetectThreshold != null ? loadG2pAwsTtsPrefs().autoDetectThreshold : 0.75)), style:'width:220px;'});
    autoThr.addEventListener('input', ()=>{ autoThrLabel.textContent = 'Token threshold: ' + Math.round(parseFloat(autoThr.value)*100) + '%'; scheduleAutoDetect(); });
    autoThrLabel.textContent = 'Token threshold: ' + Math.round(parseFloat(autoThr.value)*100) + '%';

    const autoDebugCheck = el('label', {class:'checkbox'});
    const autoDebugInput = el('input', {type:'checkbox'});
    autoDebugInput.checked = !!(loadG2pAwsTtsPrefs().autoDetectShowDebug);
    autoDebugInput.addEventListener('change', ()=>{ saveG2pAwsTtsPrefs({...loadG2pAwsTtsPrefs(), autoDetectShowDebug: !!autoDebugInput.checked}); scheduleAutoDetect(); });
    autoDebugCheck.appendChild(autoDebugInput);
    autoDebugCheck.appendChild(document.createTextNode('Show Debug'));

    autoTopRow.appendChild(autoThrLabel);
    autoTopRow.appendChild(autoThr);
    autoTopRow.appendChild(autoDebugCheck);

    const autoOverrideTag = el('span', {class:'tag', id:'autoOverrideTag'}, ['Overrides: 0']);
    const btnAutoResetOverrides = el('button', {class:'btn', type:'button', title:'Clear manual include and exclude toggles for auto-detected tokens.'}, ['Reset Overrides']);
    btnAutoResetOverrides.addEventListener('click', ()=>{
      AUTO_DETECT_STATE.overrides = {};
      AUTO_DETECT_STATE.selectedKey = null;
      scheduleAutoDetect();
    });

    autoTopRow.appendChild(autoOverrideTag);
    autoTopRow.appendChild(btnAutoResetOverrides);


    const autoSummary = el('div', {style:'margin-top:10px;'});
    const autoSummaryLine = el('div', {class:'muted'}, ['Included tokens show a subtle dot. Click a token to inspect details. Shift-click a token to toggle processing for that token. Manual overrides show ↻.']);
    autoSummary.appendChild(autoSummaryLine);

    const autoHlTitle = el('div', {class:'muted', style:'margin-top:10px;'}, ['Highlighted Text']);
    const autoHl = el('div', {class:'hlText', style:'margin-top:6px;'});
    const autoBlocksTitle = el('div', {class:'muted', style:'margin-top:12px;'}, ['Detected Blocks']);
    const autoBlocks = el('div', {style:'margin-top:6px; display:flex; flex-wrap:wrap; gap:8px;'});
    const autoWordTitle = el('div', {class:'muted', style:'margin-top:12px;'}, ['Word Details']);
    const autoWordWrap = el('div', {style:'margin-top:6px; overflow:auto;'});
    const autoTbl = el('table', {class:'tbl'});
    autoWordWrap.appendChild(autoTbl);
    const autoSelTitle = el('div', {class:'muted', style:'margin-top:12px;'}, ['Selected Word']);
    const autoSel = el('div', {style:'margin-top:6px;'});

    autoPanel.appendChild(autoTopRow);
    autoPanel.appendChild(autoSummary);
    autoPanel.appendChild(autoHlTitle);
    autoPanel.appendChild(autoHl);
    autoPanel.appendChild(autoBlocksTitle);
    autoPanel.appendChild(autoBlocks);
    autoPanel.appendChild(autoWordTitle);
    autoPanel.appendChild(autoWordWrap);
    autoPanel.appendChild(autoSelTitle);
    autoPanel.appendChild(autoSel);

    card.appendChild(autoPanel);

    const outCard = el('div', {class:'card'});
    outCard.appendChild(el('h2', {}, ['SSML Output']));

    const ssmlOut = el('textarea', {rows:'6', id:'awsSsmlOutput', class:'mono'});
    APP_SHARED.awsTtsSsmlEl = ssmlOut;

    const outBtns = el('div', {class:'row'});
    const btnCopy = el('button', {class:'btn', type:'button'}, ['Copy SSML']);
    const btnDownload = el('button', {class:'btn', type:'button'}, ['Download SSML']);
    outBtns.appendChild(btnCopy);
    outBtns.appendChild(btnDownload);

    outCard.appendChild(ssmlOut);
    outCard.appendChild(el('div', {style:'margin-top:10px;'}));
    outCard.appendChild(outBtns);

    const mapWrap = el('div', {style:'margin-top:12px;'});
    outCard.appendChild(mapWrap);

    const traceWrap = el('div', {style:'margin-top:12px;'});
    outCard.appendChild(traceWrap);

    root.appendChild(outCard);

    const playCard = el('div', {class:'card'});
    playCard.appendChild(el('h2', {}, ['AWS Polly Playback']));
    playCard.appendChild(el('p', {}, ['This runs in your browser using the AWS SDK. If the SDK fails to load or the browser blocks the call, you can still copy SSML and run it with boto3.']));

    const cfg = loadG2pAwsTtsPrefs();
    const creds = loadG2pAwsTtsCreds();

    const serviceRegion = el('input', {type:'text', value: cfg.serviceRegion || 'australiaeast', placeholder:'service_region (reference)'});
    const awsRegion = el('input', {type:'text', value: cfg.awsRegion || 'ap-southeast-2', placeholder:"aws_region (e.g. ap-southeast-2)"});
    const voiceId = el('input', {type:'text', value: cfg.voiceId || 'Aria', placeholder:'VoiceId'});

    const engine = el('select', {class:'btn'});
    engine.style.padding = '8px 10px';
    engine.style.borderRadius = '10px';
    engine.style.background = 'rgba(18,22,27,.85)';
    engine.style.border = '1px solid var(--border)';
    engine.style.color = 'var(--text)';
    for(const v of ['neural','standard']){
      const o = el('option', {value:v}, [v]);
      if(v === (cfg.engine || 'neural')) o.selected = true;
      engine.appendChild(o);
    }

    const languageCode = el('input', {type:'text', value: cfg.languageCode || 'en-NZ', placeholder:'LanguageCode (optional)'});

    const outputFormat = el('select', {class:'btn'});
    outputFormat.style.padding = '8px 10px';
    outputFormat.style.borderRadius = '10px';
    outputFormat.style.background = 'rgba(18,22,27,.85)';
    outputFormat.style.border = '1px solid var(--border)';
    outputFormat.style.color = 'var(--text)';
    for(const v of ['mp3','ogg_vorbis','pcm']){
      const o = el('option', {value:v}, [v]);
      if(v === (cfg.outputFormat || 'mp3')) o.selected = true;
      outputFormat.appendChild(o);
    }

    const accessKeyId = el('input', {type:'password', value: creds.accessKeyId || '', placeholder:'AWS Access Key Id'});
    const secretAccessKey = el('input', {type:'password', value: creds.secretAccessKey || '', placeholder:'AWS Secret Access Key'});
    const sessionToken = el('input', {type:'password', value: creds.sessionToken || '', placeholder:'AWS Session Token (optional)'});

    const rememberCheck = el('label', {class:'checkbox'});
    const rememberInput = el('input', {type:'checkbox'});
    rememberInput.checked = !!creds.remember;
    rememberCheck.appendChild(rememberInput);
    rememberCheck.appendChild(document.createTextNode('Remember Credentials (Local Storage)'));

    const btnSaveCfg = el('button', {class:'btn', type:'button'}, ['Save Config']);
    const btnPlay = el('button', {class:'btn primary', type:'button'}, ['Play SSML']);
    const btnDownloadMp3 = el('button', {class:'btn', type:'button'}, ['Download MP3']);

    const audio = el('audio', {controls:'', style:'width:100%; margin-top:10px;'});
    const playTrace = el('pre', {class:'mono', style:'margin-top:10px; white-space:pre-wrap;'});

    const grid = el('div', {class:'twoCol'});
    grid.appendChild(el('div', {}, [el('h3', {}, ['Regions']), el('div', {class:'stack'}, [
      el('label', {}, ['service_region']), serviceRegion,
      el('label', {}, ['aws_region']), awsRegion
    ])]));

    grid.appendChild(el('div', {}, [el('h3', {}, ['Voice']), el('div', {class:'stack'}, [
      el('label', {}, ['VoiceId']), voiceId,
      el('label', {}, ['Engine']), engine,
      el('label', {}, ['LanguageCode']), languageCode,
      el('label', {}, ['OutputFormat']), outputFormat
    ])]));

    playCard.appendChild(grid);

    playCard.appendChild(el('h3', {}, ['Credentials']));
    playCard.appendChild(el('div', {class:'stack'}, [
      accessKeyId,
      secretAccessKey,
      sessionToken,
      rememberCheck
    ]));

    const playBtns = el('div', {class:'row', style:'margin-top:10px;'});
    playBtns.appendChild(btnSaveCfg);
    playBtns.appendChild(btnPlay);
    playBtns.appendChild(btnDownloadMp3);
    playCard.appendChild(playBtns);
    playCard.appendChild(audio);
    playCard.appendChild(playTrace);

    root.appendChild(playCard);

    const histCard = el('div', {class:'card'});
    histCard.appendChild(el('h2', {}, ['AWS TTS History']));
    histCard.appendChild(el('p', {}, ['Most recent first. Click a row to restore input and SSML output.']));

    const histControls = el('div', {class:'row'});
    const btnClearHist = el('button', {class:'btn', type:'button'}, ['Clear History']);
    const btnExportHist = el('button', {class:'btn', type:'button'}, ['Export History']);
    const btnImportHist = el('button', {class:'btn', type:'button'}, ['Import History']);
    const histFile = el('input', {type:'file', accept:'application/json', class:'hidden'});

    btnImportHist.addEventListener('click', ()=> histFile.click());

    histControls.appendChild(btnClearHist);
    histControls.appendChild(btnExportHist);
    histControls.appendChild(btnImportHist);
    histCard.appendChild(histControls);
    histCard.appendChild(histFile);

    const histTable = el('table', {class:'table'});
    const histHead = el('thead');
    histHead.appendChild(el('tr', {}, [
      el('th', {}, ['When']),
      el('th', {}, ['Mode']),
      el('th', {}, ['Input']),
      el('th', {}, ['Voice']),
      el('th', {}, ['Region'])
    ]));
    histTable.appendChild(histHead);
    const histBody = el('tbody');
    histTable.appendChild(histBody);
    histCard.appendChild(histTable);

    root.appendChild(histCard);

    function escapeAttr(s){
      return String(s ?? '').replaceAll('&','&amp;').replaceAll('"','&quot;').replaceAll("'",'&#39;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    }

    function buildPhonemeTag(ipa, bodyText, emptyBody){
      const ph = escapeAttr(ipa || '');
      const body = emptyBody ? '' : escapeHtml(bodyText || '');
      return `<phoneme alphabet="ipa" ph="${ph}">${body}</phoneme>`;
    }

    function trimNonFinalHTail(ipa){
      const s = String(ipa ?? '');
      if(s.length <= 1) return s;
      // Remove a trailing literal 'h' when this IPA part is not the final segment of the word.
      // Preserve any trailing boundary dots (common when the next IPA part begins with a dot).
      return s.replace(/h(\.+)?$/, (m, dots)=> (dots ?? ''));
    }

    function mapWordToIpa(word){
      const original = String(word || '');
      const wNorm = normalizeWord(original);
      if(!wNorm) return {ok:false, word:original, reason:'empty'};

      const res = segmentWordCore(wNorm, {ctx:'g2pAwsTts'});
      const segs = normalizeSegments(res.segments);
      if(!segs.length) return {ok:false, word:original, reason:'no-segments', segments:[], ruleIds:res.ruleIds || []};

      const rows = [];
      const ipaParts = [];
      let missing = false;

      for(let si=0; si<segs.length; si++){
        const seg = segs[si];
        const matches = getLexiconMatches(seg);
        const chosen = chooseDefaultMatch(matches);
        if(!chosen){
          missing = true;
          rows.push({segment:seg, status:'missing', matches:[]});
          ipaParts.push('');
          continue;
        }
        let ipaPart = chosen.ipa || '';
        if(trimNonFinalHInput.checked && si < (segs.length - 1)) ipaPart = trimNonFinalHTail(ipaPart);
        rows.push({
          segment: seg,
          status: 'ok',
          chosenUnit: chosen.unit,
          chosenIpa: ipaPart,
          chosenNumber: chosen.unit_number,
          matchCount: matches.length
        });
        ipaParts.push(ipaPart);
      }

      const ipa = joinIpa(ipaParts, joinSelect.value || 'dot');
      const phoneme = buildPhonemeTag(ipa, original, emptyBodyInput.checked);

      return {
        ok: !(missing && strictInput.checked),
        word: original,
        wordNorm: wNorm,
        segments: segs,
        ipaParts,
        ipa,
        phoneme,
        rows,
        ruleIds: res.ruleIds || []
      };
    }

    function tokenizeTextPreserve(text, splitHyphen){
      const t = String(text || '');
      const wordRe = splitHyphen ? /[A-Za-zĀāĒēĪīŌōŪū]+/g : /[A-Za-zĀāĒēĪīŌōŪū\-]+/g;
      const tokens = [];
      let last = 0;
      for(const m of t.matchAll(wordRe)){
        const i = m.index || 0;
        if(i > last) tokens.push({type:'sep', text: t.slice(last, i)});
        tokens.push({type:'word', text: m[0]});
        last = i + m[0].length;
      }
      if(last < t.length) tokens.push({type:'sep', text: t.slice(last)});
      return tokens;
    }

    function splitWordParts(word){
      const w = String(word || '').trim();
      if(!w) return [];
      if(!hyphenInput.checked) return [w];
      return w.split('-').filter(Boolean);
    }

    
    function showAutoPanel(show){
      autoPanel.style.display = show ? '' : 'none';
    }

    let _autoDetectTimer = null;
    function scheduleAutoDetect(){
      if(_autoDetectTimer) clearTimeout(_autoDetectTimer);
      _autoDetectTimer = setTimeout(()=>{ if(outputModeSelect.value === 'mixedAuto'){ runAutoDetectAnalysis(true); } }, 120);
    }

    
    function getAutoDisplayText(){
      const mode = modeSelect.value;
      if(mode === 'text') return String(input.value || '');
      if(mode === 'list'){
        const raw = String(input.value || '');
        const items = raw.split(/[\n\r\t,;]+/g).map(s=>s.trim()).filter(Boolean);
        return items.join(', ');
      }
      return String(input.value || '');
    }

    function normKey(s){
      return String(s || '').trim().toLowerCase();
    }

    function computeAutoDetect(){
      const ambiguous = loadTokenList(STORAGE_KEYS.detectAmbiguous, defaultAmbiguousTokens);
      const particles = loadTokenList(STORAGE_KEYS.detectParticles, defaultParticleTokens);
      const lists = {
        ambiguousArr: ambiguous,
        particlesArr: particles,
        ambiguous: new Set(ambiguous),
        particles: new Set(particles)
      };

      const splitHyphen = !!hyphenInput.checked;
      const displayText = getAutoDisplayText();
      const parts = tokenizeTextPreserve(displayText, splitHyphen);
      const wordParts = parts.filter(p=>p.type === 'word').map(p=>p.text);

      const baseTokens = [];
      let seq = 0;
      for(const rawWord of wordParts){
        seq += 1;
        const baseKey = normKey(rawWord) || 'word';
        const key = baseKey + '#' + seq;

        const norm = normalizeWord(rawWord);
        const base = scoreTokenBase(norm, lists);
        baseTokens.push({
          raw: rawWord,
          norm,
          base: base.base,
          hardBlock: !!base.hardBlock,
          debug: base.debug || [],
          segments: base.segments || [],
          signals: base.ruleIds || [],
          ruleIds: base.ruleIds || [],
          coverage: base.coverage,
          orphans: base.orphans,
          key,
          baseKey
        });
      }

      const scored0 = applyContextBoost(baseTokens, lists);
      const isMultiPartMaori = baseTokens.length > 1 && scored0.every(t => !t.hardBlock);
      const scored = (!isMultiPartMaori) ? applyZeroNeighborPropagation(scored0, lists) : scored0;

      const thr = clamp01(parseFloat(autoThr.value) || 0.75);

      const wrapMap = {};
      for(const t of scored){
        const baseInclude = (!t.hardBlock) && (t.score >= thr);
        const ov = autoGetOverride(t.key);
        const include = (ov === null) ? baseInclude : !!ov;

        // annotate token for UI
        t.baseInclude = baseInclude;
        t.override = ov;
        t.include = include;

        wrapMap[t.key] = include;
      }

      return { scored, wrapMap, lists, thr, isMultiPartMaori, displayText, parts };
    }

    function renderAutoDetectUI(res){

      const scored = res.scored || [];
      const wrapMap = res.wrapMap || {};
      const thr = res.thr;

      const prefs = loadG2pAwsTtsPrefs();
      const showDebug = !!prefs.autoDetectShowDebug;
      const autoOvrEl = document.getElementById('autoOverrideTag');
      if(autoOvrEl) autoOvrEl.textContent = 'Overrides: ' + autoOverrideCount();

      // Highlighted Text display based on current input mode, preserving punctuation when enabled
      autoHl.innerHTML = '';
      autoBlocks.innerHTML = '';
      autoSel.innerHTML = '';
      autoTbl.innerHTML = '';

      const displayText = (res && res.displayText != null) ? res.displayText : getAutoDisplayText();
      const parts = (res && res.parts) ? res.parts : tokenizeTextPreserve(displayText, !!hyphenInput.checked);

      let wi = 0;
      const tokSpans = [];
      for(const part of parts){
        if(part.type !== 'word'){
          autoHl.appendChild(document.createTextNode(part.text));
          continue;
        }
        const t = scored[wi];
        const word = part.text;
        const s = t || {score:0, hardBlock:false, signals:[], norm: normalizeWord(word), key: (t && t.key) || ''};
        const lab = scoreToLabel(s.score || 0);
        const include = !!wrapMap[s.key];
        const ov = (t && t.override !== undefined) ? t.override : autoGetOverride(s.key);
        const hasOv = (ov !== null && ov !== undefined);
        const cls = 'hlTok ' + lab.cls + (include ? ' inc' : '') + (hasOv ? ' ovr' : '');
        const span = el('span', {class: cls, tabindex:'0', 'data-idx': String(wi), 'data-key': String(s.key || '')}, [word]);

        span.addEventListener('click', (e)=>{
          if(e && e.shiftKey){
            const key = String(s.key || '');
            if(key){
              autoSetOverride(key, !include);
              AUTO_DETECT_STATE.selectedKey = key;
              runAutoDetectAnalysis(true);
            }
            return;
          }
          selectAutoToken(wi);
        });
        tokSpans.push(span);
        autoHl.appendChild(span);
        wi += 1;
      }

      function makeBlocks(){
        const blocks = [];
        let cur = null;
        for(let i=0;i<scored.length;i++){
          const t = scored[i];
          const inc = !!wrapMap[t.key];
          if(inc){
            if(!cur) cur = {start:i, end:i, words:[t.raw]};
            else { cur.end = i; cur.words.push(t.raw); }
          } else {
            if(cur){ blocks.push(cur); cur=null; }
          }
        }
        if(cur) blocks.push(cur);
        return blocks;
      }

      const blocks = makeBlocks();
      if(!blocks.length){
        autoBlocks.appendChild(el('span', {class:'tag'}, ['No Te Reo blocks detected']));
      } else {
        let bi = 0;
        for(const b of blocks){
          bi += 1;
          const label = `Block ${bi}: #${b.start+1} to #${b.end+1}`;
          const item = el('div', {style:'display:flex; gap:8px; align-items:center;'});
          item.appendChild(el('span', {class:'tag good'}, [label]));
          item.appendChild(el('span', {class:'mono'}, [b.words.join(' ')]));
          autoBlocks.appendChild(item);
        }
      }

      // Word details table
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['#']),
        el('th', {}, ['Word']),
        el('th', {}, ['Score']),
        el('th', {}, ['Process']),
        el('th', {}, ['Signals'])
      ]));
      autoTbl.appendChild(thead);

      const tbody = el('tbody');
      for(let i=0;i<scored.length;i++){
        const t = scored[i];
        const include = !!wrapMap[t.key];
        const pct = Math.round((t.score || 0) * 100) + '%';
        const sigs = renderSignalPills(t.signals || [], (id)=>{ /* no-op */ });

        const procCell = el('td', {});
        const cb = el('input', {type:'checkbox', title:'Toggle processing for this token'});
        cb.checked = include;
        cb.addEventListener('click', (e)=>{ e.stopPropagation(); });
        cb.addEventListener('change', ()=>{
          autoSetOverride(t.key, !!cb.checked);
          AUTO_DETECT_STATE.selectedKey = t.key;
          runAutoDetectAnalysis(true);
        });
        procCell.appendChild(cb);

        const ov = autoGetOverride(t.key);
        if(ov !== null){
          procCell.appendChild(el('span', {class:'tag', style:'margin-left:6px;'}, ['Override']));
        }

        const tr = el('tr', {style:'cursor:pointer;'}, [
          el('td', {class:'mono'}, [String(i+1)]),
          el('td', {class:'mono'}, [String(t.raw || '')]),
          el('td', {}, [el('span', {class:'tag ' + scoreToLabel(t.score || 0).cls}, [pct])]),
          procCell,
          el('td', {}, [sigs])
        ]);
        tr.addEventListener('click', ()=>{ selectAutoToken(i); });
        tbody.appendChild(tr);
      }
      autoTbl.appendChild(tbody);

      function selectAutoToken(i){
        const t = scored[i];
        if(!t) return;
        for(let j=0;j<tokSpans.length;j++){
          tokSpans[j].classList.toggle('sel', j===i);
        }
        const include = !!wrapMap[t.key];
        AUTO_DETECT_STATE.selectedKey = t.key;

        autoSel.innerHTML = '';
        autoSel.appendChild(el('div', {class:'row'}, [
          el('span', {class:'tag ' + scoreToLabel(t.score || 0).cls}, [scoreToLabel(t.score || 0).label]),
          include ? el('span', {class:'tag good'}, ['Included']) : el('span', {class:'tag'}, ['Not Included']),
          el('span', {class:'mono'}, [String(t.raw || '')])
        ]));

        const ov = autoGetOverride(t.key);
        const ovRow = el('div', {class:'row', style:'margin-top:8px; align-items:center;'}, []);
        const ovCb = el('input', {type:'checkbox', title:'Toggle whether this token is processed as te reo (wrap in <phoneme>)'});
        ovCb.checked = include;
        ovCb.addEventListener('change', ()=>{
          autoSetOverride(t.key, !!ovCb.checked);
          runAutoDetectAnalysis(true);
        });
        ovRow.appendChild(ovCb);
        ovRow.appendChild(el('span', {class:'muted'}, ['Process as Te Reo (Wrap In <phoneme>)']));

        if(ov !== null){
          const tag = el('span', {class:'tag', style:'margin-left:8px;'}, ['Override']);
          const btnClear = el('button', {class:'btn', type:'button', style:'padding:6px 10px;'}, ['Clear']);
          btnClear.addEventListener('click', ()=>{
            delete AUTO_DETECT_STATE.overrides[t.key];
            runAutoDetectAnalysis(true);
          });
          ovRow.appendChild(tag);
          ovRow.appendChild(btnClear);
        } else {
          ovRow.appendChild(el('span', {class:'tag', style:'margin-left:8px; opacity:.8;'}, ['Auto']));
        }
        autoSel.appendChild(ovRow);

        const info = el('div', {style:'margin-top:8px;'});
        info.appendChild(el('div', {class:'muted'}, ['Normalized']));
        info.appendChild(el('div', {class:'mono'}, [String(t.norm || '')]));

        info.appendChild(el('div', {class:'muted', style:'margin-top:8px;'}, ['Signals']));
        info.appendChild(renderSignalPills(t.signals || []));

        if(showDebug){
          info.appendChild(el('div', {class:'muted', style:'margin-top:8px;'}, ['Debug']));
          const pre = el('pre', {class:'mono', style:'white-space:pre-wrap;'}, [JSON.stringify({base:t.base, contextDelta:t.contextDelta, contextNotes:t.contextNotes, debug:t.debug}, null, 2)]);
          info.appendChild(pre);
        }
        autoSel.appendChild(info);
      }

      // Auto-select first included token, else first token
      let selIdx = -1;
      if(AUTO_DETECT_STATE.selectedKey){
        selIdx = scored.findIndex(t => t && t.key === AUTO_DETECT_STATE.selectedKey);
      }
      if(selIdx < 0){
        const firstInc = scored.findIndex(t => !!wrapMap[t.key]);
        selIdx = (firstInc >= 0) ? firstInc : 0;
      }
      selectAutoToken(selIdx);

      // Persist threshold into g2p aws prefs
      saveG2pAwsTtsPrefs({...loadG2pAwsTtsPrefs(), autoDetectThreshold: thr });
    }

    function runAutoDetectAnalysis(renderUi){
      const h = autoDetectHash();
      if(AUTO_DETECT_STATE.lastHash !== h){
        AUTO_DETECT_STATE.lastHash = h;
        AUTO_DETECT_STATE.overrides = {};
        AUTO_DETECT_STATE.selectedKey = null;
      }
      const res = computeAutoDetect();
      if(renderUi) renderAutoDetectUI(res);
      return res;
    }

    function buildSsmlFromInput(){
      const mode = modeSelect.value;
      const joinMode = joinSelect.value;
      const outputMode = outputModeSelect.value || 'phoneme';

      function normKey(s){
        return String(s || '').trim().toLowerCase();
      }

      const nextPrefs = {
        ...loadG2pAwsTtsPrefs(),
        inputMode: mode,
        joinMode,
        outputMode,
        mixedWrap,
        wrapSpeak: speakInput.checked,
        emptyPhonemeBody: emptyBodyInput.checked,
        preservePunct: punctInput.checked,
        splitHyphen: hyphenInput.checked,
        trimNonFinalH: trimNonFinalHInput.checked,
        strictMissing: strictInput.checked,
        showTrace: traceInput.checked,
        lastInputText: input.value
      };
      saveG2pAwsTtsPrefs(nextPrefs);

      mapWrap.innerHTML = '';
      traceWrap.innerHTML = '';

      const items = [];
      let ssmlBody = '';

      function showMixedPanel(show){
        mixedPanel.style.display = show ? '' : 'none';
      }

      let _mixedTokenCounterForWrap = 0;
      function _mixedTokenKeyFor(word){
        _mixedTokenCounterForWrap += 1;
        const base = normKey(word) || 'word';
        return `${base}#${_mixedTokenCounterForWrap}`;
      }

      function buildMixedTokenIndex(){
        const raw = String(input.value || '');
        const splitHyphen = !!hyphenInput.checked;
        const preserve = !!punctInput.checked;
        const tokens = [];
        let n = 0;

        function pushWord(word){
          const w = String(word || '').trim();
          if(!w) return;
          n += 1;
          const base = normKey(w) || 'word';
          const key = `${base}#${n}`;
          const label = `#${String(n).padStart(2,'0')} ${w}`;
          tokens.push({key, label, word:w, base});
        }

        function addWordOrParts(word){
          const w = String(word || '').trim();
          if(!w) return;
          if(splitHyphen){
            for(const p of w.split('-').filter(Boolean)) pushWord(p);
          } else {
            pushWord(w);
          }
        }

        if(mode === 'single'){
          addWordOrParts(raw.trim());
        } else if(mode === 'list'){
          const words = raw.split(/[\n\r\t,;]+/g).map(x=>x.trim()).filter(Boolean);
          for(const w of words) addWordOrParts(w);
        } else {
          if(preserve){
            const toks = tokenizeTextPreserve(raw, splitHyphen);
            for(const tok of toks){
              if(tok.type === 'word') pushWord(tok.text);
            }
          } else {
            const words = raw.split(/\s+/g).map(x=>x.trim()).filter(Boolean);
            for(const w of words) addWordOrParts(w);
          }
        }

        return {tokens};
      }

      function rebuildMixedList(){
        const idx = buildMixedTokenIndex();
        const filt = String(mixedFilter.value || '').trim().toLowerCase();
        mixedList.innerHTML = '';

        for(const tok of idx.tokens){
          const key = tok.key;
          const base = tok.base;
          if(mixedWrap[key] === undefined){
            if(base && mixedWrap[base] !== undefined) mixedWrap[key] = mixedWrap[base];
            else mixedWrap[key] = true;
          }
          const label = tok.label || tok.word || key;
          if(filt && !label.toLowerCase().includes(filt) && !String(key).toLowerCase().includes(filt) && !String(tok.word||'').toLowerCase().includes(filt)) continue;

          const row = el('div', {style:'display:flex; align-items:center; gap:10px; padding:4px 2px;'});
          const cb = el('input', {type:'checkbox'});
          cb.checked = (mixedWrap[key] !== false);
          cb.addEventListener('change', ()=>{
            mixedWrap[key] = !!cb.checked;
            saveG2pAwsTtsPrefs({ ...loadG2pAwsTtsPrefs(), mixedWrap, outputMode: (outputModeSelect.value || 'mixed') });
          });
          const txt = el('div', {class:'mono', style:'opacity:.95;'}, [label]);
          row.appendChild(cb);
          row.appendChild(txt);
          mixedList.appendChild(row);
        }
      }

      function ensureMixedReady(){
        showMixedPanel(true);
        rebuildMixedList();
      }

      let autoWrapMap = null;

      function shouldWrapWord(word){
        if(outputMode === 'phoneme') return true;
        if(outputMode === 'plain') return false;
        const w = String(word || '');
        const key = _mixedTokenKeyFor(w);

        if(outputMode === 'mixedAuto'){
          if(!autoWrapMap){
            const res = runAutoDetectAnalysis(false);
            autoWrapMap = (res && res.wrapMap) ? res.wrapMap : {};
          }
          return autoWrapMap[key] === true;
        }

        if(outputMode !== 'mixed') return false;

        if(mixedWrap[key] === undefined){
          const base = normKey(w);
          if(base && mixedWrap[base] !== undefined) mixedWrap[key] = mixedWrap[base];
          else mixedWrap[key] = true;
        }
        return mixedWrap[key] !== false;
      }

      function ssmlPieceForWord(word){

        const w = String(word || '');
        if(shouldWrapWord(w)){
          const r = mapWordToIpa(w);
          r.kind = 'phoneme';
          r.ssmlPiece = r.phoneme;
          items.push(r);
          return r.phoneme;
        }
        const piece = escapeHtml(w);
        items.push({kind:'plain', word:w, segments:[], ipa:'', phoneme:piece, ssmlPiece:piece});
        return piece;
      }

      function buildPlainSpeakBody(){
        const raw = String(input.value || '');
        if(mode === 'single') return raw.trim();
        if(mode === 'list'){
          const words = raw.split(/[\n\r\t,;]+/g).map(x=>x.trim()).filter(Boolean);
          return words.join(', ');
        }
        return raw;
      }

      if(outputMode === 'plain'){
        showMixedPanel(false);
        showAutoPanel(false);
        ssmlBody = escapeHtml(buildPlainSpeakBody());
      } else {
        if(outputMode === 'mixed'){
          showAutoPanel(false);
          ensureMixedReady();
        } else if(outputMode === 'mixedAuto'){
          showMixedPanel(false);
          showAutoPanel(true);
          runAutoDetectAnalysis(true);
        } else {
          showMixedPanel(false);
          showAutoPanel(false);
        }

        if(mode === 'single'){
          const parts = splitWordParts(input.value);
          for(let pi=0; pi<parts.length; pi++){
            if(pi > 0 && hyphenInput.checked) ssmlBody += '-';
            ssmlBody += ssmlPieceForWord(parts[pi]);
          }
        } else if(mode === 'list'){
          const raw = String(input.value || '');
          const words = raw.split(/[\n\r\t,;]+/g).map(x=>x.trim()).filter(Boolean);
          const outs = [];
          for(const w of words){
            const parts = splitWordParts(w);
            let partOut = '';
            for(let pi=0; pi<parts.length; pi++){
              if(pi > 0 && hyphenInput.checked) partOut += '-';
              partOut += ssmlPieceForWord(parts[pi]);
            }
            outs.push(partOut);
          }
          ssmlBody = outs.join(', ');
        } else {
          const preserve = punctInput.checked;
          if(!preserve){
            const raw = String(input.value || '');
            const words = raw.split(/\s+/g).map(x=>x.trim()).filter(Boolean);
            const outs = [];
            for(const w of words){
              const parts = splitWordParts(w);
              let partOut = '';
              for(let pi=0; pi<parts.length; pi++){
                if(pi > 0 && hyphenInput.checked) partOut += '-';
                partOut += ssmlPieceForWord(parts[pi]);
              }
              outs.push(partOut);
            }
            ssmlBody = outs.join(' ');
          } else {
            const toks = tokenizeTextPreserve(input.value, hyphenInput.checked);
            for(const tok of toks){
              if(tok.type === 'sep'){
                ssmlBody += tok.text;
                continue;
              }
              ssmlBody += ssmlPieceForWord(tok.text);
            }
          }
        }
      }

      const ssml = speakInput.checked ? `<speak>${ssmlBody}</speak>` : ssmlBody;
      ssmlOut.value = ssml;

      _g2pAwsTtsSetStemFromInput(mode, input.value);
      lastAudioBlob = null;

      if(outputMode === 'plain'){
        mapWrap.appendChild(el('p', {}, ['Plain Speak mode: output is wrapped only in <speak> with no <phoneme> tags.']));
        if(traceInput.checked){
          const lines = [];
          lines.push(`inputMode: ${mode}`);
          lines.push(`outputMode: ${outputMode}`);
          lines.push(`wrapSpeak: ${speakInput.checked}`);
          traceWrap.appendChild(el('pre', {class:'mono', style:'white-space:pre-wrap;'}, [lines.join('\n')]));
        }
      } else {
        const mapped = items.filter(x => x && x.word != null);
        const t = el('table', {class:'table'});
        const thead = el('thead');
        thead.appendChild(el('tr', {}, [
          el('th', {}, ['Word']),
          el('th', {}, ['Segments']),
          el('th', {}, ['IPA']),
          el('th', {}, ['SSML'])
        ]));
        t.appendChild(thead);
        const tb = el('tbody');
        for(const r of mapped){
          const segStr = r.segments ? segmentsToString(r.segments) : '';
          const ipaStr = r.ipa || '';
          tb.appendChild(el('tr', {}, [
            el('td', {class:'mono'}, [String(r.word || '')]),
            el('td', {class:'mono'}, [segStr]),
            el('td', {class:'mono'}, [ipaStr]),
            el('td', {class:'mono'}, [String(r.ssmlPiece || r.phoneme || '')])
          ]));
        }
        t.appendChild(tb);
        mapWrap.appendChild(t);

        if(traceInput.checked){
          const missing = mapped.filter(x => x && x.rows && x.rows.some(rr => rr.status === 'missing'));
          const lines = [];
          lines.push(`inputMode: ${mode}`);
          lines.push(`joinMode: ${joinMode}`);
          lines.push(`outputMode: ${outputMode}`);
          lines.push(`wrapSpeak: ${speakInput.checked}`);
          lines.push(`emptyPhonemeBody: ${emptyBodyInput.checked}`);
          lines.push(`preservePunct: ${punctInput.checked}`);
          lines.push(`splitHyphen: ${hyphenInput.checked}`);
          lines.push(`trimNonFinalH: ${trimNonFinalHInput.checked}`);
          lines.push(`strictMissing: ${strictInput.checked}`);
          if(missing.length){
            lines.push('');
            lines.push('Missing Lexicon Matches:');
            for(const r of missing){
              const missSegs = (r.rows || []).filter(rr => rr.status === 'missing').map(rr => rr.segment).filter(Boolean);
              lines.push(`- ${r.word}: ${missSegs.join(', ')}`);
            }
          }
          traceWrap.appendChild(el('pre', {class:'mono', style:'white-space:pre-wrap;'}, [lines.join('\n')]));
        }

        addG2pAwsTtsHistoryEntry({
          ts: new Date().toISOString(),
          inputMode: mode,
          inputText: String(input.value || ''),
          joinMode,
          outputMode,
          mixedWrap,
          ssml,
          cfg: {
            serviceRegion: serviceRegion.value,
            awsRegion: awsRegion.value,
            voiceId: voiceId.value,
            engine: engine.value,
            languageCode: languageCode.value,
            outputFormat: outputFormat.value
          },
          items: mapped
        });
      }

      if(outputMode === 'plain'){
        addG2pAwsTtsHistoryEntry({
          ts: new Date().toISOString(),
          inputMode: mode,
          inputText: String(input.value || ''),
          joinMode,
          outputMode,
          mixedWrap,
          ssml,
          cfg: {
            serviceRegion: serviceRegion.value,
            awsRegion: awsRegion.value,
            voiceId: voiceId.value,
            engine: engine.value,
            languageCode: languageCode.value,
            outputFormat: outputFormat.value
          },
          items: []
        });
      }

      drawHistory();
      return ssml;
    }

    function drawHistory(){
      const items = loadG2pAwsTtsHistory();
      histBody.innerHTML = '';
      for(const it of (items || [])){
        const when = String(it.ts || '');
        const mode = String(it.inputMode || '');
        const inPreview = String(it.inputText || '').replace(/\s+/g,' ').slice(0, 60);
        const voice = String((it.cfg && it.cfg.voiceId) || '');
        const region = String((it.cfg && it.cfg.awsRegion) || '');

        const tr = el('tr', {style:'cursor:pointer;'});
        tr.appendChild(el('td', {class:'mono'}, [when]));
        tr.appendChild(el('td', {class:'mono'}, [mode]));
        tr.appendChild(el('td', {}, [inPreview]));
        tr.appendChild(el('td', {class:'mono'}, [voice]));
        tr.appendChild(el('td', {class:'mono'}, [region]));

        tr.addEventListener('click', ()=>{
          input.value = it.inputText || '';
          modeSelect.value = it.inputMode || 'text';
          joinSelect.value = it.joinMode || 'dot';
          outputModeSelect.value = it.outputMode || 'phoneme';
          mixedWrap = Object.assign({}, (it.mixedWrap || mixedWrap || {}));
          _g2pAwsTtsUpdateOutputModeUI();
          ssmlOut.value = it.ssml || '';
          _g2pAwsTtsSetStemFromInput(it.inputMode || 'text', it.inputText || '');
          lastAudioBlob = null;
          if(it.cfg){
            serviceRegion.value = it.cfg.serviceRegion || serviceRegion.value;
            awsRegion.value = it.cfg.awsRegion || awsRegion.value;
            voiceId.value = it.cfg.voiceId || voiceId.value;
            engine.value = it.cfg.engine || engine.value;
            languageCode.value = it.cfg.languageCode || languageCode.value;
            outputFormat.value = it.cfg.outputFormat || outputFormat.value;
          }
        });

        histBody.appendChild(tr);
      }
    }

    btnGenerate.addEventListener('click', buildSsmlFromInput);

    
    function _g2pAwsTtsRebuildMixed(){
      // rebuild list without generating SSML (includes duplicates in-order)
      const mode = modeSelect.value;
      const splitHyphen = !!hyphenInput.checked;
      const preserve = !!punctInput.checked;
      const raw = String(input.value || '');

      const tokens = [];
      let n = 0;
      const normKey = (s)=> String(s||'').trim().toLowerCase();

      function pushWord(word){
        const w = String(word || '').trim();
        if(!w) return;
        n += 1;
        const base = normKey(w) || 'word';
        const key = `${base}#${n}`;
        const label = `#${String(n).padStart(2,'0')} ${w}`;
        tokens.push({key, label, word:w, base});
      }

      function addWordOrParts(word){
        const w = String(word || '').trim();
        if(!w) return;
        if(splitHyphen){
          for(const p of w.split('-').filter(Boolean)) pushWord(p);
        } else {
          pushWord(w);
        }
      }

      if(mode === 'single'){
        addWordOrParts(raw.trim());
      } else if(mode === 'list'){
        const words = raw.split(/[\n\r\t,;]+/g).map(x=>x.trim()).filter(Boolean);
        for(const w of words) addWordOrParts(w);
      } else {
        if(preserve){
          const toks = tokenizeTextPreserve(raw, splitHyphen);
          for(const tok of toks){
            if(tok.type === 'word') pushWord(tok.text);
          }
        } else {
          const words = raw.split(/\s+/g).map(x=>x.trim()).filter(Boolean);
          for(const w of words) addWordOrParts(w);
        }
      }

      const filt = String(mixedFilter.value || '').trim().toLowerCase();
      mixedList.innerHTML = '';
      for(const tok of tokens){
        const key = tok.key;
        const base = tok.base;
        if(mixedWrap[key] === undefined){
          if(base && mixedWrap[base] !== undefined) mixedWrap[key] = mixedWrap[base];
          else mixedWrap[key] = true;
        }
        const label = tok.label || tok.word || key;
        if(filt && !label.toLowerCase().includes(filt) && !String(key).toLowerCase().includes(filt) && !String(tok.word||'').toLowerCase().includes(filt)) continue;

        const row = el('div', {style:'display:flex; align-items:center; gap:10px; padding:4px 2px;'});
        const cb = el('input', {type:'checkbox'});
        cb.checked = (mixedWrap[key] !== false);
        cb.addEventListener('change', ()=>{
          mixedWrap[key] = !!cb.checked;
          saveG2pAwsTtsPrefs({ ...loadG2pAwsTtsPrefs(), mixedWrap, outputMode: (outputModeSelect.value || 'mixed') });
        });
        row.appendChild(cb);
        row.appendChild(el('div', {class:'mono', style:'opacity:.95;'}, [label]));
        mixedList.appendChild(row);
      }
    }

    function _g2pAwsTtsUpdateOutputModeUI(){
      const om = outputModeSelect.value || 'phoneme';
      if(om === 'mixed'){
        mixedPanel.style.display = '';
        autoPanel.style.display = 'none';
        _g2pAwsTtsRebuildMixed();
      } else if(om === 'mixedAuto'){
        mixedPanel.style.display = 'none';
        autoPanel.style.display = '';
        scheduleAutoDetect();
      } else {
        mixedPanel.style.display = 'none';
        autoPanel.style.display = 'none';
      }
    }

    outputModeSelect.addEventListener('change', ()=>{
      const p = loadG2pAwsTtsPrefs();
      saveG2pAwsTtsPrefs({ ...p, outputMode: outputModeSelect.value || 'phoneme', mixedWrap });
      _g2pAwsTtsUpdateOutputModeUI();
    });

    btnMixedRefresh.addEventListener('click', _g2pAwsTtsRebuildMixed);
    mixedFilter.addEventListener('input', _g2pAwsTtsRebuildMixed);

    btnMixedAll.addEventListener('click', ()=>{
      const p = loadG2pAwsTtsPrefs();
      _g2pAwsTtsRebuildMixed();
      for(const k of Object.keys(mixedWrap || {})) mixedWrap[k] = true;
      saveG2pAwsTtsPrefs({ ...p, mixedWrap, outputMode: 'mixed' });
      _g2pAwsTtsRebuildMixed();
    });

    btnMixedNone.addEventListener('click', ()=>{
      const p = loadG2pAwsTtsPrefs();
      _g2pAwsTtsRebuildMixed();
      for(const k of Object.keys(mixedWrap || {})) mixedWrap[k] = false;
      saveG2pAwsTtsPrefs({ ...p, mixedWrap, outputMode: 'mixed' });
      _g2pAwsTtsRebuildMixed();
    });

    btnMixedInvert.addEventListener('click', ()=>{
      const p = loadG2pAwsTtsPrefs();
      _g2pAwsTtsRebuildMixed();
      for(const k of Object.keys(mixedWrap || {})) mixedWrap[k] = !(mixedWrap[k] !== false);
      saveG2pAwsTtsPrefs({ ...p, mixedWrap, outputMode: 'mixed' });
      _g2pAwsTtsRebuildMixed();
    });

    // initialize mixed panel based on stored prefs
    _g2pAwsTtsUpdateOutputModeUI();



    btnCopy.addEventListener('click', ()=>{
      const t = ssmlOut.value || '';
      if(navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(t);
    });

    btnDownload.addEventListener('click', ()=>{
      downloadText((lastExportStem || 'g2p_aws_tts') + '.ssml', ssmlOut.value || '', 'text/plain');
    });

    btnClearHist.addEventListener('click', ()=>{
      saveG2pAwsTtsHistory([]);
      drawHistory();
    });

    btnExportHist.addEventListener('click', ()=>{
      const items = loadG2pAwsTtsHistory();
      downloadText('aws_tts_history.json', JSON.stringify(items || [], null, 2), 'application/json');
    });

    histFile.addEventListener('change', async ()=>{
      const f = histFile.files && histFile.files[0];
      if(!f) return;
      const txt = await f.text();
      const parsed = safeJsonParse(txt);
      if(!parsed.ok || !Array.isArray(parsed.value)) return;
      saveG2pAwsTtsHistory(parsed.value);
      drawHistory();
      histFile.value = '';
    });

    btnSaveCfg.addEventListener('click', ()=>{
      const next = {
        ...loadG2pAwsTtsPrefs(),
        serviceRegion: serviceRegion.value,
        awsRegion: awsRegion.value,
        voiceId: voiceId.value,
        engine: engine.value,
        languageCode: languageCode.value,
        outputFormat: outputFormat.value
      };
      saveG2pAwsTtsPrefs(next);

      const remember = !!rememberInput.checked;
      if(remember){
        saveG2pAwsTtsCreds({
          remember: true,
          accessKeyId: accessKeyId.value,
          secretAccessKey: secretAccessKey.value,
          sessionToken: sessionToken.value
        });
      } else {
        saveG2pAwsTtsCreds({remember:false});
      }

      playTrace.textContent = 'Saved.';
    });

    

    btnDownloadMp3.addEventListener('click', ()=>{
      if(!lastAudioBlob){
        playTrace.textContent = 'No MP3 available. Click Play SSML first.';
        return;
      }
      const name = (lastExportStem || 'g2p_aws_tts') + '.mp3';
      _g2pAwsTtsDownloadBlob(name, lastAudioBlob);
    });

btnPlay.addEventListener('click', async ()=>{
      playTrace.textContent = '';
      const ssml = (ssmlOut.value || '').trim();
      if(!ssml){
        playTrace.textContent = 'No SSML to play.';
        return;
      }
      if(typeof AWS === 'undefined' || !AWS || !AWS.Polly){
        playTrace.textContent = 'AWS SDK not available. Check that the script loaded.';
        return;
      }
      const ak = String(accessKeyId.value || '').trim();
      const sk = String(secretAccessKey.value || '').trim();
      if(!ak || !sk){
        playTrace.textContent = 'Missing AWS credentials.';
        return;
      }
      try{
        AWS.config.region = awsRegion.value;
        AWS.config.credentials = new AWS.Credentials({
          accessKeyId: ak,
          secretAccessKey: sk,
          sessionToken: String(sessionToken.value || '').trim() || undefined
        });

        const polly = new AWS.Polly({apiVersion:'2016-06-10', region: awsRegion.value});
        const params = {
          Text: ssml,
          OutputFormat: outputFormat.value || 'mp3',
          VoiceId: voiceId.value || 'Aria',
          TextType: 'ssml',
          Engine: engine.value || 'neural'
        };
        const lc = String(languageCode.value || '').trim();
        if(lc) params.LanguageCode = lc;

        playTrace.textContent = JSON.stringify({params}, null, 2);

        const data = await polly.synthesizeSpeech(params).promise();
        if(!data || !data.AudioStream){
          playTrace.textContent += '\n\nNo audio stream in response.';
          return;
        }

        let blob;
        const stream = data.AudioStream;
        if(stream instanceof ArrayBuffer){
          blob = new Blob([stream], {type:'audio/mpeg'});
        } else if(stream && stream.buffer){
          blob = new Blob([stream.buffer], {type:'audio/mpeg'});
        } else {
          blob = new Blob([stream], {type:'audio/mpeg'});
        }

        lastAudioBlob = blob;

        audio.src = URL.createObjectURL(blob);
        await audio.play();
      } catch(e){
        playTrace.textContent = 'Error: ' + String(e && e.message ? e.message : e) + '\n\n' +
          'Boto3 params reference:\n' +
          "Text=ssml, OutputFormat='mp3', VoiceId='Aria', TextType='ssml', LanguageCode='en-NZ', Engine='neural'";
      }
    });

    // initial history render
    drawHistory();
  }



  // Te Reo Detect
  const DETECTION_SIGNALS = [
    { id:'D01', cat:'Character Set', title:'Allowed Character Inventory', desc:`Māori orthography uses a constrained letter set (with macrons) and common digraphs (ng, wh).\nIf a token contains letters outside the inventory (for example b, d, f, l, s, v, x, y, z) it is less likely to be te reo.` },
    { id:'D02', cat:'Character Set', title:'Macron Presence', desc:`Macrons (ā ē ī ō ū) are a strong signal for te reo Māori spelling.\nIf a token contains a macron, likelihood increases.` },
    { id:'D03', cat:'Phonotactics', title:'Digraph Presence', desc:`The digraphs 'ng' and 'wh' are frequent in te reo Māori.\nIf a token contains ng or wh, likelihood increases.` },
    { id:'D04', cat:'Phonotactics', title:'Ends With Vowel', desc:`Many te reo Māori words end in a vowel.\nIf a token ends in a vowel or macron vowel, likelihood increases. If it ends in a consonant, likelihood decreases.` },
    { id:'D05', cat:'Phonotactics', title:'Vowel Density', desc:`Te reo Māori tends to have a relatively high vowel density.\nThis is a soft signal and is used only as a minor adjustment.` },
    { id:'D06', cat:'Segmenter', title:'Segmenter Produces Clean CV Units', desc:`If the v12 segmenter produces segments that look like valid CV or digraph+vowel units, that increases likelihood.\nIf it produces orphan consonant segments, likelihood decreases.` },
    { id:'D07', cat:'Lexicon', title:'Segment Coverage In IPA Lexicon', desc:`If most produced segments exist as 'Unit' entries in your G2P lexicon, likelihood increases.\nLow coverage suggests the token may not be te reo (or is out-of-lexicon).` },
    { id:'D08', cat:'Tokens', title:'Particle Token (Medium-High)', desc:`Some tokens (for example 'te', 'ki', 'ko', 'ngā') often appear as particles.\nThese can be short and sometimes overlap with English tokens so they are treated as medium-high likelihood, then adjusted by context.` },
    { id:'D09', cat:'Tokens', title:'Ambiguous Token', desc:`Some tokens can plausibly be English or te reo (for example 'to', 'he', 'me').\nThese start lower and are then pulled up or down based on nearby tokens.` },
    { id:'D10', cat:'Context', title:'Neighbor Context Boost', desc:`If an ambiguous or particle token sits next to a high-likelihood te reo token, its score is boosted.\nIf it sits inside a strongly English pattern, its score is reduced.` },
    { id:'D11', cat:'Character Set', title:'Forbidden Letters (Hard Reject)', desc:`If a token contains any of the letters b, c, d, f, j, l, q, s, v, x, y, z then it is not standard te reo Maori orthography.
This is treated as a hard reject signal and the score is capped very low.` },
    { id:'D12', cat:'Lexicon', title:'Zero Lexicon Unit Matches', desc:`If the segmenter output yields zero matching units in the IPA lexicon, the token is unlikely to be te reo.
A very small chance remains for out-of-lexicon items or a rare segmentation mismatch, but the score is strongly penalized and capped.` },
    { id:'D13', cat:'Context', title:'Zero Neighbor Propagation', desc:`If a token is treated as 0% (hard reject), an adjacent short or ambiguous token can also be treated as 0%.
This prevents ambiguous items like "to" from being misclassified as te reo when sitting next to a clear non-Māori word.
This rule is only applied in the Te Reo Detect tab and does not apply in the Text Block tab.` }
,    { id:'D14', cat:'Phonotactics', title:'Final Consonant Penalty', desc:`Standard te reo Maori word forms end in a vowel (including macron vowels).
If a token ends in a consonant, it is strongly unlikely to be te reo and its score is capped low.` }
,    { id:'D15', cat:'Phonotactics', title:'Illegal Consonant Cluster', desc:`Te reo Maori does not generally allow consonant clusters (two consonants in a row) except the digraphs 'ng' and 'wh'.
If a token contains other consonant-consonant sequences (including doubled consonants), it is strongly penalized and capped.` }
,    { id:'D16', cat:'Phonotactics', title:'Digraph Must Be Followed By Vowel', desc:`The digraphs 'ng' and 'wh' act as consonants and should be followed by a vowel in standard te reo Maori spelling.
If 'ng' or 'wh' occurs at the end of a word or is followed by a consonant, it is strongly penalized and capped.` }
,    { id:'D17', cat:'Phonotactics', title:'Invalid g Usage', desc:`In standard te reo Maori orthography, the letter 'g' only appears as part of the digraph 'ng'.
If 'g' appears without immediately following 'n', the token is strongly unlikely to be te reo.` }

  ];

  const DET_SIGNAL_BY_ID = new Map(DETECTION_SIGNALS.map(s => [s.id, s]));

  function loadDetectPrefs(){
    const raw = loadFromStorage(STORAGE_KEYS.detectPrefs);
    const parsed = raw ? safeJsonParse(raw) : {ok:false};
        if(parsed.ok && parsed.value && typeof parsed.value === 'object') return parsed.value;
    return { showDebug: false, contextBoost: true };
  }

  function saveDetectPrefs(prefs){
    return saveToStorage(STORAGE_KEYS.detectPrefs, JSON.stringify(prefs || {}, null, 2));
  }

  function defaultAmbiguousTokens(){
    return ['to','he','me','no','a','i','o','e'];
  }

  function defaultParticleTokens(){
    return ['te','ki','ko','nga','ngā','kei','kua','hei','nā','na','mā','ma','mō','mo'];
  }

  function parseTokenList(text){
    const raw = String(text || '').split(/[\n,]+/).map(x => x.trim().toLowerCase()).filter(Boolean);
    return uniquePreserveOrder(raw);
  }

  function loadTokenList(key, fallbackFn){
    const raw = loadFromStorage(key);
    if(!raw) return fallbackFn();
    const parsed = safeJsonParse(raw);
    if(parsed.ok && Array.isArray(parsed.value)) return parsed.value.map(x=>String(x||'').trim().toLowerCase()).filter(Boolean);
    // allow plain text list storage too
    return parseTokenList(raw) || fallbackFn();
  }

  function saveTokenList(key, arr){
    return saveToStorage(key, JSON.stringify(arr || [], null, 2));
  }

  function loadDetectHistory(){
    const raw = loadFromStorage(STORAGE_KEYS.detectHistory);
    if(!raw) return [];
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !Array.isArray(parsed.value)) return [];
    return parsed.value;
  }

  function saveDetectHistory(items){
    return saveToStorage(STORAGE_KEYS.detectHistory, JSON.stringify(items || [], null, 2));
  }

  function addDetectHistoryEntry(entry){
    const items = loadDetectHistory();
    const sig = `${entry.input || ''}::${(entry.tokens||[]).map(t=>t.norm||t.raw||'').join('|')}`;
    const filtered = items.filter(x => `${x.input || ''}::${(x.tokens||[]).map(t=>t.norm||t.raw||'').join('|')}` !== sig);
    filtered.unshift(entry);
    saveDetectHistory(filtered.slice(0, 200));
  }


  function loadDetectBlockHistory(){
    const raw = loadFromStorage(STORAGE_KEYS.detectBlockHistory);
    if(!raw) return [];
    const parsed = safeJsonParse(raw);
    if(!parsed.ok || !Array.isArray(parsed.value)) return [];
    return parsed.value;
  }

  function saveDetectBlockHistory(items){
    return saveToStorage(STORAGE_KEYS.detectBlockHistory, JSON.stringify(items || [], null, 2));
  }

  function addDetectBlockHistoryEntry(entry){
    const items = loadDetectBlockHistory();
    const sig = `${(entry.text||'').trim()}::${String(entry.threshold||'')}`;
    const filtered = items.filter(x => `${(x.text||'').trim()}::${String(x.threshold||'')}` !== sig);
    filtered.unshift(entry);
    saveDetectBlockHistory(filtered.slice(0, 120));
  }

  function tokenizeText(input){
    const s = String(input || '').trim();
    if(!s) return [];
    // split on whitespace but keep internal apostrophes/macrons
    const rough = s.split(/\s+/).filter(Boolean);
    const tokens = [];
    for(const part of rough){
      // strip leading/trailing punctuation
      const m = part.match(/^(["'“”‘’\(\[\{]*)(.*?)([\.,;:!\?\)\]\}"'“”‘’]*)$/);
      const core = m ? m[2] : part;
      if(core) tokens.push({ raw: core, rawWithPunct: part });
    }
    return tokens;
  }

  const MAORI_ALLOWED = new Set('aeiouāēīōūhkmnprtw');
  const MAORI_VOWELS = new Set('aeiouāēīōū');
  const MAORI_FORBIDDEN = new Set('bcdfjlqsvxyz'.split(''));

  function hasForbiddenLetters(token){
    const letters = (String(token||'').match(/[a-zāēīōū]/g) || []);
    for(const ch of letters){
      if(MAORI_FORBIDDEN.has(ch)) return true;
    }
    return false;
  }


  function hasMacron(token){
    return /[āēīōū]/.test(token);
  }

  function endsWithVowel(token){
    const t = String(token||'');
    if(!t) return false;
    const last = t.slice(-1);
    return MAORI_VOWELS.has(last);
  }

  function isLetterChar(ch){
    return /[a-zāēīōū]/.test(ch);
  }

  function isVowelChar(ch){
    return MAORI_VOWELS.has(ch);
  }

  function illegalConsonantPairs(token){
    const t = String(token || '');
    const out = [];
    for(let i=0;i<t.length-1;i++){
      const a = t[i], b = t[i+1];
      if(!isLetterChar(a) || !isLetterChar(b)) continue;
      if(isVowelChar(a) || isVowelChar(b)) continue;
      const pair = a + b;
      if(pair === 'ng' || pair === 'wh') continue;
      out.push({i, pair});
    }
    return out;
  }

  function invalidDigraphFollowers(token){
    const t = String(token || '');
    const issues = [];
    for(let i=0;i<t.length-1;i++){
      const dig = t.slice(i, i+2);
      if(dig === 'ng' || dig === 'wh'){
        const next = t[i+2] || '';
        if(!next || !isVowelChar(next)){
          issues.push({i, dig, next: next || '(end)'});
        }
      }
    }
    return issues;
  }

  function invalidGUsage(token){
    const t = String(token || '');
    for(let i=0;i<t.length;i++){
      if(t[i] === 'g'){
        if(i === 0 || t[i-1] !== 'n') return true;
      }
    }
    return false;
  }

  function vowelDensity(token){
    const letters = (token.match(/[a-zāēīōū]/g) || []);
    if(!letters.length) return 0;
    let v = 0;
    for(const ch of letters){
      if(MAORI_VOWELS.has(ch)) v++;
    }
    return v / letters.length;
  }

  function outsideInventory(token){
    const letters = (token.match(/[a-zāēīōū]/g) || []);
    for(const ch of letters){
      if(!MAORI_ALLOWED.has(ch) && ch !== 'g'){ // g exists only as part of ng, treat carefully
        return true;
      }
    }
    // allow g only if token contains ng somewhere; otherwise treat as outside
    if(letters.includes('g') && !token.includes('ng')) return true;
    return false;
  }

  function lexiconCoverage(segments){
    const segs = normalizeSegments(segments || []);
    if(!segs.length) return 0;
    let hit = 0;
    for(const s of segs){
      if(getLexiconMatches(s).length) hit++;
    }
    return hit / segs.length;
  }

  function orphanConsonantCount(segments){
    const segs = normalizeSegments(segments || []);
    let c = 0;
    for(const s of segs){
      const hasV = [...s].some(ch => MAORI_VOWELS.has(ch));
      if(!hasV) c++;
    }
    return c;
  }

  function clamp01(x){
    return Math.max(0, Math.min(1, x));
  }

  function scoreTokenBase(tokenNorm, lists){
    const signals = [];
    const debug = [];

    if(!tokenNorm){
      return { base: 0, signals, debug };
    }

    // Start neutral
    let score = 0.50;

    let hardBlock = false;
    if(hasForbiddenLetters(tokenNorm)){
      hardBlock = true;
      score = 0.0;
      signals.push('D11');
      debug.push({id:'D11', delta:'cap<=0.00', note:'contains forbidden letters'});
    }

    const outInv = outsideInventory(tokenNorm);
    if(outInv){
      score -= 0.35;
      signals.push('D01');
      debug.push({id:'D01', delta:-0.35, note:'outside inventory'});
    } else {
      score += 0.18;
      signals.push('D01');
      debug.push({id:'D01', delta:+0.18, note:'within inventory'});
    }

    if(hasMacron(tokenNorm)){
      score += 0.25;
      signals.push('D02');
      debug.push({id:'D02', delta:+0.25});
    }

    if(tokenNorm.includes('ng') || tokenNorm.includes('wh')){
      score += 0.12;
      signals.push('D03');
      debug.push({id:'D03', delta:+0.12});
    }

    if(endsWithVowel(tokenNorm)){
      score += 0.10;
      signals.push('D04');
      debug.push({id:'D04', delta:+0.10});
    } else {
      score -= 0.12;
      signals.push('D04');
      debug.push({id:'D04', delta:-0.12});
    }

    const vd = vowelDensity(tokenNorm);
    if(vd >= 0.45){
      score += 0.06;
      signals.push('D05');
      debug.push({id:'D05', delta:+0.06, note:`density ${vd.toFixed(2)}`});
    } else if(vd < 0.30){
      score -= 0.05;
      signals.push('D05');
      debug.push({id:'D05', delta:-0.05, note:`density ${vd.toFixed(2)}`});
    }


    // Additional phonotactic weed-out
    if(!hardBlock){
      // Stronger penalty for final consonant (cap low)
      if(!endsWithVowel(tokenNorm)){
        score -= 0.25;
        score = Math.min(score, 0.18);
        signals.push('D14');
        debug.push({id:'D14', delta:'cap<=0.18 and -0.25', note:'ends with consonant'});
      }

      const pairs = illegalConsonantPairs(tokenNorm);
      if(pairs.length){
        score -= 0.40;
        score = Math.min(score, 0.10);
        signals.push('D15');
        debug.push({id:'D15', delta:'cap<=0.10 and -0.40', note:`illegal pairs: ${pairs.slice(0,6).map(p=>p.pair+'@'+p.i).join(', ')}${pairs.length>6?' …':''}`});
      }

      const digIssues = invalidDigraphFollowers(tokenNorm);
      if(digIssues.length){
        score -= 0.32;
        score = Math.min(score, 0.12);
        signals.push('D16');
        debug.push({id:'D16', delta:'cap<=0.12 and -0.32', note:`digraph issues: ${digIssues.slice(0,6).map(d=>d.dig+'@'+d.i+'→'+d.next).join(', ')}${digIssues.length>6?' …':''}`});
      }

      if(invalidGUsage(tokenNorm)){
        score -= 0.35;
        score = Math.min(score, 0.12);
        signals.push('D17');
        debug.push({id:'D17', delta:'cap<=0.12 and -0.35', note:'g appears outside ng'});
      }
    }

    // Segmenter and lexicon coverage
    const segOut = segmentWordCore(tokenNorm, { trace: false });
    const segs = segOut.segments || [];
    const segNorm = normalizeSegments(segs);
    let lexHits = 0;
    for(const s of segNorm){
      if(getLexiconMatches(s).length) lexHits++;
    }

    const orphans = orphanConsonantCount(segs);
    if(orphans){
      score -= Math.min(0.18, 0.06 * orphans);
      signals.push('D06');
      debug.push({id:'D06', delta: -Math.min(0.18, 0.06 * orphans), note:`${orphans} orphan consonant segment(s)`});
      // Orphan consonant segments indicate a phonotactic mismatch; cap aggressively
      if(orphans >= 2) score = Math.min(score, 0.18);
      else score = Math.min(score, 0.45);
      debug.push({id:'D06', delta:'cap', note:`orphan cap applied (orphans=${orphans})`});
    } else {
      score += 0.06;
      signals.push('D06');
      debug.push({id:'D06', delta:+0.06});
    }

    const cov = segNorm.length ? (lexHits / segNorm.length) : 0;
    if(cov >= 0.80){
      score += 0.22;
      signals.push('D07');
      debug.push({id:'D07', delta:+0.22, note:`coverage ${(cov*100).toFixed(0)}%`});
    } else if(cov >= 0.60){
      score += 0.14;
      signals.push('D07');
      debug.push({id:'D07', delta:+0.14, note:`coverage ${(cov*100).toFixed(0)}%`});
    } else if(cov >= 0.30){
      score += 0.05;
      signals.push('D07');
      debug.push({id:'D07', delta:+0.05, note:`coverage ${(cov*100).toFixed(0)}%`});
    } else {
      score -= 0.12;
      signals.push('D07');
      debug.push({id:'D07', delta:-0.12, note:`coverage ${(cov*100).toFixed(0)}%`});

    if(segNorm.length && lexHits === 0){
      // Strong negative: no produced segment matches the IPA lexicon
      score -= 0.30;
      score = Math.min(score, 0.20);
      signals.push('D12');
      debug.push({id:'D12', delta:'cap<=0.20 and -0.30', note:'zero lexicon unit matches'});
    }
    }

    // Token lists
    const isParticle = lists.particles.has(tokenNorm);
    const isAmbig = lists.ambiguous.has(tokenNorm);

    if(isParticle){
      // Medium-high base for particles
      score = Math.max(score, 0.70);
      score += 0.02;
      signals.push('D08');
      debug.push({id:'D08', delta:'floor to 0.70', note:'particle token (medium-high)'});
    }

    if(isAmbig){
      // Start lower for ambiguous tokens, but do not block strong Māori evidence
      score = Math.min(score, 0.55);
      score -= 0.06;
      signals.push('D09');
      debug.push({id:'D09', delta:'cap to 0.55 then -0.06', note:'ambiguous token'});
    }

    if(hardBlock){
      score = 0.0;
    }

    score = clamp01(score);

    return {
      base: score,
      signals: uniquePreserveOrder(signals),
      debug,
      segments: segs,
      ruleIds: segOut.ruleIds || [],
      coverage: cov,
      orphans,
      hardBlock
    };
  }

  function applyContextBoost(tokens, lists){
    // tokens: array with {norm, base, score, signals, debug, ...}
    const out = tokens.map(t => ({...t, score: t.base, contextDelta:0, contextNotes: [] }));

    const getS = (i) => (i>=0 && i<out.length) ? out[i].score : null;
    const getN = (i) => (i>=0 && i<out.length) ? out[i].norm : '';

    for(let i=0;i<out.length;i++){
      const t = out[i];
      if(t.hardBlock){
        t.contextDelta = 0;
        t.score = clamp01(t.base);
        continue;
      }
      const prev = getS(i-1);
      const next = getS(i+1);

      const isAmbig = lists.ambiguous.has(t.norm);
      const isParticle = lists.particles.has(t.norm);
      const uncertain = t.base >= 0.35 && t.base <= 0.70;

      let delta = 0;

      // Special English pattern penalty: "welcome to"
      if(t.norm === 'to' && getN(i-1) === 'welcome'){
        delta -= 0.18;
        t.contextNotes.push('English pattern: "welcome to"');
      }

      if(isAmbig || isParticle || uncertain){
        const boostFrom = (neighborScore, label) => {
          if(neighborScore == null) return;
          if(neighborScore >= 0.80){ delta += 0.15; t.contextNotes.push(`${label} high (>=0.80)`); }
          else if(neighborScore >= 0.70){ delta += 0.10; t.contextNotes.push(`${label} strong (>=0.70)`); }
          else if(neighborScore >= 0.60){ delta += 0.06; t.contextNotes.push(`${label} moderate (>=0.60)`); }
          else if(neighborScore <= 0.25){ delta -= 0.06; t.contextNotes.push(`${label} very low (<=0.25)`); }
        };

        boostFrom(prev, 'Prev');
        boostFrom(next, 'Next');

        if(prev != null && next != null && prev >= 0.70 && next >= 0.70){
          delta += 0.05;
          t.contextNotes.push('Both sides strong');
        }

        // Special ambiguous rule for "to": if next is very Māori-like, boost more.
        if(t.norm === 'to'){
          if(next != null && next >= 0.75){ delta += 0.08; t.contextNotes.push('Special boost: "to" before high-likelihood token'); }
          if(prev != null && prev <= 0.25){ delta -= 0.05; t.contextNotes.push('Special penalty: "to" after low token'); }
        }

        // Particle reinforcement: te next to a high token becomes more confident
        if(t.norm === 'te'){
          if(next != null && next >= 0.75){ delta += 0.08; t.contextNotes.push('Particle reinforcement: te + high token'); }
          if(prev != null && prev >= 0.75){ delta += 0.06; t.contextNotes.push('Particle reinforcement: high token + te'); }
        }

        // Clamp delta magnitude
        delta = Math.max(-0.22, Math.min(0.25, delta));

        if(delta != 0){
          t.signals = uniquePreserveOrder([...(t.signals||[]), 'D10']);
        }
      }

      t.contextDelta = delta;
      t.score = clamp01(t.base + delta);
    }

    return out;
  }


  function applyZeroNeighborPropagation(tokens, lists){
    // Applies only in the Te Reo Detect tab.
    // If a token is a hard reject (0%), adjacent ambiguous or very short tokens are also treated as 0%.
    const out = tokens.map(t => ({...t, signals: (t.signals||[]).slice(), contextNotes: (t.contextNotes||[]).slice() }));
    const isZero = (t) => (t && (t.hardBlock || t.score === 0));

    for(let i=0;i<out.length;i++){
      if(!isZero(out[i])) continue;
      for(const j of [i-1, i+1]){
        if(j < 0 || j >= out.length) continue;
        const n = out[j];
        if(!n || n.hardBlock) continue;
        const norm = String(n.norm||'');
        const isAmbig = lists.ambiguous.has(norm);
        const isShort = norm.length <= 2;
        if(isAmbig || isShort){
          n.score = 0.0;
          n.contextDelta = -Math.max(0, n.base || 0);
          n.contextNotes.push('Zero neighbor propagation');
          n.signals = uniquePreserveOrder([...(n.signals||[]), 'D13']);
        }
      }
    }

    return out;
  }

  function scoreToLabel(score){
    if(score >= 0.75) return {label:'Likely Te Reo', cls:'good'};
    if(score >= 0.55) return {label:'Mixed or Ambiguous', cls:'warn'};
    return {label:'Unlikely Te Reo', cls:'bad'};
  }

  function renderSignalPills(signalIds, onClick){
    const ids = uniquePreserveOrder(signalIds || []);
    const wrap = el('div', {class:'row'});
    if(!ids.length){
      wrap.appendChild(el('span', {class:'tag warn'}, ['no signals']));
      return wrap;
    }
    for(const id of ids){
      const s = DET_SIGNAL_BY_ID.get(id);
      const b = el('button', {type:'button', class:'tag', title: s ? s.title : id, onclick: ()=> onClick(id)}, [id]);
      wrap.appendChild(b);
    }
    return wrap;
  }

  
  function renderIpaLookupKeyboard(){
    const root = document.getElementById('pageIpaLookupKeyboard');
    root.innerHTML = '';

    const PREF_KEY = 'ipa_lookup_keyboard_prefs_v1';
    const prefs = safeJsonParse(localStorage.getItem(PREF_KEY) || '{}').value || {};

    let dictLoaded = false;
    let dictEntries = 0;
    let wordToIpas = new Map();     // wordKey -> Set(ipa)
    let ipaToWords = new Map();     // ipa -> Set(wordKey)
    let dictName = prefs.dictName || '';

    function savePrefs(extra = {}){
      const next = Object.assign({}, prefs, extra);
      localStorage.setItem(PREF_KEY, JSON.stringify(next));
    }

    function setStatus(node, text, kind){
      node.textContent = text;
      node.className = 'tag';
      if(kind === 'ok') node.classList.add('good');
      if(kind === 'warn') node.classList.add('bad');
    }

    function normalizeWordKey(s){
      return String(s || '').trim().toLowerCase();
    }

    function readFileAsText(file){
      return new Promise((resolve, reject)=>{
        const r = new FileReader();
        r.onload = ()=> resolve(String(r.result || ''));
        r.onerror = ()=> reject(r.error || new Error('File read failed'));
        r.readAsText(file);
      });
    }

    function resetDict(){
      dictLoaded = false;
      dictEntries = 0;
      wordToIpas = new Map();
      ipaToWords = new Map();
    }

    function parseDictText(text){
      resetDict();
      const lines = String(text || '').split(/\r?\n/g);
      for(const raw of lines){
        const line = raw.trim();
        if(!line) continue;
        if(line.startsWith(';;;')) continue;
        if(line.startsWith('#')) continue;

        // cmudict-ipa style: WORD  IPA...
        // allow tabs or multiple spaces
        const parts = line.split(/\s+/g);
        if(parts.length < 2) continue;

        const w = parts[0].replace(/\(\d+\)$/g, '');
        const ipa = parts.slice(1).join(' ').trim();
        if(!w || !ipa) continue;

        const key = normalizeWordKey(w);
        if(!wordToIpas.has(key)) wordToIpas.set(key, new Set());
        wordToIpas.get(key).add(ipa);

        if(!ipaToWords.has(ipa)) ipaToWords.set(ipa, new Set());
        ipaToWords.get(ipa).add(key);

        dictEntries++;
      }
      dictLoaded = dictEntries > 0;
      return { ok: dictLoaded, entries: dictEntries };
    }

    async function tryAutoFetch(statusNode, metaNode){
      setStatus(statusNode, 'Trying to auto-load cmudict-0.7b-ipa.txt from the same folder...', 'warn');
      metaNode.textContent = '';
      try{
        const res = await fetch('cmudict-0.7b-ipa.txt', { cache: 'no-store' });
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const r = parseDictText(text);
        dictName = 'cmudict-0.7b-ipa.txt';
        savePrefs({ dictName });
        setStatus(statusNode, `Dictionary loaded (${r.entries.toLocaleString()} entries).`, 'ok');
        metaNode.textContent = 'Source: auto-load from same folder';
        rerunSearches();
      }catch(err){
        console.warn(err);
        setStatus(statusNode, 'Auto-load failed. Use the file picker or drag and drop a dictionary TXT.', 'warn');
      }
    }

    function rerunSearches(){
      doWordSearch();
      doIpaSearch();
    }

    // Layout
    const topCard = el('div', {class:'card'});
    topCard.appendChild(el('h2', {}, ['IPA Lookup And Keyboard']));
    topCard.appendChild(el('p', {style:'margin-top:6px;'}, [
      'Load a dictionary (cmudict IPA format works well) then search words or IPA and use the symbol keyboard to build IPA. You can insert into the scratchpad, the active field, or the G2P - AWS TTS fields.'
    ]));
    root.appendChild(topCard);

    const dictCard = el('div', {class:'card'});
    dictCard.appendChild(el('h2', {}, ['Dictionary']));
    const dictStatus = el('div', {class:'tag', style:'margin-top:8px;'}, ['Dictionary not loaded']);
    const dictMeta = el('div', {class:'muted', style:'margin-top:6px;'}, [dictName ? `Last: ${dictName}` : 'Tip: place cmudict-0.7b-ipa.txt next to this HTML for auto-load.']);
    const dictRow = el('div', {class:'row', style:'margin-top:10px;'});
    const dictFile = el('input', {type:'file', accept:'.txt'});
    const btnAuto = el('button', {class:'btn', type:'button'}, ['Try Auto Load']);
    const btnClear = el('button', {class:'btn', type:'button'}, ['Clear Dictionary']);
    dictRow.appendChild(dictFile);
    dictRow.appendChild(btnAuto);
    dictRow.appendChild(btnClear);

    const dropZone = el('div', {style:'margin-top:10px; padding:12px; border:1px dashed var(--border); border-radius:12px; background:rgba(18,22,27,.35);'}, [
      el('div', {class:'muted'}, ['Drag and drop a dictionary TXT file here'])
    ]);

    dictCard.appendChild(dictStatus);
    dictCard.appendChild(dictMeta);
    dictCard.appendChild(dictRow);
    dictCard.appendChild(dropZone);
    root.appendChild(dictCard);

    btnAuto.onclick = ()=> tryAutoFetch(dictStatus, dictMeta);
    btnClear.onclick = ()=>{
      resetDict();
      setStatus(dictStatus, 'Dictionary cleared.', 'warn');
      dictMeta.textContent = '';
      rerunSearches();
    };

    async function loadDictFile(file){
      if(!file) return;
      try{
        const text = await readFileAsText(file);
        const r = parseDictText(text);
        dictName = file.name || 'dictionary.txt';
        savePrefs({ dictName });
        setStatus(dictStatus, `Dictionary loaded (${r.entries.toLocaleString()} entries).`, 'ok');
        dictMeta.textContent = `Source: ${dictName}`;
        rerunSearches();
      }catch(err){
        console.error(err);
        setStatus(dictStatus, 'Failed to read the selected file.', 'warn');
      }
    }

    dictFile.addEventListener('change', ()=> loadDictFile(dictFile.files && dictFile.files[0]));
    dropZone.addEventListener('dragover', (e)=>{ e.preventDefault(); dropZone.style.background = 'rgba(18,22,27,.55)'; });
    dropZone.addEventListener('dragleave', ()=>{ dropZone.style.background = 'rgba(18,22,27,.35)'; });
    dropZone.addEventListener('drop', (e)=>{
      e.preventDefault();
      dropZone.style.background = 'rgba(18,22,27,.35)';
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(f) loadDictFile(f);
    });

    // Insert target and scratchpad
    const kbCard = el('div', {class:'card'});
    kbCard.appendChild(el('h2', {}, ['Keyboard']));
    const scratch = el('textarea', {id:'ipaScratchpad', class:'mono', rows:'4', placeholder:'Build IPA here then copy or insert into other fields'});
    scratch.value = prefs.scratch || '';

    const insertRow = el('div', {class:'row', style:'margin-top:10px;'});
    const insertTarget = el('select', {class:'btn', title:'Insert target'});
    insertTarget.style.padding = '8px 10px';
    insertTarget.style.borderRadius = '10px';
    insertTarget.style.background = 'rgba(18,22,27,.85)';
    insertTarget.style.border = '1px solid var(--border)';
    insertTarget.style.color = 'var(--text)';

    const targets = [
      {v:'scratch', t:'Target: Scratchpad'},
      {v:'active', t:'Target: Active Field'},
      {v:'awsInput', t:'Target: AWS TTS Input'},
      {v:'awsSsml', t:'Target: SSML Output'}
    ];
    for(const t of targets){
      const o = el('option', {value:t.v}, [t.t]);
      if(t.v === (prefs.insertTarget || 'scratch')) o.selected = true;
      insertTarget.appendChild(o);
    }

    const activeNote = el('div', {class:'tag', style:'align-self:center; opacity:.9;'}, ['Active Field: none']);
    insertRow.appendChild(insertTarget);
    insertRow.appendChild(activeNote);

    function refreshActiveNote(){
      const elx = APP_SHARED.lastFocused;
      if(!elx) { activeNote.textContent = 'Active Field: none'; return; }
      const tag = (elx.tagName || '').toLowerCase();
      const id = elx.id ? `#${elx.id}` : '';
      activeNote.textContent = `Active Field: ${tag}${id}`;
    }
    refreshActiveNote();
    APP_SHARED.onFocus = refreshActiveNote;

    function getTargetEl(){
      const v = insertTarget.value;
      if(v === 'scratch') return scratch;
      if(v === 'awsInput') return APP_SHARED.awsTtsInputEl || null;
      if(v === 'awsSsml') return APP_SHARED.awsTtsSsmlEl || null;
      return APP_SHARED.lastFocused || null;
    }

    const scratchBtns = el('div', {class:'row', style:'margin-top:10px;'});
    const btnCopy = el('button', {class:'btn', type:'button'}, ['Copy Scratchpad']);
    const btnClearScratch = el('button', {class:'btn', type:'button'}, ['Clear Scratchpad']);
    const btnInsertPhoneme = el('button', {class:'btn', type:'button'}, ['Insert <phoneme>']);
    scratchBtns.appendChild(btnCopy);
    scratchBtns.appendChild(btnClearScratch);
    scratchBtns.appendChild(btnInsertPhoneme);

    btnCopy.onclick = async ()=>{
      try{ await navigator.clipboard.writeText(scratch.value || ''); }catch(_e){}
    };
    btnClearScratch.onclick = ()=>{
      scratch.value = '';
      savePrefs({ scratch: '' });
    };
    btnInsertPhoneme.onclick = ()=>{
      const t = getTargetEl();
      wrapSelectionText(t, '<phoneme alphabet="ipa" ph="', '"></phoneme>');
    };

    // Symbol list
    const filter = el('input', {type:'text', placeholder:'Filter symbols like stress, long, ə, ŋ'});
    filter.style.marginTop = '10px';
    filter.style.width = '100%';
    filter.style.padding = '10px';
    filter.style.borderRadius = '12px';
    filter.style.border = '1px solid var(--border)';
    filter.style.background = 'rgba(18,22,27,.6)';
    filter.style.color = 'var(--text)';

    const select = el('select', {size:'10', style:'width:100%; margin-top:8px; max-height:260px; overflow:auto;'});
    select.innerHTML = IPA_SYMBOL_OPTIONS_HTML;

    const btnInsertSym = el('button', {class:'btn', type:'button', style:'margin-top:8px;'}, ['Insert Symbol']);
    btnInsertSym.onclick = ()=>{
      const opt = select.options[select.selectedIndex];
      if(!opt) return;
      const symbol = opt.value || opt.textContent.split(' - ')[0];
      insertAtCursorText(getTargetEl(), symbol);
    };

    filter.addEventListener('input', ()=>{
      const q = (filter.value || '').trim().toLowerCase();
      for(const opt of Array.from(select.options)){
        const txt = (opt.textContent || '').toLowerCase();
        opt.hidden = q ? !txt.includes(q) : false;
      }
    });

    scratch.addEventListener('input', ()=> savePrefs({ scratch: scratch.value, insertTarget: insertTarget.value }));
    insertTarget.addEventListener('change', ()=> savePrefs({ insertTarget: insertTarget.value }));

    kbCard.appendChild(insertRow);
    kbCard.appendChild(el('label', {style:'margin-top:10px; display:block;'}, ['Scratchpad']));
    kbCard.appendChild(scratch);
    kbCard.appendChild(scratchBtns);
    kbCard.appendChild(filter);
    kbCard.appendChild(select);
    kbCard.appendChild(btnInsertSym);
    root.appendChild(kbCard);

    // Word lookup
    const wordCard = el('div', {class:'card'});
    wordCard.appendChild(el('h2', {}, ['Word To IPA']));
    const wordRow = el('div', {class:'row'});
    const wordInput = el('input', {type:'text', placeholder:'Enter a word, example: council'});
    wordInput.value = prefs.wordQuery || '';
    wordInput.style.minWidth = '240px';

    const wordMode = el('select', {class:'btn'});
    const wordModes = [
      {v:'starts', t:'Starts With'},
      {v:'contains', t:'Contains'},
      {v:'exact', t:'Exact'},
      {v:'ends', t:'Ends With'}
    ];
    for(const m of wordModes){
      const o = el('option', {value:m.v}, [m.t]);
      if(m.v === (prefs.wordMode || 'starts')) o.selected = true;
      wordMode.appendChild(o);
    }

    const sortSel = el('select', {class:'btn', title:'Sort'});
    const sortOpts = [
      {v:'alpha', t:'Sort: A-Z'},
      {v:'len', t:'Sort: Length'},
      {v:'hits', t:'Sort: Most IPA'}
    ];
    for(const s of sortOpts){
      const o = el('option', {value:s.v}, [s.t]);
      if(s.v === (prefs.wordSort || 'alpha')) o.selected = true;
      sortSel.appendChild(o);
    }

    const limitSel = el('select', {class:'btn', title:'Limit'});
    for(const n of [25,50,100,200,500]){
      const o = el('option', {value:String(n)}, [String(n)]);
      if(String(n) === String(prefs.wordLimit || 100)) o.selected = true;
      limitSel.appendChild(o);
    }

    const btnWord = el('button', {class:'btn primary', type:'button'}, ['Search']);
    wordRow.appendChild(wordInput);
    wordRow.appendChild(wordMode);
    wordRow.appendChild(sortSel);
    wordRow.appendChild(limitSel);
    wordRow.appendChild(btnWord);

    const wordResults = el('div', {style:'margin-top:10px;'});
    wordCard.appendChild(wordRow);
    wordCard.appendChild(wordResults);
    root.appendChild(wordCard);

    function doWordSearch(){
      wordResults.innerHTML = '';
      const q = String(wordInput.value || '').trim().toLowerCase();
      savePrefs({ wordQuery:q, wordMode:wordMode.value, wordLimit:Number(limitSel.value), wordSort:sortSel.value });
      if(!q){
        wordResults.appendChild(el('div', {class:'muted'}, ['Enter a word to search.']));
        return;
      }
      if(!dictLoaded){
        wordResults.appendChild(el('div', {class:'muted'}, ['Dictionary not loaded yet. Load one above first.']));
        return;
      }

      const mode = wordMode.value;
      const limit = Math.max(1, Number(limitSel.value) || 100);
      let matches = [];
      for(const [w, ipas] of wordToIpas.entries()){
        if(mode === 'exact' && w === q) matches.push([w, ipas]);
        else if(mode === 'starts' && w.startsWith(q)) matches.push([w, ipas]);
        else if(mode === 'ends' && w.endsWith(q)) matches.push([w, ipas]);
        else if(mode === 'contains' && w.includes(q)) matches.push([w, ipas]);
      }

      if(sortSel.value === 'alpha'){
        matches.sort((a,b)=> a[0].localeCompare(b[0]));
      }else if(sortSel.value === 'len'){
        matches.sort((a,b)=> a[0].length - b[0].length || a[0].localeCompare(b[0]));
      }else{
        matches.sort((a,b)=> b[1].size - a[1].size || a[0].localeCompare(b[0]));
      }

      matches = matches.slice(0, limit);

      const header = el('div', {class:'muted'}, [`Matches: ${matches.length.toLocaleString()}`]);
      wordResults.appendChild(header);

      for(const [w, ipas] of matches){
        const box = el('div', {style:'margin-top:10px; padding:10px; border:1px solid var(--border); border-radius:12px; background:rgba(0,0,0,.12);'});
        box.appendChild(el('div', {style:'font-weight:700;'}, [w]));
        const grid = el('div', {class:'pillGrid', style:'margin-top:8px;'});
        for(const ipa of Array.from(ipas)){
          const btn = el('button', {class:'tag', type:'button', title:'Insert IPA', onclick:()=>{
            insertAtCursorText(getTargetEl(), ipa);
          }}, [ipa]);
          grid.appendChild(btn);
        }
        box.appendChild(grid);
        wordResults.appendChild(box);
      }
    }

    btnWord.onclick = doWordSearch;
    wordInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); doWordSearch(); } });

    // IPA lookup
    const ipaCard = el('div', {class:'card'});
    ipaCard.appendChild(el('h2', {}, ['IPA To Words']));
    const ipaRow = el('div', {class:'row'});
    const ipaInput = el('input', {type:'text', class:'mono', placeholder:'Enter IPA, example: ˈkæt'});
    ipaInput.value = prefs.ipaQuery || '';
    ipaInput.style.minWidth = '260px';

    const ipaMode = el('select', {class:'btn'});
    const ipaModes = [
      {v:'contains', t:'Contains'},
      {v:'exact', t:'Exact'}
    ];
    for(const m of ipaModes){
      const o = el('option', {value:m.v}, [m.t]);
      if(m.v === (prefs.ipaMode || 'contains')) o.selected = true;
      ipaMode.appendChild(o);
    }

    const ipaLimit = el('select', {class:'btn', title:'Limit'});
    for(const n of [25,50,100,200,500]){
      const o = el('option', {value:String(n)}, [String(n)]);
      if(String(n) === String(prefs.ipaLimit || 100)) o.selected = true;
      ipaLimit.appendChild(o);
    }

    const btnIpa = el('button', {class:'btn primary', type:'button'}, ['Search']);
    ipaRow.appendChild(ipaInput);
    ipaRow.appendChild(ipaMode);
    ipaRow.appendChild(ipaLimit);
    ipaRow.appendChild(btnIpa);

    const ipaResults = el('div', {style:'margin-top:10px;'});
    ipaCard.appendChild(ipaRow);
    ipaCard.appendChild(ipaResults);
    root.appendChild(ipaCard);

    function doIpaSearch(){
      ipaResults.innerHTML = '';
      const q = String(ipaInput.value || '').trim();
      savePrefs({ ipaQuery:q, ipaMode:ipaMode.value, ipaLimit:Number(ipaLimit.value) });
      if(!q){
        ipaResults.appendChild(el('div', {class:'muted'}, ['Enter IPA to search.']));
        return;
      }
      if(!dictLoaded){
        ipaResults.appendChild(el('div', {class:'muted'}, ['Dictionary not loaded yet. Load one above first.']));
        return;
      }

      const mode = ipaMode.value;
      const limit = Math.max(1, Number(ipaLimit.value) || 100);

      let matches = [];
      for(const [ipa, words] of ipaToWords.entries()){
        if(mode === 'exact' && ipa === q) matches.push([ipa, words]);
        else if(mode === 'contains' && ipa.includes(q)) matches.push([ipa, words]);
      }

      matches.sort((a,b)=> b[1].size - a[1].size || a[0].localeCompare(b[0]));
      matches = matches.slice(0, limit);

      ipaResults.appendChild(el('div', {class:'muted'}, [`Matches: ${matches.length.toLocaleString()}`]));

      for(const [ipa, words] of matches){
        const box = el('div', {style:'margin-top:10px; padding:10px; border:1px solid var(--border); border-radius:12px; background:rgba(0,0,0,.12);'});
        const top = el('div', {style:'display:flex; gap:10px; align-items:center; flex-wrap:wrap;'});
        top.appendChild(el('div', {class:'mono', style:'font-weight:700;'}, [ipa]));
        top.appendChild(el('button', {class:'tag', type:'button', onclick:()=> insertAtCursorText(getTargetEl(), ipa)}, ['Insert IPA']));
        box.appendChild(top);

        const grid = el('div', {class:'pillGrid', style:'margin-top:8px;'});
        const list = Array.from(words).sort((a,b)=> a.localeCompare(b));
        for(const w of list.slice(0, 50)){
          const btn = el('button', {class:'tag', type:'button', title:'Insert word', onclick:()=> insertAtCursorText(getTargetEl(), w)}, [w]);
          grid.appendChild(btn);
        }
        box.appendChild(grid);

        ipaResults.appendChild(box);
      }
    }

    btnIpa.onclick = doIpaSearch;
    ipaInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); doIpaSearch(); } });

    // Remember: AWS output/input nodes may not exist until user opens that tab at least once
    // Auto-run if dictionary was previously loaded via auto-load
    if(prefs.autoLoadOnOpen && !dictLoaded){
      tryAutoFetch(dictStatus, dictMeta);
    }
  }


  function renderDetect(){
    const root = document.getElementById('pageDetect');
    root.innerHTML = '';

    const prefs = loadDetectPrefs();

    // Lists
    const ambiguous = loadTokenList(STORAGE_KEYS.detectAmbiguous, defaultAmbiguousTokens);
    const particles = loadTokenList(STORAGE_KEYS.detectParticles, defaultParticleTokens);

    const lists = {
      ambiguousArr: ambiguous,
      particlesArr: particles,
      ambiguous: new Set(ambiguous),
      particles: new Set(particles)
    };

    // Header
    const card = el('div', {class:'card'});
    card.appendChild(el('h2', {}, ['Te Reo Detect']));
    card.appendChild(el('p', {}, ['Estimate whether tokens are likely te reo Māori using v12 segmentation, phonotactic signals and G2P lexicon coverage. Ambiguous tokens are adjusted by nearby context.']));

    const input = el('input', {type:'text', placeholder:'e.g. welcome to tepu | to tepu | te patukurea', value:''});
    const runBtn = el('button', {class:'btn primary', type:'button'}, ['Analyze']);

    const debugCheck = el('label', {class:'checkbox'});
    const debugInput = el('input', {type:'checkbox'});
    debugInput.checked = !!prefs.showDebug;
    debugCheck.appendChild(debugInput);
    debugCheck.appendChild(document.createTextNode('Show Debug'));

    debugInput.addEventListener('change', ()=>{
      prefs.showDebug = !!debugInput.checked;
      saveDetectPrefs(prefs);
      // rerender output only if exists
      runBtn.click();
    });

    const controlRow = el('div', {class:'row'});
    controlRow.appendChild(el('div', {style:'flex:1; min-width:260px;'}, [input]));
    const btnWrap = el('div', {style:'display:flex; gap:8px; flex-wrap:wrap;'});
    btnWrap.appendChild(runBtn);
    btnWrap.appendChild(debugCheck);
    controlRow.appendChild(btnWrap);
    card.appendChild(controlRow);

    const outWrap = el('div', {class:'stack', id:'detectOut', style:'margin-top:12px;'});
    card.appendChild(outWrap);

    root.appendChild(card);

    // Token list editors
    const listsCard = el('div', {class:'card'});
    listsCard.appendChild(el('h3', {}, ['Token Lists (Editable)']));
    listsCard.appendChild(el('p', {}, ['Edit the ambiguous and particle tokens without touching code. Use commas or new lines. These lists are saved to localStorage.']));

    const edWrap = el('div', {class:'listEditor'});
    const ambArea = el('textarea', {spellcheck:'false'});
    ambArea.value = ambiguous.join(', ');
    const partArea = el('textarea', {spellcheck:'false'});
    partArea.value = particles.join(', ');

    const ambBox = el('div', {class:'card', style:'padding:12px; margin:0;'});
    ambBox.appendChild(el('h3', {}, ['Ambiguous Tokens']));
    ambBox.appendChild(el('p', {class:'muted'}, ['Example: to, he, me']));
    ambBox.appendChild(ambArea);

    const partBox = el('div', {class:'card', style:'padding:12px; margin:0;'});
    partBox.appendChild(el('h3', {}, ['Particle Tokens']));
    partBox.appendChild(el('p', {class:'muted'}, ['Particles start medium-high (te is medium-high) then context adjusts.']));
    partBox.appendChild(partArea);

    edWrap.appendChild(ambBox);
    edWrap.appendChild(partBox);

    const listBtnRow = el('div', {class:'row', style:'margin-top:10px;'});
    const btnApply = el('button', {class:'btn primary', type:'button'}, ['Apply Lists']);
    const btnReset = el('button', {class:'btn', type:'button'}, ['Reset Defaults']);

    btnApply.addEventListener('click', ()=>{
      const amb = parseTokenList(ambArea.value);
      const par = parseTokenList(partArea.value);
      saveTokenList(STORAGE_KEYS.detectAmbiguous, amb);
      saveTokenList(STORAGE_KEYS.detectParticles, par);
      // re-render detect to load new sets
      renderDetect();
      setActiveTab('detect');
    });

    btnReset.addEventListener('click', ()=>{
      saveTokenList(STORAGE_KEYS.detectAmbiguous, defaultAmbiguousTokens());
      saveTokenList(STORAGE_KEYS.detectParticles, defaultParticleTokens());
      renderDetect();
      setActiveTab('detect');
    });

    listBtnRow.appendChild(btnApply);
    listBtnRow.appendChild(btnReset);
    listsCard.appendChild(edWrap);
    listsCard.appendChild(listBtnRow);

    root.appendChild(listsCard);

    // Signals browser
    const sigCard = el('div', {class:'card'});
    sigCard.appendChild(el('h3', {}, ['Detect Signals']));
    sigCard.appendChild(el('p', {}, ['Click a signal pill to view its explanation. Tokens in the analysis include signal pills that explain why the score moved.']));

    const layout = el('div', {class:'signalLayout'});
    const left = el('div', {class:'card', style:'padding:12px; margin:0;'});
    const right = el('div', {class:'card', style:'padding:12px; margin:0;', id:'detectSignalDetails'});

    const pillGrid = el('div', {class:'pillGrid'});
    for(const s of DETECTION_SIGNALS){
      pillGrid.appendChild(el('button', {type:'button', class:'tag', title:s.title, onclick:()=>{ drawSignalDetails(s.id); }}, [s.id]));
    }
    left.appendChild(pillGrid);

    function drawSignalDetails(id){
      right.innerHTML = '';
      const s = DET_SIGNAL_BY_ID.get(id);
      if(!s){
        right.appendChild(el('h3', {}, ['Signal Details']));
        right.appendChild(el('p', {}, ['Select a signal to view details.']));
        return;
      }
      right.appendChild(el('h3', {}, ['Signal Details']));
      right.appendChild(el('div', {class:'row'}, [
        el('span', {class:'tag'}, [s.id]),
        el('span', {class:'tag'}, [`category: ${s.cat}`]),
        el('span', {class:'tag'}, [s.title])
      ]));
      right.appendChild(el('div', {class:'divider'}));
      right.appendChild(el('h3', {}, ['Explanation']));
      right.appendChild(el('pre', {}, [s.desc]));
    }

    drawSignalDetails('D01');

    layout.appendChild(left);
    layout.appendChild(right);
    sigCard.appendChild(layout);
    root.appendChild(sigCard);

    // History
    const histCard = el('div', {class:'card'});
    histCard.appendChild(el('h3', {}, ['Detect History']));

    const btnRow = el('div', {class:'row'});
    btnRow.appendChild(el('button', {class:'btn', type:'button', onclick:()=>{ saveDetectHistory([]); drawHistory(); }}, ['Clear History']));
    btnRow.appendChild(el('button', {class:'btn', type:'button', onclick:()=>{ downloadText('segmenter_v12_detect_history.json', JSON.stringify(loadDetectHistory(), null, 2), 'application/json'); }}, ['Export History']));

    const btnImport = el('button', {class:'btn', type:'button'}, ['Import History']);
    btnImport.addEventListener('click', async ()=>{
      const txt = prompt('Paste Detect History JSON');
      if(!txt) return;
      const parsed = safeJsonParse(txt);
      if(!parsed.ok || !Array.isArray(parsed.value)){
        alert('Invalid JSON');
        return;
      }
      saveDetectHistory(parsed.value);
      drawHistory();
    });

    btnRow.appendChild(btnImport);
    histCard.appendChild(btnRow);

    const histWrap = el('div', {id:'detectHistoryWrap'});
    histCard.appendChild(histWrap);
    root.appendChild(histCard);

    function drawHistory(){
      histWrap.innerHTML = '';
      const items = loadDetectHistory();
      if(!items.length){
        histWrap.appendChild(el('p', {class:'muted'}, ['No history yet. Run an analysis to save entries here.']));
        return;
      }

      for(const item of items){
        const c = el('div', {class:'card', style:'margin:10px 0; padding:12px;'});
        c.appendChild(el('div', {class:'row'}, [
          el('span', {class:'tag'}, [new Date(item.createdAt || Date.now()).toLocaleString()]),
          el('span', {class:'tag'}, [`tokens: ${(item.tokens||[]).length}`]),
          el('span', {class:'tag'}, [`sentence: ${(item.sentenceScore*100).toFixed(0)}%`])
        ]));
        c.appendChild(el('h3', {}, [item.input || '']));

        const table = el('table', {class:'tokenTable'});
        table.appendChild(el('thead', {}, [
          el('tr', {}, [
            el('th', {}, ['Token']),
            el('th', {}, ['Score']),
            el('th', {}, ['Segments']),
            el('th', {}, ['Signals'])
          ])
        ]));
        const tb = el('tbody');
        for(const t of (item.tokens||[])){
          const lab = scoreToLabel(t.score);
          const scoreP = el('span', {class:'scorePill'}, [
            el('span', {class:`scoreDot ${lab.cls}`}),
            `${(t.score*100).toFixed(0)}%`,
            `(${lab.label})`
          ]);

          const segText = (t.segments||[]).length ? segmentsToString(t.segments) : '';
          const segCell = el('div', {}, [segText || '']);

          const sigCell = el('div');
          sigCell.appendChild(renderSignalPills(t.signals || [], (id)=>{ drawSignalDetails(id); setActiveTab('detect'); }));

          const tr = el('tr');
          tr.appendChild(el('td', {}, [t.raw || t.norm || '']));
          tr.appendChild(el('td', {}, [scoreP]));
          tr.appendChild(el('td', {}, [segCell]));
          tr.appendChild(el('td', {}, [sigCell]));
          tb.appendChild(tr);
        }
        table.appendChild(tb);
        c.appendChild(table);
        histWrap.appendChild(c);
      }
    }

    drawHistory();

    function renderAnalysis(){
      outWrap.innerHTML = '';

      const text = input.value;
      const tokensRaw = tokenizeText(text);
      if(!tokensRaw.length){
        outWrap.appendChild(el('p', {class:'muted'}, ['Enter text to analyze.']));
        return;
      }

      const baseTokens = [];
      for(const tk of tokensRaw){
        const norm = normalizeWord(tk.raw);
        const base = scoreTokenBase(norm, lists);
        baseTokens.push({ raw: tk.raw, norm, base: base.base, signals: base.signals, debug: base.debug, segments: base.segments, ruleIds: base.ruleIds, coverage: base.coverage, orphans: base.orphans });
      }

      const scored0 = applyContextBoost(baseTokens, lists);
      const isMultiPartMaori = tokensRaw.length > 1 && scored0.every(t => !t.hardBlock);
      const scored = (!isMultiPartMaori) ? applyZeroNeighborPropagation(scored0, lists) : scored0;

      // Sentence score (length weighted)
      let sum = 0.0; let wsum = 0.0;
      for(const t of scored){
        const w = Math.max(1, (t.norm||'').length);
        sum += t.score * w;
        wsum += w;
      }
      const sentenceScore = wsum ? (sum / wsum) : 0;

      const sentLab = scoreToLabel(sentenceScore);
      const headerRow = el('div', {class:'row'});
      headerRow.appendChild(el('span', {class:`tag ${sentLab.cls}`}, [`Sentence Likelihood: ${(sentenceScore*100).toFixed(0)}%` ]));
      headerRow.appendChild(el('span', {class:'tag'}, [`tokens: ${scored.length}`]));
      outWrap.appendChild(headerRow);

      const table = el('table', {class:'tokenTable'});
      table.appendChild(el('thead', {}, [
        el('tr', {}, [
          el('th', {}, ['Token']),
          el('th', {}, ['Score']),
          el('th', {}, ['Segments And Coverage']),
          el('th', {}, ['Signals And Rules'])
        ])
      ]));
      const tbody = el('tbody');

      for(const t of scored){
        const lab = scoreToLabel(t.score);
        const scoreP = el('span', {class:'scorePill'}, [
          el('span', {class:`scoreDot ${lab.cls}`}),
          `${(t.score*100).toFixed(0)}%`,
          `(${lab.label})`
        ]);

        const segs = t.segments || [];
        const cov = typeof t.coverage === 'number' ? t.coverage : 0;
        const segCell = el('div');
        segCell.appendChild(el('div', {}, [segs.length ? segmentsToString(segs) : '']));
        segCell.appendChild(el('div', {class:'row', style:'margin-top:6px;'}, [
          el('span', {class:'tag'}, [`coverage: ${(cov*100).toFixed(0)}%`]),
          el('span', {class:'tag'}, [`orphans: ${t.orphans||0}`])
        ]));

        const sigCell = el('div');
        sigCell.appendChild(renderSignalPills(t.signals || [], (id)=>{ drawSignalDetails(id); }));
        sigCell.appendChild(el('div', {class:'divider'}));
        sigCell.appendChild(el('div', {class:'muted'}, ['Segmenter rules used:']));
        sigCell.appendChild(renderRulePills(t.ruleIds || [], {max: 10}));

        if(prefs.showDebug){
          const details = el('details', {class:'tokenDetails'});
          details.appendChild(el('summary', {}, ['Debug breakdown']));
          details.appendChild(el('pre', {}, [JSON.stringify({ base: t.base, contextDelta: t.contextDelta, contextNotes: t.contextNotes, debug: t.debug }, null, 2)]));
          sigCell.appendChild(details);
        }

        const tr = el('tr');
        tr.appendChild(el('td', {}, [t.raw]));
        tr.appendChild(el('td', {}, [scoreP]));
        tr.appendChild(el('td', {}, [segCell]));
        tr.appendChild(el('td', {}, [sigCell]));
        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      outWrap.appendChild(table);

      const btnSave = el('button', {class:'btn', type:'button'}, ['Save To Detect History']);
      btnSave.addEventListener('click', ()=>{
        addDetectHistoryEntry({
          createdAt: new Date().toISOString(),
          input: text,
          sentenceScore,
          tokens: scored.map(t => ({ raw: t.raw, norm: t.norm, score: t.score, base: t.base, contextDelta: t.contextDelta, contextNotes: t.contextNotes, segments: t.segments, coverage: t.coverage, orphans: t.orphans, signals: t.signals, ruleIds: t.ruleIds }))
        });
        drawHistory();
      });

      outWrap.appendChild(el('div', {class:'row', style:'margin-top:10px;'}, [btnSave]));
    }

    runBtn.addEventListener('click', renderAnalysis);

    // Seed examples
    input.value = 'to tepu';
    renderAnalysis();
  }
  

  function tokenizeTextBlockParts(input){
    const s = String(input || '');
    if(!s) return [];
    const reWord = /([A-Za-zĀĒĪŌŪāēīōū]+(?:['’][A-Za-zĀĒĪŌŪāēīōū]+)*)/g;
    const parts = [];
    let last = 0;
    for(;;){
      const m = reWord.exec(s);
      if(!m) break;
      const i = m.index;
      if(i > last) parts.push({ type:'sep', text: s.slice(last, i) });
      parts.push({ type:'word', raw: m[1] });
      last = reWord.lastIndex;
    }
    if(last < s.length) parts.push({ type:'sep', text: s.slice(last) });
    return parts;
  }

  function isHardBoundary(sepText){
    if(!sepText) return false;
    return /[\n\r]|[.!?]/.test(sepText);
  }

  function applyContextBoostBounded(tokens, lists, boundaryAfter){
    const out = tokens.map(t => ({...t, score: t.base, contextDelta:0, contextNotes: [] }));

    const prevScore = (i) => {
      if(i-1 < 0) return null;
      if(boundaryAfter && boundaryAfter[i-1]) return null;
      return out[i-1].score;
    };
    const nextScore = (i) => {
      if(i+1 >= out.length) return null;
      if(boundaryAfter && boundaryAfter[i]) return null;
      return out[i+1].score;
    };
    const prevNorm = (i) => {
      if(i-1 < 0) return '';
      if(boundaryAfter && boundaryAfter[i-1]) return '';
      return out[i-1].norm || '';
    };

    for(let i=0;i<out.length;i++){
      const t = out[i];
      if(t.hardBlock){
        t.contextDelta = 0;
        t.score = clamp01(t.base);
        continue;
      }

      const prev = prevScore(i);
      const next = nextScore(i);
      const prevN = prevNorm(i);

      const isAmbig = lists.ambiguous.has(t.norm);
      const isParticle = lists.particles.has(t.norm);
      const uncertain = t.base >= 0.35 && t.base <= 0.70;

      let delta = 0;

      if(t.norm === 'to' && prevN === 'welcome'){
        delta -= 0.18;
        t.contextNotes.push('English pattern: "welcome to"');
      }

      if(isAmbig || isParticle || uncertain){
        const boostFrom = (neighborScore, label) => {
          if(neighborScore == null) return;
          if(neighborScore >= 0.80){ delta += 0.15; t.contextNotes.push(label + ' high (>=0.80)'); }
          else if(neighborScore >= 0.70){ delta += 0.10; t.contextNotes.push(label + ' strong (>=0.70)'); }
          else if(neighborScore >= 0.60){ delta += 0.06; t.contextNotes.push(label + ' moderate (>=0.60)'); }
          else if(neighborScore <= 0.25){ delta -= 0.06; t.contextNotes.push(label + ' very low (<=0.25)'); }
        };

        boostFrom(prev, 'Prev');
        boostFrom(next, 'Next');

        if(prev != null && next != null && prev >= 0.70 && next >= 0.70){
          delta += 0.05;
          t.contextNotes.push('Both sides strong');
        }

        if(t.norm === 'to'){
          if(next != null && next >= 0.75){ delta += 0.08; t.contextNotes.push('Special boost: "to" before high-likelihood token'); }
          if(prev != null && prev <= 0.25){ delta -= 0.05; t.contextNotes.push('Special penalty: "to" after low token'); }
        }

        if(t.norm === 'te'){
          if(next != null && next >= 0.75){ delta += 0.08; t.contextNotes.push('Particle reinforcement: te + high token'); }
          if(prev != null && prev >= 0.75){ delta += 0.06; t.contextNotes.push('Particle reinforcement: high token + te'); }
        }

        delta = Math.max(-0.22, Math.min(0.25, delta));

        if(delta != 0){
          t.signals = uniquePreserveOrder([...(t.signals||[]), 'D10']);
        }
      }

      t.contextDelta = delta;
      t.score = clamp01(t.base + delta);
    }

    return out;
  }

  function renderDetectBlock(){
    const root = document.getElementById('pageDetectBlock');
    root.innerHTML = '';

    const prefs = loadDetectPrefs();

    const ambiguous = loadTokenList(STORAGE_KEYS.detectAmbiguous, defaultAmbiguousTokens);
    const particles = loadTokenList(STORAGE_KEYS.detectParticles, defaultParticleTokens);

    const lists = {
      ambiguousArr: ambiguous,
      particlesArr: particles,
      ambiguous: new Set(ambiguous),
      particles: new Set(particles)
    };

    const card = el('div', {class:'card'});
    card.appendChild(el('h2', {}, ['Te Reo Detect Text Block']));
    card.appendChild(el('p', {}, ['Detect likely te reo Māori words and multi-token blocks inside a mixed passage. This mode uses neighbor context for scoring, but it does not apply the 0% neighbor rule. Click any highlighted word to inspect details.']));

    const area = el('textarea', {spellcheck:'false', style:'min-height:140px;'});
    area.value = loadFromStorage('rr_detect_block_text') || 'Welcome to Kerikeri. Haere mai ki te tepu, e hoa. This is mixed text with te reo.';

    const runBtn = el('button', {class:'btn primary', type:'button'}, ['Analyze Block']);

    const thrLabel = el('span', {class:'tag'}, ['Block threshold: 75%']);
    const thr = el('input', {type:'range', min:'0.50', max:'0.90', step:'0.01', value:String((loadG2pAwsTtsPrefs().autoDetectThreshold != null ? loadG2pAwsTtsPrefs().autoDetectThreshold : 0.75)), style:'width:220px;'});
    thr.addEventListener('input', ()=>{ thrLabel.textContent = 'Block threshold: ' + Math.round(parseFloat(thr.value)*100) + '%'; });

    const debugCheck = el('label', {class:'checkbox'});
    const debugInput = el('input', {type:'checkbox'});
    debugInput.checked = !!prefs.showDebugBlock;
    debugCheck.appendChild(debugInput);
    debugCheck.appendChild(document.createTextNode('Show Debug'));

    const topRow = el('div', {class:'row'});
    topRow.appendChild(runBtn);
    topRow.appendChild(thrLabel);
    topRow.appendChild(thr);
    topRow.appendChild(debugCheck);

    card.appendChild(area);
    card.appendChild(topRow);

    const layout = el('div', {class:'detectBlockLayout'});
    const left = el('div', {class:'card', style:'margin:0; padding:12px;'});
    const right = el('div', {class:'card', style:'margin:0; padding:12px;'});

    left.appendChild(el('h3', {}, ['Highlighted Text']));
    const hl = el('div', {class:'hlText', id:'detectBlockHL'});
    left.appendChild(hl);

    left.appendChild(el('div', {class:'divider'}));
    left.appendChild(el('h3', {}, ['Detected Blocks']));
    const blocksWrap = el('div', {id:'detectBlockBlocks'});
    left.appendChild(blocksWrap);

    right.appendChild(el('h3', {}, ['Word Details']));
    const details = el('div', {id:'detectBlockDetails'});
    right.appendChild(details);

    layout.appendChild(left);
    layout.appendChild(right);

    root.appendChild(card);
    root.appendChild(layout);

    // History card
    const historyCard = el('div', {class:'card', style:'margin-top:12px;'});
    historyCard.appendChild(el('h2', {}, ['Detect Block History']));
    historyCard.appendChild(el('p', {}, ['Most recent first. Click an entry to load the text back into the analyzer.']));

    const hControls = el('div', {class:'row'});
    const hClear = el('button', {class:'btn', type:'button'}, ['Clear History']);
    const hExport = el('button', {class:'btn', type:'button'}, ['Export History']);
    const hImport = el('button', {class:'btn', type:'button'}, ['Import History']);
    const hFile = el('input', {type:'file', accept:'application/json', class:'hidden'});

    hClear.addEventListener('click', ()=>{ saveDetectBlockHistory([]); drawBlockHistory(); });
    hExport.addEventListener('click', ()=>{
      const data = loadDetectBlockHistory();
      downloadText('detect_text_block_history.json', JSON.stringify(data, null, 2), 'application/json');
    });
    hImport.addEventListener('click', ()=> hFile.click());
    hFile.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const txt = await f.text();
      const parsed = safeJsonParse(txt);
      if(!parsed.ok || !Array.isArray(parsed.value)) return;
      saveDetectBlockHistory(parsed.value);
      drawBlockHistory();
      hFile.value = '';
    });

    hControls.appendChild(hClear);
    hControls.appendChild(hExport);
    hControls.appendChild(hImport);
    hControls.appendChild(hFile);

    const hWrap = el('div', {id:'detectBlockHistoryWrap'});
    historyCard.appendChild(hControls);
    historyCard.appendChild(el('div', {class:'divider'}));
    historyCard.appendChild(hWrap);

    function drawBlockHistory(){
      const items = loadDetectBlockHistory();
      hWrap.innerHTML = '';
      if(!items.length){
        hWrap.appendChild(el('p', {}, ['No history yet. Run Analyze Block to add entries.']));
        return;
      }

      const tbl = el('table');
      const thead = el('thead');
      thead.appendChild(el('tr', {}, [
        el('th', {}, ['Time']),
        el('th', {}, ['Preview']),
        el('th', {}, ['Threshold']),
        el('th', {}, ['Blocks'])
      ]));
      tbl.appendChild(thead);

      const tbody = el('tbody');
      for(const item of items){
        const tr = el('tr');
        tr.addEventListener('click', ()=>{
          area.value = item.text || '';
          saveToStorage('rr_detect_block_text', area.value);
          if(item.threshold){
            thr.value = String(item.threshold);
            thrLabel.textContent = 'Block threshold: ' + Math.round(parseFloat(thr.value)*100) + '%';
          }
          analyze();
        });

        const dt = item.ts ? new Date(item.ts) : null;
        const preview = String(item.text || '').replace(/\s+/g,' ').trim();
        tr.appendChild(el('td', {}, [dt ? dt.toLocaleString() : '']));
        tr.appendChild(el('td', {class:'mono'}, [preview.slice(0, 90) + (preview.length > 90 ? '…' : '')]));
        tr.appendChild(el('td', {}, [item.threshold != null ? (Math.round(parseFloat(item.threshold)*100) + '%') : '']));
        tr.appendChild(el('td', {}, [String(item.blocksCount != null ? item.blocksCount : '')]));
        tbody.appendChild(tr);
      }

      tbl.appendChild(tbody);
      hWrap.appendChild(tbl);
    }

    root.appendChild(historyCard);

    const drawDetails = (t) => {
      details.innerHTML = '';
      if(!t){
        details.appendChild(el('p', {class:'muted'}, ['Click a highlighted word to inspect it.']));
        return;
      }

      const lab = scoreToLabel(t.score);
      details.appendChild(el('h4', {}, [t.raw + '  (' + (t.norm||'') + ')']));

      const head = el('div', {class:'row'});
      head.appendChild(el('div', {class:'tag ' + lab.cls}, [Math.round(t.score*100) + '%']));
      head.appendChild(el('div', {class:'tag'}, [lab.label]));
      details.appendChild(head);

      if(t.segments && t.segments.length){
        details.appendChild(el('div', {class:'divider'}));
        details.appendChild(el('div', {class:'muted'}, ['Segments']));
        details.appendChild(el('div', {class:'mono'}, [t.segments.join(' | ')]));
      }

      details.appendChild(el('div', {class:'divider'}));
      details.appendChild(el('div', {class:'muted'}, ['Signals']));
      details.appendChild(renderSignalPills(t.signals || [], (id)=>{ drawSignalDetails(id); setActiveTab('detect'); }));

      details.appendChild(el('div', {class:'divider'}));
      details.appendChild(el('div', {class:'muted'}, ['Segmenter Rules Used']));
      details.appendChild(renderRulePills(t.ruleIds || [], (rid)=>{ drawRuleDetails(rid); setActiveTab('rules'); }));

      if(debugInput.checked){
        details.appendChild(el('div', {class:'divider'}));
        details.appendChild(el('div', {class:'muted'}, ['Debug']));
        const pre = el('pre', {style:'white-space:pre-wrap;'}, [JSON.stringify({base:t.base, contextDelta:t.contextDelta, coverage:t.coverage, orphans:t.orphans, notes:t.contextNotes, debug:t.debug}, null, 2)]);
        details.appendChild(pre);
      }
    };

    let lastSelected = null;

    function analyze(){
      const rawText = area.value || '';
      saveToStorage('rr_detect_block_text', rawText);

      hl.innerHTML = '';
      blocksWrap.innerHTML = '';
      drawDetails(null);

      const parts = tokenizeTextBlockParts(rawText);

      const wordTokens = [];
      const sepBuf = [];
      let wi = -1;
      for(const p of parts){
        if(p.type === 'word'){
          wi += 1;
          p.wordIndex = wi;
          wordTokens.push({ raw: p.raw });
          sepBuf[wi] = '';
        } else if(wi >= 0){
          sepBuf[wi] = (sepBuf[wi] || '') + (p.text || '');
        }
      }

      if(!wordTokens.length){
        hl.appendChild(el('p', {class:'muted'}, ['No word tokens found.']));
        return;
      }

      const boundaryAfter = [];
      for(let i=0;i<wordTokens.length-1;i++) boundaryAfter[i] = isHardBoundary(sepBuf[i] || '');

      const baseTokens = [];
      for(const wt of wordTokens){
        const norm = normalizeWord(wt.raw);
        const base = scoreTokenBase(norm, lists);
        baseTokens.push({ raw: wt.raw, norm, base: base.base, signals: base.signals, debug: base.debug, segments: base.segments, ruleIds: base.ruleIds, coverage: base.coverage, orphans: base.orphans, hardBlock: base.hardBlock });
      }

      const scored = applyContextBoostBounded(baseTokens, lists, boundaryAfter);

      const frag = document.createDocumentFragment();
      for(const p of parts){
        if(p.type === 'sep'){
          frag.appendChild(document.createTextNode(p.text || ''));
        } else {
          const t = scored[p.wordIndex];
          const lab = scoreToLabel(t.score);
          frag.appendChild(el('span', {class:'hlTok ' + lab.cls, 'data-idx': String(p.wordIndex)}, [p.raw]));
        }
      }
      hl.appendChild(frag);

      hl.querySelectorAll('.hlTok').forEach(sp => {
        sp.addEventListener('click', ()=>{
          const idx = parseInt(sp.getAttribute('data-idx') || '', 10);
          if(Number.isNaN(idx)) return;
          if(lastSelected != null){
            const prev = hl.querySelector('.hlTok[data-idx="' + lastSelected + '"]');
            if(prev) prev.classList.remove('sel');
          }
          sp.classList.add('sel');
          lastSelected = idx;
          drawDetails(scored[idx]);
        });
      });

      const thrVal = parseFloat(thr.value || '0.75');
      const blocks = [];
      let cur = [];
      let curStart = 0;

      const shouldInclude = (i) => {
        const t = scored[i];
        if(t.hardBlock) return false;
        if(t.score >= thrVal) return true;
        const support = (t.score >= Math.max(0.60, thrVal - 0.15)) && (lists.particles.has(t.norm) || lists.ambiguous.has(t.norm));
        if(!support) return false;
        const prevHigh = (i-1 >= 0 && !boundaryAfter[i-1] && scored[i-1].score >= thrVal);
        const nextHigh = (i+1 < scored.length && !boundaryAfter[i] && scored[i+1].score >= thrVal);
        return prevHigh || nextHigh;
      };

      for(let i=0;i<scored.length;i++){
        if(i>0 && boundaryAfter[i-1] && cur.length){
          blocks.push({ start: curStart, idxs: cur.slice() });
          cur = [];
        }
        if(shouldInclude(i)){
          if(!cur.length) curStart = i;
          cur.push(i);
        } else {
          if(cur.length){
            blocks.push({ start: curStart, idxs: cur.slice() });
            cur = [];
          }
        }
      }
      if(cur.length) blocks.push({ start: curStart, idxs: cur.slice() });

      // Save to history (text block mode only)
      addDetectBlockHistoryEntry({
        ts: new Date().toISOString(),
        text: rawText,
        threshold: thrVal,
        blocksCount: blocks.length,
        tokenCount: scored.length
      });
      drawBlockHistory();

      if(!blocks.length){
        blocksWrap.appendChild(el('p', {class:'muted'}, ['No blocks above threshold.']));
        return;
      }

      for(const b of blocks){
        const words = b.idxs.map(i => scored[i].raw);
        const avg = b.idxs.reduce((a,i)=>a+scored[i].score,0) / b.idxs.length;
        const btn = el('button', {type:'button', class:'tag good', title:'Avg ' + Math.round(avg*100) + '%'}, [words.join(' ')]);
        btn.addEventListener('click', ()=>{
          const idx = b.start;
          const elTok = hl.querySelector('.hlTok[data-idx="' + idx + '"]');
          if(elTok) elTok.click();
        });
        blocksWrap.appendChild(btn);
      }
    }

    runBtn.addEventListener('click', ()=>{
      prefs.showDebugBlock = !!debugInput.checked;
      saveDetectPrefs(prefs);
      analyze();
    });

    debugInput.addEventListener('change', ()=>{
      prefs.showDebugBlock = !!debugInput.checked;
      saveDetectPrefs(prefs);
      analyze();
    });

    thr.addEventListener('change', analyze);

    drawBlockHistory();

    analyze();
  }


function renderRules(){
    const root = document.getElementById('pageRules');
    root.innerHTML = '';

    const card = el('div', {class:'card'});
    card.appendChild(el('h2', {}, ['Rules']));
    card.appendChild(el('p', {}, ['Click a rule pill to view its explanation. Rule pills appear in regression results and demo history, and clicking them brings you here.']));

    const layout = el('div', {class:'ruleLayout'});
    const left = el('div', {class:'card'});
    const right = el('div', {class:'card'});

    left.appendChild(el('h3', {}, ['All Rules']));

    const search = el('input', {type:'search', placeholder:'Search rules by id, title, or category...'});

    const pills = el('div', {class:'pillGrid', id:'allRulePills', style:'margin-top:10px;'});

    left.appendChild(search);
    left.appendChild(pills);

    function filteredRules(q){
      const s = (q || '').trim().toLowerCase();
      if(!s) return RULES;
      return RULES.filter(r =>
        r.id.toLowerCase().includes(s) ||
        r.title.toLowerCase().includes(s) ||
        r.cat.toLowerCase().includes(s) ||
        r.desc.toLowerCase().includes(s)
      );
    }

    function drawPills(q){
      pills.innerHTML = '';
      const list = filteredRules(q);
      for(const r of list){
        const isSel = r.id === state.selectedRuleId;
        const cls = isSel ? 'tag good' : 'tag';
        const b = el('button', {type:'button', class: cls, title: `${r.title}`, onclick: ()=>{ state.selectedRuleId = r.id; drawDetails(); drawPills(search.value); }}, [r.id]);
        pills.appendChild(b);
      }
      if(!list.length){
        pills.appendChild(el('span', {class:'tag warn'}, ['no matches']));
      }
    }

    function drawDetails(){
      right.innerHTML = '';
      const r = RULE_BY_ID.get(state.selectedRuleId);
      if(!r){
        right.appendChild(el('h3', {}, ['Rule Details']));
        right.appendChild(el('p', {}, ['Select a rule to view details.']));
        return;
      }

      right.appendChild(el('h3', {}, ['Rule Details']));
      right.appendChild(el('div', {class:'row'}, [
        el('span', {class:'tag'}, [r.id]),
        el('span', {class:'tag'}, [`category: ${r.cat}`]),
        el('span', {class:'tag'}, [r.title])
      ]));

      right.appendChild(el('div', {class:'divider'}));

      right.appendChild(el('h3', {}, ['Explanation']));

      // Use <pre> to preserve multi-line formatting from the logic document
      right.appendChild(el('pre', {}, [r.desc]));

      if(r.example){
        right.appendChild(el('h3', {}, ['Example']));
        right.appendChild(el('pre', {}, [r.example]));
      }

      const btnRow = el('div', {class:'row', style:'margin-top:10px;'});
      btnRow.appendChild(el('button', {class:'btn', type:'button', onclick:()=>{
        navigator.clipboard && navigator.clipboard.writeText ? navigator.clipboard.writeText(r.id) : null;
      }}, ['Copy Rule Id']));

      btnRow.appendChild(el('button', {class:'btn', type:'button', onclick:()=>{
        setActiveTab('regression');
      }}, ['Back To Regression']));

      right.appendChild(btnRow);
    }

    search.addEventListener('input', ()=> drawPills(search.value));

    drawDetails();
    drawPills(search.value);

    layout.appendChild(left);
    layout.appendChild(right);

    card.appendChild(layout);
    root.appendChild(card);
  }


function defaultSttPrefs(){
  return {
    lang: 'mi-NZ',
    continuous: true,
    interim: true,
    autoDetectThreshold: 0.75,
    showDebug: false
  };
}

function loadSttPrefs(){
  const base = defaultSttPrefs();
  const raw = loadFromStorage(STORAGE_KEYS.sttPrefs);
  const parsed = raw ? safeJsonParse(raw) : {ok:false};
  if(parsed.ok && parsed.value && typeof parsed.value === 'object') return {...base, ...parsed.value};
  return base;
}

function saveSttPrefs(p){
  return saveToStorage(STORAGE_KEYS.sttPrefs, JSON.stringify(p || {}, null, 2));
}

function loadSttHistory(){
  const raw = loadFromStorage(STORAGE_KEYS.sttHistory);
  const parsed = raw ? safeJsonParse(raw) : {ok:false};
  if(parsed.ok && Array.isArray(parsed.value)) return parsed.value;
  return [];
}

function saveSttHistory(list){
  return saveToStorage(STORAGE_KEYS.sttHistory, JSON.stringify(list || [], null, 2));
}

function addSttHistoryEntry(entry){
  const list = loadSttHistory();
  list.unshift(entry);
  if(list.length > 200) list.length = 200;
  saveSttHistory(list);
}

function renderSpeechToText(){
  const root = document.getElementById('pageSTT');
  root.innerHTML = '';

  const prefs = loadSttPrefs();

  const card = el('div', {class:'card'});
  card.appendChild(el('h2', {}, ['Speech To Text']));
  card.appendChild(el('p', {class:'muted'}, [
    'Web only live microphone speech recognition. MP3 files can be played here for convenience, but browsers cannot transcribe an MP3 directly without downloads or a server.'
  ]));

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;

  const row = el('div', {class:'row'});
  const lang = el('select', {class:'input'});
  const langOpts = [
    {v:'mi-NZ', t:'mi-NZ (Te Reo Maori)'},
    {v:'en-NZ', t:'en-NZ (English NZ)'},
    {v:'en-AU', t:'en-AU (English AU)'},
    {v:'en-US', t:'en-US (English US)'},
    {v:'custom', t:'Custom'}
  ];
  for(const o of langOpts){
    const opt = el('option', {value:o.v}, [o.t]);
    if((prefs.lang || 'mi-NZ') === o.v) opt.selected = true;
    lang.appendChild(opt);
  }
  const customLang = el('input', {class:'input', placeholder:'Language tag eg mi-NZ', value: (prefs.lang && !langOpts.some(x=>x.v===prefs.lang)) ? prefs.lang : ''});
  customLang.style.maxWidth = '220px';

  const startBtn = el('button', {class:'btn', type:'button'}, ['Start']);
  const stopBtn = el('button', {class:'btn', type:'button', disabled:true}, ['Stop']);
  const clearBtn = el('button', {class:'btn', type:'button'}, ['Clear']);

  const status = el('div', {class:'tag'}, [SR ? 'Ready' : 'SpeechRecognition Not Available']);
  status.style.marginLeft = 'auto';

  row.appendChild(el('div', {class:'muted'}, ['Language']));
  row.appendChild(lang);
  row.appendChild(customLang);
  row.appendChild(startBtn);
  row.appendChild(stopBtn);
  row.appendChild(clearBtn);
  row.appendChild(status);

  card.appendChild(row);

  const transcriptCard = el('div', {class:'card'});
  transcriptCard.appendChild(el('h3', {}, ['Transcript']));

  const interimLine = el('div', {class:'muted', style:'min-height:22px;'}, ['']);
  const finalBox = el('textarea', {class:'textarea mono', rows:'6', placeholder:'Final transcript will appear here'});
  const buttons2 = el('div', {class:'row'});
  const copyBtn = el('button', {class:'btn', type:'button'}, ['Copy']);
  const saveHistBtn = el('button', {class:'btn', type:'button'}, ['Save To History']);
  const sendAwsBtn = el('button', {class:'btn', type:'button'}, ['Send To G2P - AWS TTS']);
  buttons2.appendChild(copyBtn);
  buttons2.appendChild(saveHistBtn);
  buttons2.appendChild(sendAwsBtn);

  transcriptCard.appendChild(interimLine);
  transcriptCard.appendChild(finalBox);
  transcriptCard.appendChild(buttons2);

  // MP3 Assist
  const audioCard = el('div', {class:'card'});
  audioCard.appendChild(el('h3', {}, ['Audio File Assist']));
  audioCard.appendChild(el('p', {class:'muted'}, [
    'If you want to transcribe an MP3 without downloads, play it here and run live dictation. If your system can loop back audio into the mic, recognition can capture it.'
  ]));
  const audioRow = el('div', {class:'row'});
  const fileIn = el('input', {type:'file', class:'input', accept:'audio/*'});
  fileIn.style.maxWidth = '420px';
  const audioEl = el('audio', {controls:true});
  audioEl.style.width = '100%';
  audioRow.appendChild(fileIn);
  audioCard.appendChild(audioRow);
  audioCard.appendChild(audioEl);

  root.appendChild(card);
  root.appendChild(transcriptCard);
  root.appendChild(audioCard);

  // Te Reo Detect Panel
  const detectCard = el('div', {class:'card'});
  detectCard.appendChild(el('h3', {}, ['Te Reo Detect']));
  detectCard.appendChild(el('p', {class:'muted'}, ['Analyze the transcript and highlight likely te reo tokens. Included tokens use a subtle underline. Shift click a token to toggle include for that occurrence.']));

  const detectRow = el('div', {class:'row'});
  const analyzeBtn = el('button', {class:'btn', type:'button'}, ['Analyze']);
  const thr = el('input', {type:'range', min:'0.50', max:'0.90', step:'0.01', value:String(prefs.autoDetectThreshold ?? 0.75)});
  thr.style.width = '220px';
  const thrTag = el('div', {class:'tag'}, ['Threshold: ' + Math.round(parseFloat(thr.value)*100) + '%']);
  const dbgLbl = el('label', {class:'checkbox'});
  const dbg = el('input', {type:'checkbox'});
  dbg.checked = !!prefs.showDebug;
  dbgLbl.appendChild(dbg);
  dbgLbl.appendChild(document.createTextNode('Debug'));
  const teReoWordsBtn = el('button', {class:'btn', type:'button'}, ['Copy Te Reo Words']);

  detectRow.appendChild(analyzeBtn);
  detectRow.appendChild(thrTag);
  detectRow.appendChild(thr);
  detectRow.appendChild(dbgLbl);
  detectRow.appendChild(teReoWordsBtn);

  detectCard.appendChild(detectRow);

  const layout = el('div', {class:'detectBlockLayout'});
  const left = el('div', {class:'card', style:'margin:0; padding:12px;'});
  const right = el('div', {class:'card', style:'margin:0; padding:12px;'});
  left.appendChild(el('h3', {}, ['Highlighted Text']));
  const hl = el('div', {class:'hlText'});
  left.appendChild(hl);

  right.appendChild(el('h3', {}, ['Detected Blocks']));
  const blocksEl = el('div', {});
  right.appendChild(blocksEl);
  right.appendChild(el('div', {class:'divider'}));
  right.appendChild(el('h3', {}, ['Word Details']));
  const detailsEl = el('div', {});
  right.appendChild(detailsEl);

  layout.appendChild(left);
  layout.appendChild(right);
  detectCard.appendChild(layout);
  root.appendChild(detectCard);

  // History Panel
  const histCard = el('div', {class:'card'});
  histCard.appendChild(el('h3', {}, ['History']));
  const histList = el('div', {});
  histCard.appendChild(histList);
  root.appendChild(histCard);

  function refreshHistory(){
    histList.innerHTML = '';
    const list = loadSttHistory();
    if(!list.length){
      histList.appendChild(el('p', {class:'muted'}, ['No history yet']));
      return;
    }
    const top = el('div', {class:'row'});
    const clearHist = el('button', {class:'btn', type:'button'}, ['Clear History']);
    top.appendChild(clearHist);
    histList.appendChild(top);

    clearHist.addEventListener('click', ()=>{
      if(!confirm('Clear speech to text history?')) return;
      saveSttHistory([]);
      refreshHistory();
    });

    for(const it of list.slice(0, 30)){
      const b = el('button', {class:'btn', type:'button', style:'width:100%; text-align:left; white-space:normal;'}, [
        (it.when || '') + '  ' + (it.lang || '') + '  ' + (it.text || '').slice(0, 120)
      ]);
      b.addEventListener('click', ()=>{
        finalBox.value = it.text || '';
        runDetect(true);
      });
      histList.appendChild(b);
    }
  }

  refreshHistory();

  let recog = null;
  let listening = false;

  function getSelectedLang(){
    const v = lang.value;
    if(v === 'custom') return (customLang.value || 'mi-NZ').trim();
    return v;
  }

  function setUiListening(on){
    listening = on;
    startBtn.disabled = on;
    stopBtn.disabled = !on;
    status.textContent = SR ? (on ? 'Listening' : 'Ready') : 'SpeechRecognition Not Available';
  }

  function startRec(){
    if(!SR){
      alert('SpeechRecognition is not available in this browser.');
      return;
    }
    if(listening) return;

    const chosen = getSelectedLang();
    const nextPrefs = loadSttPrefs();
    nextPrefs.lang = chosen;
    nextPrefs.continuous = true;
    nextPrefs.interim = true;
    saveSttPrefs(nextPrefs);

    recog = new SR();
    recog.continuous = true;
    recog.interimResults = true;
    recog.lang = chosen;
    recog.maxAlternatives = 3;

    recog.onstart = ()=>{ setUiListening(true); };
    recog.onerror = (e)=>{ status.textContent = 'Error: ' + (e.error || 'unknown'); };
    recog.onend = ()=>{ setUiListening(false); };

    recog.onresult = (event)=>{
      let interim = '';
      for(let i=event.resultIndex; i<event.results.length; i++){
        const res = event.results[i];
        const txt = (res[0] && res[0].transcript) ? res[0].transcript : '';
        if(res.isFinal){
          const t = txt.trim();
          if(t){
            const sep = finalBox.value && !finalBox.value.endsWith('\\n') ? ' ' : '';
            finalBox.value = (finalBox.value || '') + sep + t;
          }
        } else {
          interim += txt;
        }
      }
      interimLine.textContent = interim.trim() ? ('Interim: ' + interim.trim()) : '';
    };

    try{
      recog.start();
    } catch(e){
      status.textContent = 'Start failed';
    }
  }

  function stopRec(){
    if(recog){
      try{ recog.stop(); } catch(e){}
    }
    setUiListening(false);
  }

  startBtn.addEventListener('click', startRec);
  stopBtn.addEventListener('click', stopRec);

  clearBtn.addEventListener('click', ()=>{
    interimLine.textContent = '';
    finalBox.value = '';
    hl.innerHTML = '';
    blocksEl.innerHTML = '';
    detailsEl.innerHTML = '';
  });

  copyBtn.addEventListener('click', async ()=>{
    try{
      await navigator.clipboard.writeText(finalBox.value || '');
    } catch(e){
      alert('Copy failed');
    }
  });

  saveHistBtn.addEventListener('click', ()=>{
    const txt = (finalBox.value || '').trim();
    if(!txt) return;
    addSttHistoryEntry({ when: new Date().toISOString().replace('T',' ').slice(0,19), lang: getSelectedLang(), text: txt });
    refreshHistory();
  });

  fileIn.addEventListener('change', ()=>{
    const f = fileIn.files && fileIn.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    audioEl.src = url;
    audioEl.load();
  });

  sendAwsBtn.addEventListener('click', ()=>{
    const txt = (finalBox.value || '').trim();
    if(!txt) return;
    const awsPrefs = loadG2pAwsTtsPrefs();
    awsPrefs.inputMode = 'text';
    awsPrefs.outputMode = 'mixed_auto';
    awsPrefs.preservePunct = true;
    awsPrefs.lastInputText = txt;
    awsPrefs.awsAutoDetectThreshold = clamp01(parseFloat(thr.value || '0.75'));
    saveG2pAwsTtsPrefs(awsPrefs);
    renderG2PAwsTts();
    setActiveTab('g2pAwsTts');
  });

  // Detect logic
  const detectLists = (()=>{
    const ambiguousArr = loadTokenList(STORAGE_KEYS.detectAmbiguous, defaultAmbiguousTokens);
    const particlesArr = loadTokenList(STORAGE_KEYS.detectParticles, defaultParticleTokens);
    return { ambiguousArr, particlesArr, ambiguous: new Set(ambiguousArr), particles: new Set(particlesArr) };
  })();

  let cache = null;
  let overrides = {}; // position index -> bool include

  function normKey(base, idx){
    return (base || '') + '#' + String(idx);
  }

  function computeDetect(rawText, thrVal){
    const parts = tokenizeTextBlockParts(rawText || '');
    let wi = -1;
    for(const p of parts){
      if(p.type === 'word'){
        wi += 1;
        p.wordIndex = wi;
      }
    }

    const boundaryAfter = new Array(wi+1).fill(false);
    for(let i=0;i<parts.length;i++){
      const p = parts[i];
      if(p.type !== 'word') continue;
      const next = parts[i+1];
      if(next && next.type === 'sep'){
        boundaryAfter[p.wordIndex] = isHardBoundary(next.text || '');
      }
    }

    const wordTokens = [];
    for(const p of parts) if(p.type === 'word') wordTokens.push({ raw: p.raw });

    const baseTokens = [];
    for(const wt of wordTokens){
      const norm = normalizeWord(wt.raw);
      const base = scoreTokenBase(norm, detectLists);
      baseTokens.push({
        raw: wt.raw,
        norm,
        base: base.base,
        signals: base.signals,
        debug: base.debug,
        segments: base.segments,
        ruleIds: base.ruleIds,
        coverage: base.coverage,
        orphans: base.orphans,
        hardBlock: base.hardBlock
      });
    }

    const scored = applyContextBoostBounded(baseTokens, detectLists, boundaryAfter);

    const shouldInclude = (i)=>{
      const t = scored[i];
      if(!t || t.hardBlock) return false;
      if(t.score >= thrVal) return true;

      const isSupport = (t.score >= Math.max(0.60, thrVal - 0.15))
        && (detectLists.particles.has(t.norm) || detectLists.ambiguous.has(t.norm));
      if(!isSupport) return false;

      const prevHigh = (i-1 >= 0 && !boundaryAfter[i-1] && scored[i-1].score >= thrVal);
      const nextHigh = (i+1 < scored.length && !boundaryAfter[i] && scored[i+1].score >= thrVal);
      return prevHigh || nextHigh;
    };

    const includeAuto = new Array(scored.length).fill(false);
    const includeFinal = new Array(scored.length).fill(false);

    const blocks = [];
    let cur = [];
    let curStart = 0;

    for(let i=0;i<scored.length;i++){
      if(i>0 && boundaryAfter[i-1] && cur.length){
        blocks.push({ start: curStart, idxs: cur.slice() });
        cur = [];
      }

      if(shouldInclude(i)){
        if(!cur.length) curStart = i;
        cur.push(i);
        includeAuto[i] = true;
      } else {
        if(cur.length){
          blocks.push({ start: curStart, idxs: cur.slice() });
          cur = [];
        }
      }
    }
    if(cur.length) blocks.push({ start: curStart, idxs: cur.slice() });

    for(let i=0;i<includeAuto.length;i++){
      if(i in overrides) includeFinal[i] = !!overrides[i];
      else includeFinal[i] = includeAuto[i];
    }

    return { parts, scored, blocks, includeAuto, includeFinal, boundaryAfter };
  }

  function drawDetails(t, idx){
    detailsEl.innerHTML = '';
    if(!t){
      detailsEl.appendChild(el('p', {class:'muted'}, ['Click a highlighted token to inspect it']));
      return;
    }

    const lab = scoreToLabel(t.score);
    detailsEl.appendChild(el('h4', {}, [t.raw + '  (' + (t.norm||'') + ')']));

    const head = el('div', {class:'row'});
    head.appendChild(el('div', {class:'tag ' + lab.cls}, [Math.round(t.score*100) + '%']));
    head.appendChild(el('div', {class:'tag'}, [lab.label]));

    const inc = el('label', {class:'checkbox'});
    const cb = el('input', {type:'checkbox'});
    cb.checked = !!cache.includeFinal[idx];
    inc.appendChild(cb);
    inc.appendChild(document.createTextNode('Include'));
    head.appendChild(inc);

    const clearOv = el('button', {class:'btn', type:'button'}, ['Clear Override']);
    head.appendChild(clearOv);

    detailsEl.appendChild(head);

    cb.addEventListener('change', ()=>{
      overrides[idx] = !!cb.checked;
      renderDetect(cache);
    });

    clearOv.addEventListener('click', ()=>{
      delete overrides[idx];
      renderDetect(cache);
    });

    if(t.segments && t.segments.length){
      detailsEl.appendChild(el('div', {class:'divider'}));
      detailsEl.appendChild(el('div', {class:'muted'}, ['Segments']));
      detailsEl.appendChild(el('div', {class:'mono'}, [t.segments.join(' | ')]));
    }

    detailsEl.appendChild(el('div', {class:'divider'}));
    detailsEl.appendChild(el('div', {class:'muted'}, ['Signals']));
    detailsEl.appendChild(renderSignalPills(t.signals || [], (id)=>{ drawSignalDetails(id); setActiveTab('detect'); }));

    detailsEl.appendChild(el('div', {class:'divider'}));
    detailsEl.appendChild(el('div', {class:'muted'}, ['Segmenter Rules Used']));
    detailsEl.appendChild(renderRulePills(t.ruleIds || [], (rid)=>{ drawRuleDetails(rid); setActiveTab('rules'); }));

    if(dbg.checked){
      detailsEl.appendChild(el('div', {class:'divider'}));
      detailsEl.appendChild(el('div', {class:'muted'}, ['Debug']));
      detailsEl.appendChild(el('pre', {style:'white-space:pre-wrap;'}, [
        JSON.stringify({
          base:t.base, contextDelta:t.contextDelta, notes:t.contextNotes,
          hardBlock:t.hardBlock, coverage:t.coverage, orphans:t.orphans, debug:t.debug
        }, null, 2)
      ]));
    }
  }

  function renderDetect(res){
    if(!res) return;
    cache = res;

    hl.innerHTML = '';
    blocksEl.innerHTML = '';
    detailsEl.innerHTML = '';

    const parts = res.parts || [];
    const scored = res.scored || [];

    const frag = document.createDocumentFragment();

    for(const p of parts){
      if(p.type === 'sep'){
        frag.appendChild(document.createTextNode(p.text || ''));
      } else {
        const t = scored[p.wordIndex];
        const lab = scoreToLabel(t.score);

        const sp = el('span', {class:'hlTok ' + lab.cls, 'data-idx': String(p.wordIndex)}, [p.raw]);

        if(res.includeFinal[p.wordIndex]){
          sp.classList.add('incl');
          const dot = el('span', {class:'muted', style:'margin-left:4px; font-size:10px;'}, ['•']);
          sp.appendChild(dot);
        }

        if(p.wordIndex in overrides){
          sp.classList.add('manual');
        }

        frag.appendChild(sp);
      }
    }

    hl.appendChild(frag);

    hl.querySelectorAll('.hlTok').forEach(sp=>{
      sp.addEventListener('click', (ev)=>{
        const idx = parseInt(sp.getAttribute('data-idx') || '', 10);
        if(Number.isNaN(idx)) return;

        if(ev.shiftKey){
          const next = !cache.includeFinal[idx];
          overrides[idx] = next;
          renderDetect(computeDetect(finalBox.value || '', clamp01(parseFloat(thr.value || '0.75'))));
          return;
        }

        hl.querySelectorAll('.hlTok').forEach(x=>x.classList.remove('sel'));
        sp.classList.add('sel');
        drawDetails(scored[idx], idx);
      });
    });

    if(!res.blocks.length){
      blocksEl.appendChild(el('p', {class:'muted'}, ['No blocks above threshold']));
    } else {
      for(const b of res.blocks){
        const words = b.idxs.map(i => scored[i].raw);
        const avg = b.idxs.reduce((a,i)=>a+scored[i].score,0) / b.idxs.length;
        const lab = scoreToLabel(avg);

        const btn = el('button', {
          type:'button',
          class:'btn tag ' + lab.cls,
          style:'width:100%; text-align:left; white-space:normal;',
          title:'Avg ' + Math.round(avg*100) + '%'
        }, [words.join(' ')]);

        btn.addEventListener('click', ()=>{
          const idx = b.start;
          const elTok = hl.querySelector('.hlTok[data-idx="' + idx + '"]');
          if(elTok) elTok.click();
        });

        blocksEl.appendChild(btn);
      }
    }

    // keep selected
    if(scored.length) drawDetails(scored[0], 0);
  }

  function runDetect(renderNow){
    const rawText = String(finalBox.value || '');
    const thrVal = clamp01(parseFloat(thr.value || '0.75'));
    thrTag.textContent = 'Threshold: ' + Math.round(thrVal*100) + '%';
    const res = computeDetect(rawText, thrVal);
    if(renderNow) renderDetect(res);
    return res;
  }

  analyzeBtn.addEventListener('click', ()=> runDetect(true));

  thr.addEventListener('input', ()=>{
    const next = loadSttPrefs();
    next.autoDetectThreshold = clamp01(parseFloat(thr.value || '0.75'));
    saveSttPrefs(next);
    thrTag.textContent = 'Threshold: ' + Math.round(parseFloat(thr.value)*100) + '%';
    runDetect(true);
  });

  dbg.addEventListener('change', ()=>{
    const next = loadSttPrefs();
    next.showDebug = !!dbg.checked;
    saveSttPrefs(next);
    runDetect(true);
  });

  teReoWordsBtn.addEventListener('click', async ()=>{
    const res = runDetect(false);
    const words = [];
    for(let i=0;i<(res.scored||[]).length;i++){
      if(res.includeFinal[i]) words.push(res.scored[i].raw);
    }
    const out = words.join(' ');
    try{
      await navigator.clipboard.writeText(out);
    } catch(e){
      alert('Copy failed');
    }
  });

  // initial detect from existing transcript if present
  if((finalBox.value || '').trim()) runDetect(true);
}

  // Init
  document.getElementById('tabRegression').addEventListener('click', ()=>{ renderRegression(); setActiveTab('regression'); });
  document.getElementById('tabDemo').addEventListener('click', ()=>{ renderDemo(); setActiveTab('demo'); });
  document.getElementById('tabG2P').addEventListener('click', ()=>{ renderG2P(); setActiveTab('g2p'); });
  document.getElementById('tabG2PAwsTts').addEventListener('click', ()=>{ renderG2PAwsTts(); setActiveTab('g2pAwsTts'); });
  document.getElementById('tabIpaLookupKeyboard').addEventListener('click', ()=>{ renderIpaLookupKeyboard(); setActiveTab('ipaLookupKeyboard'); });
  document.getElementById('tabSTT').addEventListener('click', ()=>{ renderSpeechToText(); setActiveTab('stt'); });
  document.getElementById('tabDetect').addEventListener('click', ()=>{ renderDetect(); setActiveTab('detect'); });
  document.getElementById('tabDetectBlock').addEventListener('click', ()=>{ renderDetectBlock(); setActiveTab('detectBlock'); });
  document.getElementById('tabRules').addEventListener('click', ()=>{ renderRules(); setActiveTab('rules'); });

  window.addEventListener('DOMContentLoaded', ()=>{
    renderRegression();
    renderDemo();
    renderG2P();
    renderDetect();
    renderRules();
    setActiveTab('regression');
  });
</script>
</body>
</html>
