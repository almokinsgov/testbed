<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Far North Emergency Situation Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }

    #map {
      height: 100vh;
      width: 100%;
    }

    .map-legend {
      background: rgba(255, 255, 255, 0.95);
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .map-legend h2 {
      font-size: 0.9rem;
      margin: 0 0 0.25rem;
    }

    .map-legend ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .map-legend li {
      margin: 0.1rem 0;
    }

    .layer-pill {
      display: inline-block;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #e0e0e0;
      margin-right: 0.25rem;
    }
	
	    .legend-item {
      display: flex;
      align-items: center;
      margin: 0.15rem 0;
    }

    .legend-swatch {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 0.4rem;
      border: 2px solid #ffffff;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
    }

  </style>
</head>
<body>
  <div
    id="map"
    role="region"
    aria-label="Far North emergency situation map showing weather, tides, outages, warnings and community locations"
  ></div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // Base map
    var map = L.map("map", {
      center: [-35.15, 173.65], // Roughly Far North District
      zoom: 8
    });

    var osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // Overlay layer containers
    var layerMetServiceWarnings = L.layerGroup();
    var layerCivilDefenceAlerts = L.layerGroup();
    var layerPowerOutages = L.layerGroup();
    var layerWaterOutages = L.layerGroup();
    var layerRoadWarnings = L.layerGroup();
    var layerMarae = L.layerGroup();
    var layerCommunityHalls = L.layerGroup();
    var layerWeatherAreas = L.layerGroup();
    var layerTides = L.layerGroup();
    var layerRivers = L.layerGroup();

    // Add layers to control
    var baseLayers = {
      "OpenStreetMap": osm
    };

    var overlays = {
      "MetService Weather Warnings": layerMetServiceWarnings,
      "Civil Defence Alerts": layerCivilDefenceAlerts,
      "Power Outages": layerPowerOutages,
      "Water Outages": layerWaterOutages,
      "NZTA Road Warnings and Closures": layerRoadWarnings,
      "Marae locations": layerMarae,
      "Community Hall locations": layerCommunityHalls,
      "Weather": layerWeatherAreas,
      "Tides": layerTides,
      "NRC River Data": layerRivers
    };

    L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

       // Marker legend
    var legend = L.control({ position: "bottomleft" });
    legend.onAdd = function () {
      var div = L.DomUtil.create("div", "map-legend");
      div.innerHTML = `
        <h2>Map Legend</h2>
        <ul>
          <li><strong>Weather</strong></li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#1976d2;"></span>
            Weather location
          </li>

          <li><strong>Tides</strong></li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#009688;"></span>
            Tide site
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#2196f3;"></span>
            High tide phase
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#ff9800;"></span>
            Low tide phase
          </li>

          <li><strong>Power outages (Top Energy)</strong></li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#e91e63;"></span>
            Unplanned outage
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#d81b60;"></span>
            Planned outage active
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#ffb300;"></span>
            Planned outage scheduled
          </li>

          <li><strong>Water outages (FNDC)</strong></li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#0277bd;"></span>
            New
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#0288d1;"></span>
            Reported
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#f57c00;"></span>
            Under repairs
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#7b1fa2;"></span>
            Planned
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#2e7d32;"></span>
            Restored
          </li>

          <li><strong>Road events (NZTA)</strong></li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#b71c1c;"></span>
            Closure
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#ff9800;"></span>
            Warning or caution
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#009688;"></span>
            Roadworks
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#ff5722;"></span>
            Hazard
          </li>

          <li><strong>Community</strong></li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#795548;"></span>
            Marae
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#9c27b0;"></span>
            Community hall
          </li>

          <li><strong>Rivers (NRC)</strong></li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#4caf50;"></span>
            River site
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#1976d2;"></span>
            River rising
          </li>
          <li class="legend-item">
            <span class="legend-swatch" style="background:#f44336;"></span>
            River falling
          </li>
        </ul>
      `;
      return div;
    };
    legend.addTo(map);


    // Helper: basic icon factory
    function makeIcon(color) {
      return L.divIcon({
        className: "custom-marker",
        html: '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:' + color + ';border:2px solid white;box-shadow:0 0 2px rgba(0,0,0,0.6);"></span>',
        iconSize: [16, 16],
        iconAnchor: [8, 8]
      });
    }

    // Helper: tide icon with direction arrow
    function makeTideIcon(color, direction) {
      var arrowChar =
        direction === "rising" ? "⬆" :
        direction === "falling" ? "⬇" :
        "";

      var arrowHtml = arrowChar
        ? '<span style="margin-left:2px;font-size:11px;">' + arrowChar + "</span>"
        : "";

      return L.divIcon({
        className: "custom-marker custom-marker-tide",
        html:
          '<div style="display:flex;align-items:center;">' +
            '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:' +
              color +
              ';border:2px solid white;box-shadow:0 0 2px rgba(0,0,0,0.6);"></span>' +
            arrowHtml +
          "</div>",
        iconSize: [18, 16],
        iconAnchor: [9, 8]
      });
    }


    // Marker style configuration
    // Polygons have their own styling further down
    var MARKER_CONFIG = {
      weatherAreas: {
        color: "#1976d2"
      },
      tides: {
        // Default tide marker colour
        defaultColor: "#009688",
        // Optional different colours by tide state if your data includes it
        // For example site.state or site.tideType
        colorByState: {
          high: "#2196f3",
          low: "#ff9800"
        }
      },
      powerOutages: {
        // Keys match statusType passed into colourForStatus
        unplanned: "#e91e63",
        plannedActive: "#d81b60",
        planned: "#ffb300",
        defaultColor: "#9e9e9e"
      },
      waterOutages: {
        defaultColor: "#2196f3",
        // Keys match item.status from the asset listing
        colorByStatus: {
          "New": " #0277bd",
          "Reported": "#0288d1",
          "Under repairs": "#f57c00",
          "Planned": "#7b1fa2",
          "Restored": "#2e7d32"
        }
      },
      nzta: {
        // Point marker colours by NZTA event type
        point: {
          closures: "#b71c1c",
          warnings: "#ff9800",
          roadworks: "#009688",
          hazards: "#ff5722",
          defaultColor: "#1976d2"
        }
      },
      marae: {
        color: "#795548"
      },
      communityHalls: {
        color: "#9c27b0"
      },
      rivers: {
        // Colour by flow or trend from Icon.Name
        defaultColor: "#4caf50",
        colorByTrend: {
          rising: "#1976d2",
          falling: "#f44336"
        }
      }
    };


        // 1. Weather From Open Meteo For Key Locations

    // Live Open Meteo API for six Far North locations
    var OPEN_METEO_URL =
      "https://api.open-meteo.com/v1/forecast?latitude=-35.111,-35.415307,-35.1034116,-35.27075,-34.834066,-34.511518&longitude=173.265,173.797135,173.7109356,173.215174,173.106533,172.890875&daily=weather_code&hourly=precipitation_probability,precipitation,rain,weather_code,wind_speed_10m,wind_gusts_10m,temperature_2m,relative_humidity_2m&current=temperature_2m,relative_humidity_2m,apparent_temperature,wind_speed_10m,wind_direction_10m,weather_code,wind_gusts_10m,precipitation&timezone=Pacific%2FAuckland&forecast_days=3";

    // Local test option: use your saved Open Meteo response file instead of live API
    // var OPEN_METEO_URL = "forecast.json";

    // Locations in the same order as the Open Meteo latitude and longitude lists
    var WEATHER_LOCATIONS = [
      { name: "Kaitaia",     lat: -35.111,     lng: 173.265 },
      { name: "Kaikohe",     lat: -35.415307,  lng: 173.797135 },
      { name: "Kaeo",        lat: -35.1034116, lng: 173.7109356 },
      { name: "Herekino",    lat: -35.27075,   lng: 173.215174 },
      { name: "Waiharara",   lat: -34.834066,  lng: 173.106533 },
      { name: "Cape Reinga", lat: -34.511518,  lng: 172.890875 }
    ];

    // Translate WMO weather code to a simple description
    function wmoToText(code) {
      var map = {
        0:  "Clear sky",
        1:  "Mainly clear",
        2:  "Partly cloudy",
        3:  "Overcast",
        45: "Fog",
        48: "Depositing rime fog",
        51: "Light drizzle",
        53: "Moderate drizzle",
        55: "Dense drizzle",
        56: "Light freezing drizzle",
        57: "Dense freezing drizzle",
        61: "Slight rain",
        63: "Moderate rain",
        65: "Heavy rain",
        66: "Light freezing rain",
        67: "Heavy freezing rain",
        71: "Slight snowfall",
        73: "Moderate snowfall",
        75: "Heavy snowfall",
        77: "Snow grains",
        80: "Slight rain showers",
        81: "Moderate rain showers",
        82: "Violent rain showers",
        85: "Slight snow showers",
        86: "Heavy snow showers",
        95: "Thunderstorm",
        96: "Thunderstorm with slight hail",
        99: "Thunderstorm with heavy hail"
      };
      return map[code] || "Unknown conditions";
    }

    function buildWeatherPopupHtml(site, forecast) {
      var current = forecast.current || {};
      var dailyCode =
        forecast.daily &&
        Array.isArray(forecast.daily.weather_code) &&
        forecast.daily.weather_code.length
          ? forecast.daily.weather_code[0]
          : null;

      var currentDesc =
        typeof current.weather_code === "number"
          ? wmoToText(current.weather_code)
          : "";

      var dailyDesc =
        typeof dailyCode === "number"
          ? wmoToText(dailyCode)
          : "";

      var html =
        "<strong>" + site.name + "</strong><br>" +
        (currentDesc ? "Now: " + currentDesc + "<br>" : "") +
        "Temperature: " +
        (current.temperature_2m != null
          ? current.temperature_2m.toFixed(1) + " °C"
          : "n/a") +
        "<br>" +
        "Feels like: " +
        (current.apparent_temperature != null
          ? current.apparent_temperature.toFixed(1) + " °C"
          : "n/a") +
        "<br>" +
        "Humidity: " +
        (current.relative_humidity_2m != null
          ? current.relative_humidity_2m + " %"
          : "n/a") +
        "<br>" +
        "Wind: " +
        (current.wind_speed_10m != null
          ? current.wind_speed_10m + " km/h"
          : "n/a") +
        (current.wind_direction_10m != null
          ? " (" + current.wind_direction_10m + "°)"
          : "") +
        "<br>";

      if (current.wind_gusts_10m != null) {
        html += "Gusts: " + current.wind_gusts_10m + " km/h<br>";
      }

      if (current.precipitation != null) {
        html += "Precipitation: " + current.precipitation + " mm<br>";
      }

      if (dailyDesc) {
        html += "<br>Today: " + dailyDesc;
      }

      return html;
    }

    function addWeatherMarker(site, forecast) {
      var popupHtml = buildWeatherPopupHtml(site, forecast);

      var marker = L.marker([site.lat, site.lng], {
        icon: makeIcon(MARKER_CONFIG.weatherAreas.color)
      });

      // Hover popup behaviour for the Weather layer
      marker.bindPopup(popupHtml);
      marker.on("mouseover", function () {
        this.openPopup();
      });
      marker.on("mouseout", function () {
        this.closePopup();
      });

      layerWeatherAreas.addLayer(marker);
    }

    function loadWeatherFromOpenMeteo() {
      fetch(OPEN_METEO_URL)
        .then(function (res) {
          return res.json();
        })
        .then(function (data) {
          // Open Meteo multi location responses are an array
          // Your saved forecast.json has this format
          var forecasts = Array.isArray(data) ? data : [data];

          if (!forecasts.length) {
            console.warn("Open Meteo weather data empty");
            return;
          }

          WEATHER_LOCATIONS.forEach(function (site, idx) {
            var forecast = forecasts[idx];
            if (!forecast || !forecast.current) {
              return;
            }
            addWeatherMarker(site, forecast);
          });
        })
        .catch(function (err) {
          console.warn("Open Meteo weather load failed", err);
        });
    }

    // Kick off weather load
    loadWeatherFromOpenMeteo();


        // 2. Tides from NIWA Tide API and CSV locations

    // CSV containing place name and coordinates
    // Format (single header, then repeating "Name,lat,lng" groups):
    // Place, Latitude, Longitude Cape Maria van Diemen,-34.40...,172.62... Ngatehe Point,-34.52...,173.41...
    var TIDES_CSV_URL =
      "https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/Testing/Tides%20-%20Tides.csv";

    // NIWA Tides API endpoint and key
    var NIWA_TIDES_API_URL = "https://api.niwa.co.nz/tides/data";
    var NIWA_TIDES_API_KEY = "qMPsVJPmEXB1b0YQtGJE5i9bnzOWOq1O";

    // Build NIWA request URL for one site, wrapped through CORS proxy
    function buildNiwaTideUrl(lat, lng) {
      var now = new Date();
      var startDate = now.toISOString().slice(0, 10); // yyyy-mm-dd (UTC)

      var baseUrl =
        NIWA_TIDES_API_URL +
        "?lat=" +
        encodeURIComponent(lat) +
        "&long=" +
        encodeURIComponent(lng) +
        "&numberOfDays=2" +
        "&startDate=" +
        encodeURIComponent(startDate) +
        "&datum=LAT" +
        "&apikey=" +
        encodeURIComponent(NIWA_TIDES_API_KEY);

      // Use same proxy pattern as other feeds
      return "https://corsproxy.io/?url=" + encodeURIComponent(baseUrl);
    }

    // Parse your compact CSV into [{ name, lat, lng }, ...]
    function parseTideCsv(text) {
      if (!text) {
        return [];
      }

      var raw = text.trim();

      // Remove header "Place, Latitude, Longitude"
      raw = raw.replace(/^Place,\s*Latitude,\s*Longitude\s*/i, "");

      var sites = [];

      // Remaining string is repeating: Name,lat,lng [space] Name2,lat2,lng2 ...
      while (raw.length) {
        var firstComma = raw.indexOf(",");
        if (firstComma === -1) {
          break;
        }
        var name = raw.slice(0, firstComma).trim();
        var rest = raw.slice(firstComma + 1).trim();

        var secondComma = rest.indexOf(",");
        if (secondComma === -1) {
          break;
        }
        var latStr = rest.slice(0, secondComma).trim();
        rest = rest.slice(secondComma + 1).trim();

        var nextSpace = rest.indexOf(" ");
        var lngStr;
        var remainder;
        if (nextSpace === -1) {
          lngStr = rest.trim();
          remainder = "";
        } else {
          lngStr = rest.slice(0, nextSpace).trim();
          remainder = rest.slice(nextSpace + 1).trim();
        }

        var lat = parseFloat(latStr);
        var lng = parseFloat(lngStr);

        if (!isNaN(lat) && !isNaN(lng) && name) {
          sites.push({ name: name, lat: lat, lng: lng });
        }

        raw = remainder;
      }

      return sites;
    }

    // Normalise NIWA response into sorted [{ time: Date, height: number }, ...]
    function normaliseNiwaTideValues(data) {
      if (!data || !data.values) {
        return [];
      }

      var series = [];
      var rawValues = data.values;

      for (var i = 0; i < rawValues.length; i++) {
        var v = rawValues[i];
        var timeStr;
        var height;

        if (Array.isArray(v)) {
          timeStr = v[0];
          height = parseFloat(v[1]);
        } else {
          timeStr = v.time || v.dateTime || v[0];
          if (v.value != null) {
            height = parseFloat(v.value);
          } else if (v.height != null) {
            height = parseFloat(v.height);
          } else {
            height = parseFloat(v[1]);
          }
        }

        if (!timeStr || !isFinite(height)) {
          continue;
        }

        var t = new Date(timeStr);
        if (isNaN(t.getTime())) {
          continue;
        }

        series.push({ time: t, height: height });
      }

      series.sort(function (a, b) {
        return a.time - b.time;
      });

      return series;
    }

    // Detect local high and low tide events from a height time series
    function detectTideEvents(series) {
      var events = [];
      if (!series || series.length < 3) {
        return events;
      }

      for (var i = 1; i < series.length - 1; i++) {
        var prev = series[i - 1];
        var cur = series[i];
        var next = series[i + 1];

        var type = null;
        if (cur.height >= prev.height && cur.height >= next.height) {
          type = "H"; // high
        } else if (cur.height <= prev.height && cur.height <= next.height) {
          type = "L"; // low
        }

        if (type) {
          events.push({
            type: type,
            time: cur.time,
            height: cur.height
          });
        }
      }

      return events;
    }

    // Summarise: last high, last low, next high, next low, and current height
        // Summarise: last high, last low, next high, next low, and current height
    function summariseTideState(series) {
      var events = detectTideEvents(series);
      if (!events.length) {
        return null;
      }

      var now = new Date();

      var lastEvent = null;
      var nextEvent = null;
      var lastHigh = null;
      var nextHigh = null;
      var lastLow = null;
      var nextLow = null;

      for (var i = 0; i < events.length; i++) {
        var e = events[i];

        if (e.time <= now) {
          if (!lastEvent || e.time > lastEvent.time) {
            lastEvent = e;
          }
          if (e.type === "H" && (!lastHigh || e.time > lastHigh.time)) {
            lastHigh = e;
          }
          if (e.type === "L" && (!lastLow || e.time > lastLow.time)) {
            lastLow = e;
          }
        }

        if (e.time >= now) {
          if (!nextEvent || e.time < nextEvent.time) {
            nextEvent = e;
          }
          if (e.type === "H" && (!nextHigh || e.time < nextHigh.time)) {
            nextHigh = e;
          }
          if (e.type === "L" && (!nextLow || e.time < nextLow.time)) {
            nextLow = e;
          }
        }
      }

      var currentHeight = null;
      var betweenPercent = null;

      if (
        lastEvent &&
        nextEvent &&
        nextEvent.time.getTime() > lastEvent.time.getTime()
      ) {
        var totalMs = nextEvent.time.getTime() - lastEvent.time.getTime();
        var elapsedMs = now.getTime() - lastEvent.time.getTime();
        var frac = elapsedMs / totalMs;

        if (frac < 0) {
          frac = 0;
        }
        if (frac > 1) {
          frac = 1;
        }

        betweenPercent = Math.round(frac * 100);
        currentHeight =
          lastEvent.height + frac * (nextEvent.height - lastEvent.height);
      }

      // Determine tide direction (going in or out) from last and next events
      var direction = null;
      if (lastEvent && nextEvent) {
        if (lastEvent.type === "L" && nextEvent.type === "H") {
          direction = "rising"; // tide coming in
        } else if (lastEvent.type === "H" && nextEvent.type === "L") {
          direction = "falling"; // tide going out
        }
      }

      return {
        lastHigh: lastHigh,
        lastLow: lastLow,
        nextHigh: nextHigh,
        nextLow: nextLow,
        currentHeight: currentHeight,
        betweenPercent: betweenPercent,
        direction: direction
      };
    }


    function formatTideTime(evt) {
      if (!evt || !evt.time) {
        return "n/a";
      }
      return evt.time.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    function formatTideHeight(evt) {
      if (!evt || typeof evt.height !== "number" || isNaN(evt.height)) {
        return "";
      }
      return evt.height.toFixed(2) + " m";
    }

    function formatCurrentHeight(h) {
      if (typeof h !== "number" || !isFinite(h)) {
        return "n/a";
      }
      return h.toFixed(2) + " m";
    }

       function addTideMarker(site, summary) {
      var direction = summary.direction;
      var arrowChar =
        direction === "rising" ? "⬆" :
        direction === "falling" ? "⬇" :
        "•";

      var directionLabel =
        direction === "rising"
          ? "Incoming (rising)"
          : direction === "falling"
          ? "Outgoing (falling)"
          : "Unknown";

      var popupHtml =
        "<strong>" + site.name + "</strong><br>" +
        "Estimated current height: " +
        formatCurrentHeight(summary.currentHeight) +
        "<br>" +
        "Tide direction: " + arrowChar + " " + directionLabel + "<br>" +
        (summary.betweenPercent != null
          ? "Between last and next tide: " +
            summary.betweenPercent +
            "% of the way<br><br>"
          : "<br>") +
        "<strong>Last high:</strong> " +
        formatTideTime(summary.lastHigh) +
        (summary.lastHigh ? " (" + formatTideHeight(summary.lastHigh) + ")" : "") +
        "<br>" +
        "<strong>Last low:</strong> " +
        formatTideTime(summary.lastLow) +
        (summary.lastLow ? " (" + formatTideHeight(summary.lastLow) + ")" : "") +
        "<br>" +
        "<strong>Next high:</strong> " +
        formatTideTime(summary.nextHigh) +
        (summary.nextHigh ? " (" + formatTideHeight(summary.nextHigh) + ")" : "") +
        "<br>" +
        "<strong>Next low:</strong> " +
        formatTideTime(summary.nextLow) +
        (summary.nextLow ? " (" + formatTideHeight(summary.nextLow) + ")" : "");

      // Use tide specific icon with arrow
      var marker = L.marker([site.lat, site.lng], {
        icon: makeTideIcon(MARKER_CONFIG.tides.defaultColor, direction)
      }).bindPopup(popupHtml);

      layerTides.addLayer(marker);
    }


    function loadTides() {
      fetch(TIDES_CSV_URL)
        .then(function (res) {
          return res.text();
        })
        .then(function (csvText) {
          var sites = parseTideCsv(csvText);
          if (!sites.length) {
            console.warn("No tide sites parsed from CSV");
            return;
          }

          sites.forEach(function (site) {
            var url = buildNiwaTideUrl(site.lat, site.lng);

            fetch(url)
              .then(function (res) {
                return res.json();
              })
              .then(function (data) {
                var series = normaliseNiwaTideValues(data);
                if (!series.length) {
                  return;
                }
                var summary = summariseTideState(series);
                if (!summary) {
                  return;
                }
                addTideMarker(site, summary);
              })
              .catch(function (err) {
                console.warn("Tide data load failed for site", site.name, err);
              });
          });
        })
        .catch(function (err) {
          console.warn("Tide CSV load failed", err);
        });
    }

    // Kick off tide load
    loadTides();


    // 3. MetService Severe Weather Watches, Warnings and Advisories (Atom + CAP)
var METSERVICE_ATOM_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/alerts/archive/latest_2025-11-08T06-24-52-084Z.xml");

// Colour helper based on title text
function metserviceColourForTitle(title) {
  var t = (title || "").toLowerCase();
  var color = "#1976d2";

  if (t.indexOf("warning") !== -1) {
    color = "#f44336";
  }
  if (t.indexOf("watch") !== -1) {
    color = "#2196f3";
  }
  if (t.indexOf("orange") !== -1) {
    color = "#ff9800";
  }
  if (t.indexOf("red") !== -1) {
    color = "#b71c1c";
  }

  return color;
}

// Use your existing Far North bounding box if available
function polygonTouchesFarNorth(latlngs) {
  if (typeof isInFarNorth !== "function") {
    return true; // if no helper, keep everything
  }
  for (var i = 0; i < latlngs.length; i++) {
    var pt = latlngs[i];
    if (isInFarNorth(pt[0], pt[1])) {
      return true;
    }
  }
  return false;
}

function loadMetserviceWeatherAlerts(atomUrl, targetLayer) {
  fetch(atomUrl)
    .then(function (res) { return res.text(); })
    .then(function (atomText) {
      var parser = new DOMParser();
      var atom = parser.parseFromString(atomText, "application/xml");

      var entries = atom.getElementsByTagName("entry");
      var tasks = [];

      for (var i = 0; i < entries.length; i++) {
        (function (entry) {
          var titleEl = entry.getElementsByTagName("title")[0];
          var summaryEl = entry.getElementsByTagName("summary")[0];

          var links = entry.getElementsByTagName("link");
          var capLinkEl = null;
          for (var j = 0; j < links.length; j++) {
            var rel = links[j].getAttribute("rel") || "";
            var type = links[j].getAttribute("type") || "";
            if (type.indexOf("cap+xml") !== -1) {
              capLinkEl = links[j];
              break;
            }
          }
          if (!capLinkEl && links.length) {
            capLinkEl = links[0];
          }

          var title = titleEl ? titleEl.textContent : "MetService Weather Alert";
          var summary = summaryEl ? summaryEl.textContent : "";
          var capUrl = capLinkEl ? capLinkEl.getAttribute("href") : null;

          if (!capUrl) {
            return;
          }

          var proxiedCapUrl = "https://corsproxy.io/?url=" + encodeURIComponent(capUrl);

          var task = fetch(proxiedCapUrl)
            .then(function (res) { return res.text(); })
            .then(function (capText) {
              var capDoc = parser.parseFromString(capText, "application/xml");

              var infoEl = capDoc.getElementsByTagName("info")[0];
              if (!infoEl) {
                return;
              }

              var eventEl = infoEl.getElementsByTagName("event")[0];
              var headlineEl = infoEl.getElementsByTagName("headline")[0];
              var descriptionEl = infoEl.getElementsByTagName("description")[0];
              var effectiveEl = infoEl.getElementsByTagName("effective")[0];
              var expiresEl = infoEl.getElementsByTagName("expires")[0];

              var eventName = eventEl ? eventEl.textContent : title;
              var headline = headlineEl ? headlineEl.textContent : title;
              var description = descriptionEl ? descriptionEl.textContent : summary;
              var effective = effectiveEl ? effectiveEl.textContent : "";
              var expires = expiresEl ? expiresEl.textContent : "";

              var colour = metserviceColourForTitle(title || eventName);

              var areaEls = infoEl.getElementsByTagName("area");
              var polygonsAddedForAlert = 0;

              for (var a = 0; a < areaEls.length; a++) {
                var areaEl = areaEls[a];
                var areaDescEl = areaEl.getElementsByTagName("areaDesc")[0];
                var areaDesc = areaDescEl ? areaDescEl.textContent : "";
                var polyEls = areaEl.getElementsByTagName("polygon");

                if (!polyEls.length) {
                  continue;
                }

                for (var pIdx = 0; pIdx < polyEls.length; pIdx++) {
                  var coordsStr = polyEls[pIdx].textContent.trim();
                  if (!coordsStr) {
                    continue;
                  }

                  var pointPairs = coordsStr.split(/\s+/);
                  var latlngs = [];

                  for (var k = 0; k < pointPairs.length; k++) {
                    var pair = pointPairs[k].split(",");
                    if (pair.length !== 2) {
                      continue;
                    }
                    var lat = parseFloat(pair[0]);
                    var lng = parseFloat(pair[1]);
                    if (isNaN(lat) || isNaN(lng)) {
                      continue;
                    }
                    latlngs.push([lat, lng]);
                  }

                  if (!latlngs.length) {
                    continue;
                  }

                  // Only keep polygons that touch the Far North
                  if (!polygonTouchesFarNorth(latlngs)) {
                    continue;
                  }

                  var popupHtml =
                    "<strong>" + headline + "</strong><br>" +
                    "<em>" + eventName + "</em><br><br>" +
                    (areaDesc ? "<strong>Area:</strong> " + areaDesc + "<br><br>" : "") +
                    (description ? nl2br(description) + "<br><br>" : "") +
                    (effective ? "<strong>From:</strong> " + effective + "<br>" : "") +
                    (expires ? "<strong>Until:</strong> " + expires + "<br>" : "");

                  var polygon = L.polygon(latlngs, {
                    color: colour,
                    weight: 2,
                    fillOpacity: 0.15
                  }).bindPopup(popupHtml);

                  polygon.addTo(targetLayer);
                  polygonsAddedForAlert++;
                }
              }

              // Fallback marker when no polygons were added for this alert
              if (!polygonsAddedForAlert) {
                var marker = L.marker(map.getCenter(), {
                  icon: makeIcon(colour)
                }).bindPopup(
                  "<strong>" + headline + "</strong><br>" +
                  "<em>" + eventName + "</em><br><br>" +
                  (description ? nl2br(description) + "<br><br>" : "") +
                  (effective ? "<strong>From:</strong> " + effective + "<br>" : "") +
                  (expires ? "<strong>Until:</strong> " + expires + "<br>" : "")
                );
                targetLayer.addLayer(marker);
              }
            })
            .catch(function (err) {
              console.warn("MetService CAP alert load failed", err);
            });

          tasks.push(task);
        })(entries[i]);
      }

      return Promise.all(tasks);
    })
    .catch(function (err) {
      console.warn("MetService Atom feed load failed", err);
    });
}

// Load MetService feed
loadMetserviceWeatherAlerts(METSERVICE_ATOM_URL, layerMetServiceWarnings);


   // 4. Civil Defence Alerts from Atom + CAP feed
// Civil Defence Atom feed that embeds CAP alerts in <content>
var CIVIL_DEFENCE_ATOM_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/alerts/CivilDefenceTest.xml");

// Optional helper if you want to reuse elsewhere
function nl2br(text) {
  return text ? text.replace(/\n/g, "<br>") : "";
}

function loadCivilDefenceAtomCap(url, targetLayer) {
  fetch(url)
    .then(function (res) { return res.text(); })
    .then(function (xmlText) {
      var parser = new DOMParser();
      var atom = parser.parseFromString(xmlText, "application/xml");

      var entries = atom.getElementsByTagName("entry");
      for (var i = 0; i < entries.length; i++) {
        var entry = entries[i];

        var titleEl = entry.getElementsByTagName("title")[0];
        var summaryEl = entry.getElementsByTagName("summary")[0];
        var linkEl = entry.getElementsByTagName("link")[0];
        var contentEl = entry.getElementsByTagName("content")[0];

        var title = titleEl ? titleEl.textContent : "Civil Defence Alert";
        var summaryText = summaryEl ? summaryEl.textContent : "";
        var linkHref = "";
        if (linkEl) {
          linkHref = linkEl.getAttribute("href") || linkEl.textContent;
        }

        var polygonsAdded = 0;

        if (contentEl) {
          // This is the CAP XML as text
          var capText = contentEl.textContent;
          if (capText) {
            var capDoc = parser.parseFromString(capText, "application/xml");

            var infoEl = capDoc.getElementsByTagName("info")[0];
            if (infoEl) {
              var headlineEl = infoEl.getElementsByTagName("headline")[0];
              var descriptionEl = infoEl.getElementsByTagName("description")[0];
              var areaEl = infoEl.getElementsByTagName("area")[0];

              var areaDescEl = areaEl ? areaEl.getElementsByTagName("areaDesc")[0] : null;
              var polyEls = areaEl ? areaEl.getElementsByTagName("polygon") : [];

              var headline = headlineEl ? headlineEl.textContent : title;
              var description = descriptionEl ? descriptionEl.textContent : summaryText;
              var areaDesc = areaDescEl ? areaDescEl.textContent : "";

              for (var j = 0; j < polyEls.length; j++) {
                var coordsStr = polyEls[j].textContent.trim();
                if (!coordsStr) {
                  continue;
                }

                var pointPairs = coordsStr.split(/\s+/);
                var latlngs = [];

                pointPairs.forEach(function (pair) {
                  var parts = pair.split(",");
                  if (parts.length !== 2) {
                    return;
                  }
                  var lat = parseFloat(parts[0]);
                  var lng = parseFloat(parts[1]);
                  if (isNaN(lat) || isNaN(lng)) {
                    return;
                  }
                  latlngs.push([lat, lng]);
                });

                if (!latlngs.length) {
                  continue;
                }

                var polygon = L.polygon(latlngs, {
                  color: "#ff9800",
                  weight: 2,
                  fillOpacity: 0.15
                });

                var popupHtml =
                  "<strong>" + headline + "</strong><br>" +
                  "<em>Civil Defence Mobile Alert</em><br><br>" +
                  (areaDesc ? "<strong>Areas:</strong> " + areaDesc + "<br><br>" : "") +
                  (description ? nl2br(description) + "<br><br>" : "") +
                  (!description && summaryText ? nl2br(summaryText) + "<br><br>" : "") +
                  (linkHref ? '<a href="' + linkHref + '" target="_blank" rel="noopener">View full alert</a>' : "");

                polygon.bindPopup(popupHtml);
                polygon.addTo(targetLayer);
                polygonsAdded++;
              }
            }
          }
        }

        // Fallback marker if no polygons found
        if (!polygonsAdded) {
          var marker = L.marker(map.getCenter(), {
            icon: makeIcon("#ff9800")
          }).bindPopup(
            "<strong>" + title + "</strong><br><br>" +
            (summaryText ? nl2br(summaryText) + "<br><br>" : "") +
            (linkHref ? '<a href="' + linkHref + '" target="_blank" rel="noopener">View full alert</a>' : "")
          );
          targetLayer.addLayer(marker);
        }
      }
    })
    .catch(function (err) {
      console.warn("Civil Defence Atom load failed", err);
    });
}

// Load Civil Defence feed
loadCivilDefenceAtomCap(CIVIL_DEFENCE_ATOM_URL, layerCivilDefenceAlerts);

// 5. Top Energy Power Outages - KMZ polygons + regions + outages

var TOP_ENERGY_OUTAGES_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/Testing/TopEnergy/outages%20(1028211125).json");
var TOP_ENERGY_REGIONS_URL =
  "https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/Testing/TopEnergy/regions%20(1028211125).json";

var TOP_ENERGY_KMZ_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://github.com/almokinsgov/NZSHAPE/raw/refs/heads/main/Testing/TopEnergy/polygonsActiveAll%20(103421112025).kmz");

// Config to control which outage types are shown as pins
// Set a type to false to hide that type
var POWER_OUTAGE_TYPES_VISIBLE = {
  unplanned: true,
  plannedActive: true,
  planned: true
};

// 5.1 Load KMZ polygons as non interactive background
function addTopEnergyPolygons(kmzUrl, targetLayer) {
  if (typeof JSZip === "undefined") {
    console.warn("JSZip is required to parse KMZ polygons");
    return;
  }

  fetch(kmzUrl)
    .then(function (res) { return res.arrayBuffer(); })
    .then(function (arrayBuffer) {
      return JSZip.loadAsync(arrayBuffer);
    })
    .then(function (zip) {
      var kmlFile = zip.file("doc.kml");
      if (!kmlFile) {
        var candidates = zip.file(/\.kml$/i);
        if (candidates && candidates.length) {
          kmlFile = candidates[0];
        }
      }
      if (!kmlFile) {
        console.warn("No KML file found inside Top Energy KMZ");
        return null;
      }
      return kmlFile.async("string");
    })
    .then(function (kmlText) {
      if (!kmlText) {
        return;
      }
      var parser = new DOMParser();
      var kmlDoc = parser.parseFromString(kmlText, "application/xml");

      var placemarks = kmlDoc.getElementsByTagName("Placemark");
      for (var i = 0; i < placemarks.length; i++) {
        var pm = placemarks[i];
        var polygons = pm.getElementsByTagName("Polygon");
        for (var j = 0; j < polygons.length; j++) {
          var poly = polygons[j];
          var coordsEls = poly.getElementsByTagName("coordinates");
          if (!coordsEls.length) {
            continue;
          }
          var coordsText = coordsEls[0].textContent;
          if (!coordsText) {
            continue;
          }

          // KML coordinates: lon,lat,alt lon,lat,alt ...
          var pairs = coordsText.trim().split(/\s+/);
          var latlngs = [];
          for (var pIdx = 0; pIdx < pairs.length; pIdx++) {
            var parts = pairs[pIdx].split(",");
            if (parts.length < 2) {
              continue;
            }
            var lon = parseFloat(parts[0]);
            var lat = parseFloat(parts[1]);
            if (isNaN(lat) || isNaN(lon)) {
              continue;
            }
            latlngs.push([lat, lon]);
          }

          if (!latlngs.length) {
            continue;
          }

          // Polygons are visual only not selectable
          var polygon = L.polygon(latlngs, {
            color: "#e91e63",
            weight: 1,
            fillOpacity: 0.05,
            interactive: false
          });

          polygon.addTo(targetLayer);
        }
      }
    })
    .catch(function (err) {
      console.warn("Top Energy KMZ polygons load failed", err);
    });
}

// 5.2 Join outages to region details and create one pin per outage
function buildTopEnergyOutageMarkers(regionsData, outagesData, targetLayer) {
  // Build lookup of region details by id (regions.*[].name)
  var regionDetailsById = {};

  Object.keys(regionsData || {}).forEach(function (key) {
    var value = regionsData[key];
    if (!Array.isArray(value)) {
      return;
    }
    value.forEach(function (r) {
      if (!r || !r.name) {
        return;
      }
      // name in regions matches id in outages
      regionDetailsById[r.name] = r;
    });
  });

  // Use marker config for colours
  function colourForStatus(statusType) {
    var cfg = MARKER_CONFIG.powerOutages || {};
    if (statusType && cfg[statusType]) {
      return cfg[statusType];
    }
    return cfg.defaultColor || "#9e9e9e";
  }

  function statusLabel(statusType) {
    if (statusType === "unplanned") {
      return "Unplanned outage";
    }
    if (statusType === "plannedActive") {
      return "Planned outage (currently active)";
    }
    if (statusType === "planned") {
      return "Planned outage";
    }
    return "Outage";
  }

  function renderDetail(detail) {
    if (!detail) {
      return "<br>No additional detail available for this outage.";
    }

    var html = "";
    if (detail.circuitName) {
      html += "Circuit: " + detail.circuitName + "<br>";
    }
    if (detail.customersCurrentlyOff != null && detail.customersCurrentlyOff !== "") {
      html += "Customers affected: " + detail.customersCurrentlyOff + "<br>";
    }
    if (detail.startDateTime) {
      html += "From: " + detail.startDateTime + "<br>";
    }
    if (detail.endDateTime) {
      html += "Until: " + detail.endDateTime + "<br>";
    }
    if (detail.alternativeStartDateTime) {
      html += "Alt from: " + detail.alternativeStartDateTime + "<br>";
    }
    if (detail.alternativeEndDateTime) {
      html += "Alt until: " + detail.alternativeEndDateTime + "<br>";
    }
    if (detail.additionalInformation) {
      html += detail.additionalInformation + "<br>";
    }
    return html || "<br>No additional detail available for this outage.";
  }

  function addOutageMarkers(list, statusType) {
    if (!Array.isArray(list)) {
      return;
    }
    list.forEach(function (outage) {
      if (!outage || outage.lat == null || outage.lng == null || !outage.id) {
        return;
      }

      // Look up detail by matching outage.id to region name
      var detail = regionDetailsById[outage.id] || null;
      var colour = colourForStatus(statusType);

      var marker = L.circleMarker([outage.lat, outage.lng], {
        radius: 7,
        fillColor: colour,
        color: "#ffffff",
        weight: 1,
        fillOpacity: 0.9
      });

      var popupHtml =
        "<strong>Top Energy outage</strong><br>" +
        "Outage ID: " + outage.id + "<br>" +
        "Type: " + statusLabel(statusType) + "<br>" +
        renderDetail(detail);

      marker.bindPopup(popupHtml);
      marker.addTo(targetLayer);
    });
  }

  // Helper to check visibility config and add markers
  function addIfVisible(list, statusType) {
    if (!POWER_OUTAGE_TYPES_VISIBLE[statusType]) {
      return;
    }
    addOutageMarkers(list, statusType);
  }

  // Outages JSON has unplanned, planned and plannedActive lists of points
  // Config controls which types are shown
  addIfVisible(outagesData.unplanned, "unplanned");
  addIfVisible(outagesData.plannedActive, "plannedActive");
  addIfVisible(outagesData.planned, "planned");
}

// 5.3 Orchestrate Top Energy layer load
function loadTopEnergyOutages() {
  // Polygons as background
  addTopEnergyPolygons(TOP_ENERGY_KMZ_URL, layerPowerOutages);

  // Regions (detail) and outages (points) in parallel
  var regionsPromise = fetch(TOP_ENERGY_REGIONS_URL).then(function (res) { return res.json(); });
  var outagesPromise = fetch(TOP_ENERGY_OUTAGES_URL).then(function (res) { return res.json(); });

  Promise.all([regionsPromise, outagesPromise])
    .then(function (results) {
      var regionsData = results[0] || {};
      var outagesData = results[1] || {};
      buildTopEnergyOutageMarkers(regionsData, outagesData, layerPowerOutages);
    })
    .catch(function (err) {
      console.warn("Top Energy regions or outages load failed", err);
    });
}

// Kick off Top Energy load
loadTopEnergyOutages();

    <!-- 6. Water Outages from Asset Listing Code -->
    <!-- FNDC water outages asset listing feed, proxied for CORS -->
    var WATER_OUTAGES_URL =
      "https://corsproxy.io/?" +
      encodeURIComponent("https://www.fndc.govt.nz/services/water/Water-outage-updates/wateroutagesassetlistingfeed");

    // Which statuses to show on the map.
    // Adjust this list to include or exclude statuses such as "Restored"
    var WATER_OUTAGE_STATUS_FILTER = ["New", "Reported", "Under repairs", "Planned", "Restored"];

    function waterOutageStatusAllowed(status) {
      if (!status) {
        return false;
      }
      var trimmed = String(status).trim();
      return WATER_OUTAGE_STATUS_FILTER.indexOf(trimmed) !== -1;
    }
	   function waterOutageMarkerColor(status) {
      var cfg = MARKER_CONFIG.waterOutages || {};
      var key = String(status || "").trim();
      if (cfg.colorByStatus && cfg.colorByStatus[key]) {
        return cfg.colorByStatus[key];
      }
      return cfg.defaultColor || "#2196f3";
    }

    function loadWaterOutages() {
  fetch(WATER_OUTAGES_URL)
    .then(function (res) {
      // Asset listing feeds can sometimes be text rather than strict JSON
      return res.text();
    })
    .then(function (text) {
      var data;

      // Try to parse as JSON directly first
      try {
        data = JSON.parse(text);
      } catch (err) {
        // Fallback: some feeds are a bare list of objects without [ ]
        // and may end with a trailing comma
        var trimmed = text.trim();

        // Remove a trailing comma at the very end, eg "...},"
        trimmed = trimmed.replace(/,\s*$/, "");

        if (trimmed.charAt(0) !== "[") {
          trimmed = "[" + trimmed;
        }
        if (trimmed.charAt(trimmed.length - 1) !== "]") {
          trimmed = trimmed + "]";
        }

        try {
          data = JSON.parse(trimmed);
        } catch (err2) {
          console.warn("Could not parse water outages feed", err2);
          return;
        }
      }

      if (!Array.isArray(data)) {
        console.warn("Water outages feed was not an array", data);
        return;
      }

      data.forEach(function (item) {
        if (!item) {
          return;
        }

        // Latitude / longitude
        var lat = parseFloat(item.latitude || item.lat);
        var lng = parseFloat(item.longitude || item.lng);
        if (!isFinite(lat) || !isFinite(lng)) {
          return;
        }

        // Status filter
        if (
          WATER_OUTAGE_STATUS_FILTER.length &&
          !waterOutageStatusAllowed(item.status)
        ) {
          return;
        }

        // Build popup HTML with all requested fields
        var popupHtml =
          "<strong>FNDC water outage</strong><br>" +
          (item.name ? "Name: " + item.name + "<br>" : "") +
          (item.status ? "Status: " + item.status + "<br>" : "") +
          (item.address ? "Address: " + item.address + "<br>" : "") +
          (item.datelodged ? "Date lodged: " + item.datelodged + "<br>" : "") +
          (item.dateresolved
            ? "Date resolved: " + item.dateresolved + "<br>"
            : "");

        if (item.details) {
          // details already contains HTML <p> tags
          popupHtml += "<br>" + item.details;
        }

        if (item.description) {
          popupHtml += "<br><em>" + item.description + "</em>";
        }

        // Add as a pin / marker to the water outages layer
          var marker = L.circleMarker([lat, lng], {
          radius: 6,
          fillColor: waterOutageMarkerColor(item.status),
          color: "#ffffff",
          weight: 1,
          fillOpacity: 0.9
        });

        marker.bindPopup(popupHtml);
        marker.addTo(layerWaterOutages);
      });
    })
    .catch(function (err) {
      console.warn("Water outages load failed", err);
    });
}


    // Kick off water outages load
    loadWaterOutages();


    // 7. Road Warnings, Closures and Roadworks from NZTA delays.json
// Live NZTA feed
var ROAD_WARNINGS_URL = "https://corsproxy.io/?url=https://www.journeys.nzta.govt.nz/assets/map-data-cache/delays.json";

// Optional: limit to Far North by simple bounding box
// Adjust if you want a different cut
function isInFarNorth(lat, lng) {
  // Rough box for Far North District
  // North of about -35.9 and west of about 174.4
  return lat > -35.9 && lat < -34.2 && lng > 172.0 && lng < 174.6;
}

function nztaPointColor(feature) {
  var p = feature.properties || {};
  var t = (p.type || "").toLowerCase();
  var impact = (p.Impact || "").toLowerCase();
  var cfg = MARKER_CONFIG.nzta && MARKER_CONFIG.nzta.point || {};
  var key = "";

  if (t === "closures" || impact.indexOf("closed") !== -1) {
    key = "closures";
  } else if (t === "warnings" || impact.indexOf("caution") !== -1) {
    key = "warnings";
  } else if (t === "roadworks") {
    key = "roadworks";
  } else if (t === "hazards") {
    key = "hazards";
  }

  if (key && cfg[key]) {
    return cfg[key];
  }
  return cfg.defaultColor || "#1976d2";
}


function nztaStyle(feature) {
  var p = feature.properties || {};
  var t = (p.type || "").toLowerCase();
  var impact = (p.Impact || "").toLowerCase();

  var color = nztaPointColor(feature);
  var weight = 3;
  var dashArray = null;

  if (t === "warnings" || impact.indexOf("caution") !== -1) {
    dashArray = "4 4";
  } else if (t === "roadworks") {
    dashArray = "2 6";
  }

  return {
    color: color,
    weight: weight,
    dashArray: dashArray,
    opacity: 0.9
  };
}


function nztaPointToLayer(feature, latlng) {
  var color = nztaPointColor(feature);
  return L.circleMarker(latlng, {
    radius: 10,
    fillColor: color,
    color: "#ffffff",
    weight: 1,
    fillOpacity: 0.9
  });
}


function nztaOnEachFeature(feature, layer) {
  var p = feature.properties || {};

  var title =
    p.Name ||
    p.LocationArea ||
    "Road Event";

  var html = "<strong>" + title + "</strong><br>";

  if (p.EventType) {
    html += "Type: " + p.EventType + "<br>";
  }
  if (p.EventDescription) {
    html += "Description: " + p.EventDescription + "<br>";
  }
  if (p.EventComments) {
    html += p.EventComments + "<br><br>";
  }
  if (p.Impact) {
    html += "Impact: " + p.Impact + "<br>";
  }
  if (p.StartDateNice) {
    html += "From: " + p.StartDateNice + "<br>";
  }
  if (p.EndDateNice) {
    html += "To: " + p.EndDateNice + "<br>";
  }
  if (p.ExpectedResolution) {
    html += "Expected: " + p.ExpectedResolution + "<br>";
  }
  if (p.AlternativeRoute) {
    html += "Detour: " + p.AlternativeRoute + "<br>";
  }

  layer.bindPopup(html);
}

fetch(ROAD_WARNINGS_URL)
  .then(function (res) { return res.json(); })
  .then(function (geojson) {

    // If you want all of NZ, remove this filter and pass geojson straight into L.geoJSON
    var filtered = {
      type: "FeatureCollection",
      features: geojson.features.filter(function (f) {
        if (!f.geometry) return false;

        var g = f.geometry;
        if (g.type === "Point") {
          var lng = g.coordinates[0];
          var lat = g.coordinates[1];
          return isInFarNorth(lat, lng);
        }

        // For MultiLineString, check first coordinate of first line
        if (g.type === "MultiLineString" &&
            g.coordinates &&
            g.coordinates.length &&
            g.coordinates[0].length) {
          var first = g.coordinates[0][0];
          var lng2 = first[0];
          var lat2 = first[1];
          return isInFarNorth(lat2, lng2);
        }

        return false;
      })
    };

    L.geoJSON(filtered, {
      style: nztaStyle,
      pointToLayer: nztaPointToLayer,
      onEachFeature: nztaOnEachFeature
    }).addTo(layerRoadWarnings);
  })
  .catch(function (err) {
    console.warn("NZTA delays load failed", err);
  });

// 8. Marae data (NZ wide from Māori Maps export)
var MARAE_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://raw.githubusercontent.com/almokinsgov/NZSHAPE/refs/heads/main/alerts/Marae%20data%20-%20data2.json");

    function loadMaraeLayer(url, targetLayer) {
  fetch(url)
    .then(function (res) { return res.json(); })
    .then(function (data) {
      if (!Array.isArray(data)) {
        console.warn("Marae data is not an array");
        return;
      }

      data.forEach(function (marae) {
        var lat = marae.latitude;
        var lng = marae.longitude;

        if (lat == null || lng == null) {
          return;
        }

        // Optional filter to Far North only
        // if (typeof isInFarNorth === "function" && !isInFarNorth(lat, lng)) {
        //   return;
        // }

        var title = marae.title || "Marae";
        var link = marae.Link || "";
        var district = marae.District || "";
        var imageUrl = marae["Image URL"] || "";

        var marker = L.marker([lat, lng], {
          icon: makeIcon(MARKER_CONFIG.marae.color)
        });

        var popupHtml =
          "<strong>" + title + "</strong><br>" +
          (district ? "<em>" + district + "</em><br><br>" : "<br>") +
          (link ? '<a href="' + link + '" target="_blank" rel="noopener">View marae page</a><br><br>' : "");

        if (imageUrl) {
          popupHtml +=
            '<a href="' + imageUrl + '" target="_blank" rel="noopener">' +
              '<img src="' + imageUrl + '" alt="Image of ' + title + '" ' +
              'style="max-width:180px;max-height:120px;display:block;margin-top:4px;border-radius:4px;object-fit:cover;" />' +
            "</a>";
        }

        marker.bindPopup(popupHtml);
        targetLayer.addLayer(marker);
      });
    })
    .catch(function (err) {
      console.warn("Marae data load failed", err);
    });
}

// Load Marae layer
loadMaraeLayer(MARAE_URL, layerMarae);


        // 9. Community Halls from FNDC District Facilities (ArcGIS pgeojson)
    var HALLS_GEOJSON_URL =
      "https://corsproxy.io/?url=" +
      encodeURIComponent(
        "https://services5.arcgis.com/H4FlrMy6xTBd6Ywx/ArcGIS/rest/services/DistrictFacilities_FNDC_public/FeatureServer/0/query?where=1%3D1&objectIds=&geometry=&geometryType=esriGeometryPoint&inSR=4326&spatialRel=esriSpatialRelIntersects&resultType=none&distance=0.0&units=esriSRUnit_Meter&outDistance=&relationParam=&returnGeodetic=false&outFields=*&returnGeometry=true&featureEncoding=esriDefault&multipatchOption=xyFootprint&maxAllowableOffset=&geometryPrecision=&outSR=&defaultSR=&datumTransformation=&applyVCSProjection=false&returnIdsOnly=false&returnUniqueIdsOnly=false&returnCountOnly=false&returnExtentOnly=false&returnQueryGeometry=false&returnDistinctValues=false&cacheHint=false&collation=&orderByFields=&groupByFieldsForStatistics=&returnAggIds=false&outStatistics=&having=&resultOffset=&resultRecordCount=&returnZ=false&returnM=false&returnTrueCurves=false&returnExceededLimitFeatures=true&quantizationParameters=&sqlFormat=none&f=pgeojson&token="
      );

    fetch(HALLS_GEOJSON_URL)
      .then(function (res) { return res.json(); })
      .then(function (geojson) {
        if (!geojson || !Array.isArray(geojson.features)) {
          console.warn("Community halls geojson has no features");
          return;
        }

        L.geoJSON(geojson, {
          // Only keep features that are halls
          filter: function (feature) {
            var p = feature && feature.properties;
            if (!p || p.asset_sub_type == null) {
              return false;
            }
            return String(p.asset_sub_type).toLowerCase() === "hall";
          },

          // Use a location pin style icon
          pointToLayer: function (feature, latlng) {
            return L.marker(latlng, {
              icon: makeIcon(MARKER_CONFIG.communityHalls.color)
            });
          },

          // Build popup using asset name and basic details
          onEachFeature: function (feature, layer) {
            var p = feature.properties || {};
            var name = p.system_name || "Community Hall";
            var community = p.community || "";
            var location = p.location || "";
            var owner = p.asset_owner || "";
            var status = p.status || "";

            var popup =
              "<strong>" + name + "</strong><br>" +
              (community ? "<em>" + community + "</em><br>" : "") +
              (location ? "Location: " + location + "<br>" : "") +
              (owner ? "Owner: " + owner + "<br>" : "") +
              (status ? "Status: " + status + "<br>" : "");

            layer.bindPopup(popup);
          }
        }).addTo(layerCommunityHalls);
      })
      .catch(function (err) {
        console.warn("Community halls geojson load failed", err);
      });


   // 10. NRC river data (live API)
var NRC_RIVERS_URL =
  "https://corsproxy.io/?url=" +
  encodeURIComponent("https://env.gurudigital.nz/WebApi/GetMapPoints/2?collectionId=19");
// For local testing you can instead use:
// var NRC_RIVERS_URL = "rivers.json";

// Helper to pick a colour based on current river trend
function riverColourForStatus(site) {
  var name = site.Icon && site.Icon.Name ? site.Icon.Name.toLowerCase() : "";
  var cfg = MARKER_CONFIG.rivers || {};

  if (cfg.colorByTrend) {
    if (name.indexOf("rising") !== -1 && cfg.colorByTrend.rising) {
      return cfg.colorByTrend.rising;
    }
    if (name.indexOf("falling") !== -1 && cfg.colorByTrend.falling) {
      return cfg.colorByTrend.falling;
    }
  }

  return cfg.defaultColor || "#4caf50";
}


// Build popup HTML for an NRC river site
function buildRiverPopup(site) {
  var title = site.DisplayName || site.Name || "River site";

  var html = "<strong>" + title + "</strong><br>";

  // Short description and LAWA link (Summary is already HTML)
  if (site.Summary) {
    html += site.Summary + "<br>";
  }

  var primary = site.PrimaryMeasurement;
  var secondary = site.SecondaryMeasurement;
  var primaryValue = site.PrimaryValue;
  var secondaryValue = site.SecondaryValue;

  if (primary && primaryValue) {
    html += "<br><strong>" +
      (primary.DisplayName || primary.Name || "Level") +
      ":</strong> " + primaryValue.Value +
      (primary.Units ? " " + primary.Units : "") +
      (primaryValue.FormattedTime && primaryValue.FormattedDate
        ? " at " + primaryValue.FormattedTime + " " + primaryValue.FormattedDate
        : "") +
      "<br>";
  }

  if (secondary && secondaryValue) {
    html += "<strong>" +
      (secondary.DisplayName || secondary.Name || "Flow") +
      ":</strong> " + secondaryValue.Value +
      (secondary.Units ? " " + secondary.Units : "") +
      (secondaryValue.FormattedTime && secondaryValue.FormattedDate
        ? " at " + secondaryValue.FormattedTime + " " + secondaryValue.FormattedDate
        : "") +
      "<br>";
  }

  var drought = site.DroughtInfo;
  if (drought) {
    if (drought.MALFText) {
      html += "<br><strong>MALF:</strong> " + drought.MALFText + "<br>";
    }
    if (drought.DMFText) {
      html += "<strong>DMF:</strong> " + drought.DMFText + "<br>";
    }
    if (drought.PercentDiffDMF) {
      html += "<strong>Relative to DMF:</strong> " + drought.PercentDiffDMF + "<br>";
    }
  }

  if (site.WebCamUrl) {
    html += '<br><a href="' + site.WebCamUrl +
      '" target="_blank" rel="noopener">View webcam</a><br>';
  }

  if (site.Image && site.Image.URL) {
    var imgUrl = "https://env.gurudigital.nz/" + site.Image.URL.replace(/^\/?/, "");
    html +=
      '<br><a href="' + imgUrl + '" target="_blank" rel="noopener">' +
        '<img src="' + imgUrl + '" alt="Image for ' + title + '"' +
        ' style="max-width:200px;max-height:130px;display:block;margin-top:4px;' +
        ' border-radius:4px;object-fit:cover;" />' +
      "</a>";
  }

  return html;
}

function loadNrcRivers(url, targetLayer) {
  fetch(url)
    .then(function (res) { return res.json(); })
    .then(function (sites) {
      if (!Array.isArray(sites)) {
        console.warn("NRC river data is not an array");
        return;
      }

      sites.forEach(function (site) {
        if (!site.HasLocation || site.Latitude == null || site.Longitude == null) {
          return;
        }

        // Optional Far North filter if you want to clip to district
        // if (typeof isInFarNorth === "function" &&
        //     !isInFarNorth(site.Latitude, site.Longitude)) {
        //   return;
        // }

        var lat = site.Latitude;
        var lng = site.Longitude;

        var marker = L.marker([lat, lng], {
          icon: makeIcon(riverColourForStatus(site))
        });

        marker.bindPopup(buildRiverPopup(site));
        targetLayer.addLayer(marker);
      });
    })
    .catch(function (err) {
      console.warn("NRC river data load failed", err);
    });
}

// Load NRC river layer
loadNrcRivers(NRC_RIVERS_URL, layerRivers);


  </script>
</body>
</html>

